<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Opencv (opencv.Opencv)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">opencv</a> &#x00BB; Opencv</nav><h1>Module <code>Opencv</code></h1></header><div class="spec module" id="module-Vector"><a href="#module-Vector" class="anchor"></a><code><span class="keyword">module</span> <a href="Vector/index.html">Vector</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Scalar"><a href="#module-Scalar" class="anchor"></a><code><span class="keyword">module</span> <a href="Scalar/index.html">Scalar</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Mat"><a href="#module-Mat" class="anchor"></a><code><span class="keyword">module</span> <a href="Mat/index.html">Mat</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Cvdata"><a href="#module-Cvdata" class="anchor"></a><code><span class="keyword">module</span> <a href="Cvdata/index.html">Cvdata</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-point2i"><a href="#type-point2i" class="anchor"></a><code><span class="keyword">type</span> point2i</code><code> = </code><code>{</code><table class="record"><tr id="type-point2i.x" class="anchored"><td class="def field"><a href="#type-point2i.x" class="anchor"></a><code>x : int;</code></td></tr><tr id="type-point2i.y" class="anchored"><td class="def field"><a href="#type-point2i.y" class="anchor"></a><code>y : int;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-point2f"><a href="#type-point2f" class="anchor"></a><code><span class="keyword">type</span> point2f</code><code> = </code><code>{</code><table class="record"><tr id="type-point2f.x" class="anchored"><td class="def field"><a href="#type-point2f.x" class="anchor"></a><code>x : float;</code></td></tr><tr id="type-point2f.y" class="anchored"><td class="def field"><a href="#type-point2f.y" class="anchor"></a><code>y : float;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-point2d"><a href="#type-point2d" class="anchor"></a><code><span class="keyword">type</span> point2d</code><code> = </code><code>{</code><table class="record"><tr id="type-point2d.x" class="anchored"><td class="def field"><a href="#type-point2d.x" class="anchor"></a><code>x : float;</code></td></tr><tr id="type-point2d.y" class="anchored"><td class="def field"><a href="#type-point2d.y" class="anchor"></a><code>y : float;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-rect2i"><a href="#type-rect2i" class="anchor"></a><code><span class="keyword">type</span> rect2i</code><code> = </code><code>{</code><table class="record"><tr id="type-rect2i.x" class="anchored"><td class="def field"><a href="#type-rect2i.x" class="anchor"></a><code>x : int;</code></td></tr><tr id="type-rect2i.y" class="anchored"><td class="def field"><a href="#type-rect2i.y" class="anchor"></a><code>y : int;</code></td></tr><tr id="type-rect2i.width" class="anchored"><td class="def field"><a href="#type-rect2i.width" class="anchor"></a><code>width : int;</code></td></tr><tr id="type-rect2i.height" class="anchored"><td class="def field"><a href="#type-rect2i.height" class="anchor"></a><code>height : int;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-size2i"><a href="#type-size2i" class="anchor"></a><code><span class="keyword">type</span> size2i</code><code> = </code><code>{</code><table class="record"><tr id="type-size2i.width" class="anchored"><td class="def field"><a href="#type-size2i.width" class="anchor"></a><code>width : int;</code></td></tr><tr id="type-size2i.height" class="anchored"><td class="def field"><a href="#type-size2i.height" class="anchor"></a><code>height : int;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-size2f"><a href="#type-size2f" class="anchor"></a><code><span class="keyword">type</span> size2f</code><code> = </code><code>{</code><table class="record"><tr id="type-size2f.width" class="anchored"><td class="def field"><a href="#type-size2f.width" class="anchor"></a><code>width : float;</code></td></tr><tr id="type-size2f.height" class="anchored"><td class="def field"><a href="#type-size2f.height" class="anchor"></a><code>height : float;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-rotated_rect"><a href="#type-rotated_rect" class="anchor"></a><code><span class="keyword">type</span> rotated_rect</code><code> = </code><code>{</code><table class="record"><tr id="type-rotated_rect.center" class="anchored"><td class="def field"><a href="#type-rotated_rect.center" class="anchor"></a><code>center : <a href="index.html#type-point2f">point2f</a>;</code></td></tr><tr id="type-rotated_rect.size" class="anchored"><td class="def field"><a href="#type-rotated_rect.size" class="anchor"></a><code>size : <a href="index.html#type-size2f">size2f</a>;</code></td></tr><tr id="type-rotated_rect.angle" class="anchored"><td class="def field"><a href="#type-rotated_rect.angle" class="anchor"></a><code>angle : float;</code></td></tr></table><code>}</code></dt></dl><aside><p>Data structure for salient point detectors.</p><p>The class instance stores a keypoint, i.e. a point feature found by one of many available keypoint detectors, such as Harris corner detector, #FAST, %StarDetector, %SURF, %SIFT etc.</p><p>The keypoint is characterized by the 2D position, scale (proportional to the diameter of the neighborhood that needs to be taken into account), orientation and some other parameters. The keypoint neighborhood is then analyzed by another algorithm that builds a descriptor (usually represented as a feature vector). The keypoints representing the same object in different images can then be matched using %KDTree or another method.</p></aside><div class="spec module" id="module-Key_point"><a href="#module-Key_point" class="anchor"></a><code><span class="keyword">module</span> <a href="Key_point/index.html">Key_point</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p>Class for matching keypoint descriptors</p><p>query descriptor index, train descriptor index, train image index, and distance between descriptors.</p></aside><div class="spec module" id="module-D_match"><a href="#module-D_match" class="anchor"></a><code><span class="keyword">module</span> <a href="D_match/index.html">D_match</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p>struct returned by cv::moments</p><p>The spatial moments <code>:m}_{ji} </code> are computed as:</p><p><code> \texttt{m} _{ji}= \sum _{x,y}  \left ( \texttt{array} (x,y)  \cdot x^j  \cdot y^i \right ) </code></p><p>The central moments <code>:mu}_{ji} </code> are computed as:</p><p><code> \texttt{mu} _{ji}= \sum _{x,y}  \left ( \texttt{array} (x,y)  \cdot (x -  \bar{x} )^j  \cdot (y -  \bar{y} )^i \right ) </code></p><p>where <code> (\bar{x}, \bar{y}) </code> is the mass center:</p><p><code> \bar{x} = \frac{\texttt{m}_{10}}{\texttt{m}_{00}} , \; \bar{y} = \frac{\texttt{m}_{01}}{\texttt{m}_{00}} </code></p><p>The normalized central moments <code>:nu}_{ij} </code> are computed as:</p><p><code> \texttt{nu} _{ji}= \frac{\texttt{mu}_{ji}}{\texttt{m}_{00}^{(i+j)/2+1}} . </code></p><p>Note: <code> \texttt{mu}_{00}=\texttt{m}_{00} </code>, <code> \texttt{nu}_{00}=1 </code> <code> \texttt{nu}_{10}=\texttt{mu}_{10}=\texttt{mu}_{01}=\texttt{mu}_{10}=0 </code> , hence the values are not stored.</p><p>The moments of a contour are defined in the same way but computed using the Green's formula (see &lt;http://en.wikipedia.org/wiki/Green_theorem&gt;). So, due to a limited raster resolution, the moments computed for a contour are slightly different from the moments computed for the same rasterized contour.</p><p>Note: Since the contour moments are computed using Green formula, you may get seemingly odd results for contours with self-intersections, e.g. a zero area (m00) for butterfly-shaped contours.</p></aside><div class="spec module" id="module-Moments"><a href="#module-Moments" class="anchor"></a><code><span class="keyword">module</span> <a href="Moments/index.html">Moments</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Mat1"><a href="#module-Mat1" class="anchor"></a><code><span class="keyword">module</span> <a href="Mat1/index.html">Mat1</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-U_mat"><a href="#module-U_mat" class="anchor"></a><code><span class="keyword">module</span> <a href="U_mat/index.html">U_mat</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Sparse_mat"><a href="#module-Sparse_mat" class="anchor"></a><code><span class="keyword">module</span> <a href="Sparse_mat/index.html">Sparse_mat</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Rng"><a href="#module-Rng" class="anchor"></a><code><span class="keyword">module</span> <a href="Rng/index.html">Rng</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p>This is a base class for all more or less complex algorithms in OpenCV</p><p>especially for classes of algorithms, for which there can be multiple implementations. The examples are stereo correspondence (for which there are algorithms like block matching, semi-global block matching, graph-cut etc.), background subtraction (which can be done using mixture-of-gaussians models, codebook-based algorithm etc.), optical flow (block matching, Lucas-Kanade, Horn-Schunck etc.).</p><p>Here is example of SimpleBlobDetector use in your application via Algorithm interface: Snippet: snippets/core_various.cpp Algorithm</p></aside><div class="spec module" id="module-Algorithm"><a href="#module-Algorithm" class="anchor"></a><code><span class="keyword">module</span> <a href="Algorithm/index.html">Algorithm</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p>finds arbitrary template in the grayscale image using Generalized Hough Transform</p></aside><div class="spec module" id="module-Generalized_hough"><a href="#module-Generalized_hough" class="anchor"></a><code><span class="keyword">module</span> <a href="Generalized_hough/index.html">Generalized_hough</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p>finds arbitrary template in the grayscale image using Generalized Hough Transform</p><p>Detects position only without translation and rotation Ballard1981 .</p></aside><div class="spec module" id="module-Generalized_hough_ballard"><a href="#module-Generalized_hough_ballard" class="anchor"></a><code><span class="keyword">module</span> <a href="Generalized_hough_ballard/index.html">Generalized_hough_ballard</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p>finds arbitrary template in the grayscale image using Generalized Hough Transform</p><p>Detects position, translation and rotation Guil1999 .</p></aside><div class="spec module" id="module-Generalized_hough_guil"><a href="#module-Generalized_hough_guil" class="anchor"></a><code><span class="keyword">module</span> <a href="Generalized_hough_guil/index.html">Generalized_hough_guil</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p>Base class for Contrast Limited Adaptive Histogram Equalization.</p></aside><div class="spec module" id="module-Clahe"><a href="#module-Clahe" class="anchor"></a><code><span class="keyword">module</span> <a href="Clahe/index.html">Clahe</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Subdiv2_d"><a href="#module-Subdiv2_d" class="anchor"></a><code><span class="keyword">module</span> <a href="Subdiv2_d/index.html">Subdiv2_d</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p>Line segment detector class</p><p>following the algorithm described at Rafael12 .</p><p>Note: Implementation has been removed due original code license conflict</p></aside><div class="spec module" id="module-Line_segment_detector"><a href="#module-Line_segment_detector" class="anchor"></a><code><span class="keyword">module</span> <a href="Line_segment_detector/index.html">Line_segment_detector</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Cv"><a href="#module-Cv" class="anchor"></a><code><span class="keyword">module</span> <a href="Cv/index.html">Cv</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p>Class for video capturing from video files, image sequences or cameras.</p><p>The class provides C++ API for capturing video from cameras or for reading video files and image sequences.</p><p>Here is how the class can be used: Include: samples/cpp/videocapture_basic.cpp</p><p>Note: In videoio_c &quot;C API&quot; the black-box structure <code>CvCapture</code> is used instead of %VideoCapture. Note:</p><ul><li>(C++) A basic sample on using the %VideoCapture interface can be found at <code>OPENCV_SOURCE_CODE/samples/cpp/videocapture_starter.cpp</code></li><li>(Python) A basic sample on using the %VideoCapture interface can be found at <code>OPENCV_SOURCE_CODE/samples/python/video.py</code></li><li>(Python) A multi threaded video processing sample can be found at <code>OPENCV_SOURCE_CODE/samples/python/video_threaded.py</code></li><li>(Python) %VideoCapture sample showcasing some features of the Video4Linux2 backend <code>OPENCV_SOURCE_CODE/samples/python/video_v4l2.py</code></li></ul></aside><div class="spec module" id="module-Video_capture"><a href="#module-Video_capture" class="anchor"></a><code><span class="keyword">module</span> <a href="Video_capture/index.html">Video_capture</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p>Video writer class.</p><p>The class provides C++ API for writing video files or image sequences.</p></aside><div class="spec module" id="module-Video_writer"><a href="#module-Video_writer" class="anchor"></a><code><span class="keyword">module</span> <a href="Video_writer/index.html">Video_writer</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-border_interpolate"><a href="#val-border_interpolate" class="anchor"></a><code><span class="keyword">val</span> border_interpolate : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int</code></dt><dd><p>Usage: <code>border_interpolate p len border_type</code></p><p>Computes the source location of an extrapolated pixel.</p><p>The function computes and returns the coordinate of a donor pixel corresponding to the specified extrapolated pixel when using the specified extrapolation border mode. For example, if you use cv::BORDER_WRAP mode in the horizontal direction, cv::BORDER_REFLECT_101 in the vertical direction and want to compute value of the &quot;virtual&quot; pixel Point(-5, 100) in a floating-point image img , it looks like:</p><pre><code class="ml">float val = img.at&lt;float&gt;(borderInterpolate(100, img.rows, cv::BORDER_REFLECT_101),
                          borderInterpolate(-5, img.cols, cv::BORDER_WRAP));</code></pre><p>Normally, the function is not called directly. It is used inside filtering functions and also in copyMakeBorder.</p><ul><li>Parameter: <code>p</code>: 0-based coordinate of the extrapolated pixel along one of the axes, likely \&lt;0 or \&gt;= len</li><li>Parameter: <code>len</code>: Length of the array along the corresponding axis.</li><li>Parameter: <code>border_type</code>: Border type, one of the #BorderTypes, except for #BORDER_TRANSPARENT and #BORDER_ISOLATED . When borderType==#BORDER_CONSTANT , the function always returns -1, regardless of p and len.</li></ul><p>See also: copyMakeBorder</p></dd></dl><dl><dt class="spec value" id="val-copy_make_border"><a href="#val-copy_make_border" class="anchor"></a><code><span class="keyword">val</span> copy_make_border : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;value:<a href="Scalar/index.html#type-t">Scalar.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>copy_make_border ?dst ?value src top bottom left right border_type</code></p><p>Forms a border around an image.</p><p>The function copies the source image into the middle of the destination image. The areas to the left, to the right, above and below the copied source image will be filled with extrapolated pixels. This is not what filtering functions based on it do (they extrapolate pixels on-fly), but what other more complex functions, including your own, may do to simplify image boundary handling.</p><p>The function supports the mode when src is already in the middle of dst . In this case, the function does not copy src itself but simply constructs the border, for example:</p><pre><code class="ml">// let border be the same in all directions
int border=2;
// constructs a larger image to fit both the image and the border
Mat gray_buf(rgb.rows + border*2, rgb.cols + border*2, rgb.depth());
// select the middle part of it w/o copying data
Mat gray(gray_canvas, Rect(border, border, rgb.cols, rgb.rows));
// convert image from RGB to grayscale
cvtColor(rgb, gray, COLOR_RGB2GRAY);
// form a border in-place
copyMakeBorder(gray, gray_buf, border, border,
               border, border, BORDER_REPLICATE);
// now do some custom filtering ...
...</code></pre><p>Note: When the source image is a part (ROI) of a bigger image, the function will try to use the pixels outside of the ROI to form a border. To disable this feature and always do extrapolation, as if src was not a ROI, use borderType | #BORDER_ISOLATED.</p><ul><li>Parameter: <code>src</code>: Source image.</li><li>Parameter: <code>dst</code>: Destination image of the same type as src and the size Size(src.cols+left+right, src.rows+top+bottom) .</li><li>Parameter: <code>top</code>: the top pixels</li><li>Parameter: <code>bottom</code>: the bottom pixels</li><li>Parameter: <code>left</code>: the left pixels</li><li>Parameter: <code>right</code>: Parameter specifying how many pixels in each direction from the source image rectangle to extrapolate. For example, top=1, bottom=1, left=1, right=1 mean that 1 pixel-wide border needs to be built.</li><li>Parameter: <code>border_type</code>: Border type. See borderInterpolate for details.</li><li>Parameter: <code>value</code>: Border value if borderType==BORDER_CONSTANT .</li></ul><p>See also: borderInterpolate</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">val</span> add : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;dtype:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>add ?dst ?mask ?dtype src1 src2</code></p><p>Calculates the per-element sum of two arrays or an array and a scalar.</p><p>The function add calculates:</p><ul><li>Sum of two arrays when both input arrays have the same size and the same number of channels: <code> \texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) +  \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0 </code></li><li>Sum of an array and a scalar when src2 is constructed from Scalar or has the same number of elements as <code>src1.channels()</code>: <code> \texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) +  \texttt{src2} ) \quad \texttt{if mask}(I) \ne0 </code></li><li>Sum of a scalar and an array when src1 is constructed from Scalar or has the same number of elements as <code>src2.channels()</code>: <code> \texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1} +  \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0 </code> where <code>I</code> is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently.</li></ul><p>The first function in the list above can be replaced with matrix expressions:</p><pre><code class="ml">dst = src1 + src2;
dst += src1; // equivalent to add(dst, src1, dst);</code></pre><p>The input arrays and the output array can all have the same or different depths. For example, you can add a 16-bit unsigned array to a 8-bit signed array and store the sum as a 32-bit floating-point array. Depth of the output array is determined by the dtype parameter. In the second and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this case, the output array will have the same depth as the input array, be it src1, src2 or both. Note: Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow.</p><ul><li>Parameter: <code>src1</code>: first input array or a scalar.</li><li>Parameter: <code>src2</code>: second input array or a scalar.</li><li>Parameter: <code>dst</code>: output array that has the same size and number of channels as the input array(s); the depth is defined by dtype or src1/src2.</li><li>Parameter: <code>mask</code>: optional operation mask - 8-bit single channel array, that specifies elements of the output array to be changed.</li><li>Parameter: <code>dtype</code>: optional depth of the output array (see the discussion below). See also: subtract, addWeighted, scaleAdd, Mat::convertTo</li></ul></dd></dl><dl><dt class="spec value" id="val-subtract"><a href="#val-subtract" class="anchor"></a><code><span class="keyword">val</span> subtract : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;dtype:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>subtract ?dst ?mask ?dtype src1 src2</code></p><p>Calculates the per-element difference between two arrays or array and a scalar.</p><p>The function subtract calculates:</p><ul><li>Difference between two arrays, when both input arrays have the same size and the same number of channels: <code> \texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) -  \texttt{src2}(I)) \quad \texttt{if mask}(I) \ne0 </code></li><li>Difference between an array and a scalar, when src2 is constructed from Scalar or has the same number of elements as <code>src1.channels()</code>: <code> \texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1}(I) -  \texttt{src2} ) \quad \texttt{if mask}(I) \ne0 </code></li><li>Difference between a scalar and an array, when src1 is constructed from Scalar or has the same number of elements as <code>src2.channels()</code>: <code> \texttt{dst}(I) =  \texttt{saturate} ( \texttt{src1} -  \texttt{src2}(I) ) \quad \texttt{if mask}(I) \ne0 </code></li><li>The reverse difference between a scalar and an array in the case of <code>SubRS</code>: <code> \texttt{dst}(I) =  \texttt{saturate} ( \texttt{src2} -  \texttt{src1}(I) ) \quad \texttt{if mask}(I) \ne0 </code> where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently.</li></ul><p>The first function in the list above can be replaced with matrix expressions:</p><pre><code class="ml">dst = src1 - src2;
dst -= src1; // equivalent to subtract(dst, src1, dst);</code></pre><p>The input arrays and the output array can all have the same or different depths. For example, you can subtract to 8-bit unsigned arrays and store the difference in a 16-bit signed array. Depth of the output array is determined by dtype parameter. In the second and third cases above, as well as in the first case, when src1.depth() == src2.depth(), dtype can be set to the default -1. In this case the output array will have the same depth as the input array, be it src1, src2 or both. Note: Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow.</p><ul><li>Parameter: <code>src1</code>: first input array or a scalar.</li><li>Parameter: <code>src2</code>: second input array or a scalar.</li><li>Parameter: <code>dst</code>: output array of the same size and the same number of channels as the input array.</li><li>Parameter: <code>mask</code>: optional operation mask; this is an 8-bit single channel array that specifies elements of the output array to be changed.</li><li>Parameter: <code>dtype</code>: optional depth of the output array See also: add, addWeighted, scaleAdd, Mat::convertTo</li></ul></dd></dl><dl><dt class="spec value" id="val-multiply"><a href="#val-multiply" class="anchor"></a><code><span class="keyword">val</span> multiply : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;scale:float</span> <span>&#45;&gt;</span> <span>?&#8288;dtype:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>multiply ?dst ?scale ?dtype src1 src2</code></p><p>Calculates the per-element scaled product of two arrays.</p><p>The function multiply calculates the per-element product of two arrays:</p><p><code> \texttt{dst} (I)= \texttt{saturate} ( \texttt{scale} \cdot \texttt{src1} (I)  \cdot \texttt{src2} (I)) </code></p><p>There is also a MatrixExpressions -friendly variant of the first function. See Mat::mul .</p><p>For a not-per-element matrix product, see gemm .</p><p>Note: Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow.</p><ul><li>Parameter: <code>src1</code>: first input array.</li><li>Parameter: <code>src2</code>: second input array of the same size and the same type as src1.</li><li>Parameter: <code>dst</code>: output array of the same size and type as src1.</li><li>Parameter: <code>scale</code>: optional scale factor.</li><li>Parameter: <code>dtype</code>: optional depth of the output array See also: add, subtract, divide, scaleAdd, addWeighted, accumulate, accumulateProduct, accumulateSquare, Mat::convertTo</li></ul></dd></dl><dl><dt class="spec value" id="val-divide1"><a href="#val-divide1" class="anchor"></a><code><span class="keyword">val</span> divide1 : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;scale:float</span> <span>&#45;&gt;</span> <span>?&#8288;dtype:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>divide1 ?dst ?scale ?dtype src1 src2</code></p><p>Performs per-element division of two arrays or a scalar by an array.</p><p>The function cv::divide divides one array by another: <code> \texttt{dst(I) = saturate(src1(I)*scale/src2(I))} </code> or a scalar by an array when there is no src1 : <code> \texttt{dst(I) = saturate(scale/src2(I))} </code></p><p>Different channels of multi-channel arrays are processed independently.</p><p>For integer types when src2(I) is zero, dst(I) will also be zero.</p><p>Note: In case of floating point data there is no special defined behavior for zero src2(I) values. Regular floating-point division is used. Expect correct IEEE-754 behaviour for floating-point data (with NaN, Inf result values).</p><p>Note: Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow.</p><ul><li>Parameter: <code>src1</code>: first input array.</li><li>Parameter: <code>src2</code>: second input array of the same size and type as src1.</li><li>Parameter: <code>scale</code>: scalar factor.</li><li>Parameter: <code>dst</code>: output array of the same size and type as src2.</li><li>Parameter: <code>dtype</code>: optional depth of the output array; if -1, dst will have depth src2.depth(), but in case of an array-by-array division, you can only pass -1 when src1.depth()==src2.depth(). See also: multiply, add, subtract</li></ul></dd></dl><dl><dt class="spec value" id="val-divide2"><a href="#val-divide2" class="anchor"></a><code><span class="keyword">val</span> divide2 : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;dtype:int</span> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>divide2 ?dst ?dtype scale src2</code></p></dd></dl><dl><dt class="spec value" id="val-scale_add"><a href="#val-scale_add" class="anchor"></a><code><span class="keyword">val</span> scale_add : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>scale_add ?dst src1 alpha src2</code></p><p>Calculates the sum of a scaled array and another array.</p><p>The function scaleAdd is one of the classical primitive linear algebra operations, known as DAXPY or SAXPY in <code>BLAS</code>(http://en.wikipedia.org/wiki/Basic_Linear_Algebra_Subprograms). It calculates the sum of a scaled array and another array: <code> \texttt{dst} (I)= \texttt{scale} \cdot \texttt{src1} (I) +  \texttt{src2} (I) </code> The function can also be emulated with a matrix expression, for example:</p><pre><code class="ml">Mat A(3, 3, CV_64F);
...
A.row(0) = A.row(1)*2 + A.row(2);</code></pre><ul><li>Parameter: <code>src1</code>: first input array.</li><li>Parameter: <code>alpha</code>: scale factor for the first array.</li><li>Parameter: <code>src2</code>: second input array of the same size and type as src1.</li><li>Parameter: <code>dst</code>: output array of the same size and type as src1. See also: add, addWeighted, subtract, Mat::dot, Mat::convertTo</li></ul></dd></dl><dl><dt class="spec value" id="val-add_weighted"><a href="#val-add_weighted" class="anchor"></a><code><span class="keyword">val</span> add_weighted : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;dtype:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>add_weighted ?dst ?dtype src1 alpha src2 beta gamma</code></p><p>Calculates the weighted sum of two arrays.</p><p>The function addWeighted calculates the weighted sum of two arrays as follows: <code> \texttt{dst} (I)= \texttt{saturate} ( \texttt{src1} (I)* \texttt{alpha} +  \texttt{src2} (I)* \texttt{beta} +  \texttt{gamma} ) </code> where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently. The function can be replaced with a matrix expression:</p><pre><code class="ml">dst = src1*alpha + src2*beta + gamma;</code></pre><p>Note: Saturation is not applied when the output array has the depth CV_32S. You may even get result of an incorrect sign in the case of overflow.</p><ul><li>Parameter: <code>src1</code>: first input array.</li><li>Parameter: <code>alpha</code>: weight of the first array elements.</li><li>Parameter: <code>src2</code>: second input array of the same size and channel number as src1.</li><li>Parameter: <code>beta</code>: weight of the second array elements.</li><li>Parameter: <code>gamma</code>: scalar added to each sum.</li><li>Parameter: <code>dst</code>: output array that has the same size and number of channels as the input arrays.</li><li>Parameter: <code>dtype</code>: optional depth of the output array; when both input arrays have the same depth, dtype can be set to -1, which will be equivalent to src1.depth(). See also: add, subtract, scaleAdd, Mat::convertTo</li></ul></dd></dl><dl><dt class="spec value" id="val-convert_scale_abs"><a href="#val-convert_scale_abs" class="anchor"></a><code><span class="keyword">val</span> convert_scale_abs : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;beta:float</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>convert_scale_abs ?dst ?alpha ?beta src</code></p><p>Scales, calculates absolute values, and converts the result to 8-bit.</p><p>On each element of the input array, the function convertScaleAbs performs three operations sequentially: scaling, taking an absolute value, conversion to an unsigned 8-bit type: <code> \texttt{dst} (I)= \texttt{saturate\_cast&lt;uchar&gt;} (| \texttt{src} (I)* \texttt{alpha} +  \texttt{beta} |) </code> In case of multi-channel arrays, the function processes each channel independently. When the output is not 8-bit, the operation can be emulated by calling the Mat::convertTo method (or by using matrix expressions) and then by calculating an absolute value of the result. For example:</p><pre><code class="ml">Mat_&lt;float&gt; A(30,30);
randu(A, Scalar(-100), Scalar(100));
Mat_&lt;float&gt; B = A*5 + 3;
B = abs(B);
// Mat_&lt;float&gt; B = abs(A*5+3) will also do the job,
// but it will allocate a temporary matrix</code></pre><ul><li>Parameter: <code>src</code>: input array.</li><li>Parameter: <code>dst</code>: output array.</li><li>Parameter: <code>alpha</code>: optional scale factor.</li><li>Parameter: <code>beta</code>: optional delta added to the scaled values. See also: Mat::convertTo, cv::abs(const Mat&amp;)</li></ul></dd></dl><dl><dt class="spec value" id="val-convert_fp16"><a href="#val-convert_fp16" class="anchor"></a><code><span class="keyword">val</span> convert_fp16 : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>convert_fp16 ?dst src</code></p><p>Converts an array to half precision floating number.</p><p>This function converts FP32 (single precision floating point) from/to FP16 (half precision floating point). CV_16S format is used to represent FP16 data. There are two use modes (src -&gt; dst): CV_32F -&gt; CV_16S and CV_16S -&gt; CV_32F. The input array has to have type of CV_32F or CV_16S to represent the bit depth. If the input array is neither of them, the function will raise an error. The format of half precision floating point is defined in IEEE 754-2008.</p><ul><li>Parameter: <code>src</code>: input array.</li><li>Parameter: <code>dst</code>: output array.</li></ul></dd></dl><dl><dt class="spec value" id="val-lut"><a href="#val-lut" class="anchor"></a><code><span class="keyword">val</span> lut : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>lut ?dst src lut</code></p><p>Performs a look-up table transform of an array.</p><p>The function LUT fills the output array with values from the look-up table. Indices of the entries are taken from the input array. That is, the function processes each element of src as follows: <code> \texttt{dst} (I)  \leftarrow \texttt{lut(src(I) + d)} </code> where <code> d =  \fork{0}{if \(\texttt{src}\) has depth \(\texttt{CV_8U}\)}{128}{if \(\texttt{src}\) has depth \(\texttt{CV_8S}\)} </code></p><ul><li>Parameter: <code>src</code>: input array of 8-bit elements.</li><li>Parameter: <code>lut</code>: look-up table of 256 elements; in case of multi-channel input array, the table should either have a single channel (in this case the same table is used for all channels) or the same number of channels as in the input array.</li><li>Parameter: <code>dst</code>: output array of the same size and number of channels as src, and the same depth as lut. See also: convertScaleAbs, Mat::convertTo</li></ul></dd></dl><dl><dt class="spec value" id="val-sum"><a href="#val-sum" class="anchor"></a><code><span class="keyword">val</span> sum : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a></code></dt><dd><p>Usage: <code>sum src</code></p><p>Calculates the sum of array elements.</p><p>The function cv::sum calculates and returns the sum of array elements, independently for each channel.</p><ul><li>Parameter: <code>src</code>: input array that must have from 1 to 4 channels. See also: countNonZero, mean, meanStdDev, norm, minMaxLoc, reduce</li></ul></dd></dl><dl><dt class="spec value" id="val-count_non_zero"><a href="#val-count_non_zero" class="anchor"></a><code><span class="keyword">val</span> count_non_zero : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Usage: <code>count_non_zero src</code></p><p>Counts non-zero array elements.</p><p>The function returns the number of non-zero elements in src : <code> \; \texttt{src} (I) \ne0 } 1 </code></p><ul><li>Parameter: <code>src</code>: single-channel array. See also: mean, meanStdDev, norm, minMaxLoc, calcCovarMatrix</li></ul></dd></dl><dl><dt class="spec value" id="val-find_non_zero"><a href="#val-find_non_zero" class="anchor"></a><code><span class="keyword">val</span> find_non_zero : <span>?&#8288;idx:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>find_non_zero ?idx src</code></p><p>Returns the list of locations of non-zero pixels</p><p>Given a binary matrix (likely returned from an operation such as threshold(), compare(), &gt;, ==, etc, return all of the non-zero indices as a cv::Mat or std::vector&lt;cv::Point&gt; (x,y) For example:</p><pre><code class="ml">cv::Mat binaryImage; // input, binary image
cv::Mat locations;   // output, locations of non-zero pixels
cv::findNonZero(binaryImage, locations);

// access pixel coordinates
Point pnt = locations.at&lt;Point&gt;(i);</code></pre><p>or</p><pre><code class="ml">cv::Mat binaryImage; // input, binary image
vector&lt;Point&gt; locations;   // output, locations of non-zero pixels
cv::findNonZero(binaryImage, locations);

// access pixel coordinates
Point pnt = locations[i];</code></pre><ul><li>Parameter: <code>src</code>: single-channel array</li><li>Parameter: <code>idx</code>: the output array, type of cv::Mat or std::vector&lt;Point&gt;, corresponding to non-zero indices in the input</li></ul></dd></dl><dl><dt class="spec value" id="val-mean"><a href="#val-mean" class="anchor"></a><code><span class="keyword">val</span> mean : <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a></code></dt><dd><p>Usage: <code>mean ?mask src</code></p><p>Calculates an average (mean) of array elements.</p><p>The function cv::mean calculates the mean value M of array elements, independently for each channel, and return it: <code> \; \texttt{mask} (I) \ne 0} 1 \\ M_c =  \left ( \sum _{I: \; \texttt{mask} (I) \ne 0}{ \texttt{mtx} (I)_c} \right )/N \end{array} </code> When all the mask elements are 0's, the function returns Scalar::all(0)</p><ul><li>Parameter: <code>src</code>: input array that should have from 1 to 4 channels so that the result can be stored in Scalar_ .</li><li>Parameter: <code>mask</code>: optional operation mask. See also: countNonZero, meanStdDev, norm, minMaxLoc</li></ul></dd></dl><dl><dt class="spec value" id="val-mean_std_dev"><a href="#val-mean_std_dev" class="anchor"></a><code><span class="keyword">val</span> mean_std_dev : <span>?&#8288;mean:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;stddev:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>mean_std_dev ?mean ?stddev ?mask src</code></p><p>Calculates a mean and standard deviation of array elements.</p><p>The function cv::meanStdDev calculates the mean and the standard deviation M of array elements independently for each channel and returns it via the output parameters: <code> \; \texttt{mask}(I) \ne 0} \texttt{src} (I)_c}{N} \\ \texttt{stddev} _c =  \sqrt{\frac{\sum_{ I: \; \texttt{mask}(I) \ne 0} \left ( \texttt{src} (I)_c -  \texttt{mean} _c \right )^2}{N}} \end{array} </code> When all the mask elements are 0's, the function returns mean=stddev=Scalar::all(0). Note: The calculated standard deviation is only the diagonal of the complete normalized covariance matrix. If the full matrix is needed, you can reshape the multi-channel array M x N to the single-channel array M\*N x mtx.channels() (only possible when the matrix is continuous) and then pass the matrix to calcCovarMatrix .</p><ul><li>Parameter: <code>src</code>: input array that should have from 1 to 4 channels so that the results can be stored in Scalar_ 's.</li><li>Parameter: <code>mean</code>: output parameter: calculated mean value.</li><li>Parameter: <code>stddev</code>: output parameter: calculated standard deviation.</li><li>Parameter: <code>mask</code>: optional operation mask. See also: countNonZero, mean, norm, minMaxLoc, calcCovarMatrix</li></ul></dd></dl><dl><dt class="spec value" id="val-norm1"><a href="#val-norm1" class="anchor"></a><code><span class="keyword">val</span> norm1 : <span>?&#8288;norm_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float</code></dt><dd><p>Usage: <code>norm1 ?norm_type ?mask src1</code></p><p>Calculates the absolute norm of an array.</p><p>This version of #norm calculates the absolute norm of src1. The type of norm to calculate is specified using #NormTypes.</p><p>As example for one array consider the function <code> r(x)= \begin{pmatrix} x \\ 1-x \end{pmatrix}, x \in [-1;1] </code>. The <code>  L_{1}, L_{2}  </code> and <code>  L_{\infty}  </code> norm for the sample value <code> r(-1) = \begin{pmatrix} -1 \\ 2 \end{pmatrix} </code> is calculated as follows <code> 
    \| r(-1) \|_{L_1} &amp;= |-1| + |2| = 3 \\
    \| r(-1) \|_{L_2} &amp;= \sqrt{(-1)^{2} + (2)^{2}} = \sqrt{5} \\
    \| r(-1) \|_{L_\infty} &amp;= \max(|-1|,|2|) = 2
 </code> and for <code> r(0.5) = \begin{pmatrix} 0.5 \\ 0.5 \end{pmatrix} </code> the calculation is <code> 
    \| r(0.5) \|_{L_1} &amp;= |0.5| + |0.5| = 1 \\
    \| r(0.5) \|_{L_2} &amp;= \sqrt{(0.5)^{2} + (0.5)^{2}} = \sqrt{0.5} \\
    \| r(0.5) \|_{L_\infty} &amp;= \max(|0.5|,|0.5|) = 0.5.
 </code> The following graphic shows all values for the three norm functions <code> \| r(x) \|_{L_1}, \| r(x) \|_{L_2} </code> and <code> \| r(x) \|_{L_\infty} </code>. It is notable that the <code>  L_{1}  </code> norm forms the upper and the <code>  L_{\infty}  </code> norm forms the lower border for the example function <code>  r(x)  </code>. !<code>Graphs for the different norm functions from the above example</code>(pics/NormTypes_OneArray_1-2-INF.png)</p><p>When the mask parameter is specified and it is not empty, the norm is</p><p>If normType is not specified, #NORM_L2 is used. calculated only over the region specified by the mask.</p><p>Multi-channel input arrays are treated as single-channel arrays, that is, the results for all channels are combined.</p><p>Hamming norms can only be calculated with CV_8U depth arrays.</p><ul><li>Parameter: <code>src1</code>: first input array.</li><li>Parameter: <code>norm_type</code>: type of the norm (see #NormTypes).</li><li>Parameter: <code>mask</code>: optional operation mask; it must have the same size as src1 and CV_8UC1 type.</li></ul></dd></dl><dl><dt class="spec value" id="val-norm2"><a href="#val-norm2" class="anchor"></a><code><span class="keyword">val</span> norm2 : <span>?&#8288;norm_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float</code></dt><dd><p>Usage: <code>norm2 ?norm_type ?mask src1 src2</code></p><p>Calculates an absolute difference norm or a relative difference norm.</p><p>This version of cv::norm calculates the absolute difference norm or the relative difference norm of arrays src1 and src2. The type of norm to calculate is specified using #NormTypes.</p><ul><li>Parameter: <code>src1</code>: first input array.</li><li>Parameter: <code>src2</code>: second input array of the same size and the same type as src1.</li><li>Parameter: <code>norm_type</code>: type of the norm (see #NormTypes).</li><li>Parameter: <code>mask</code>: optional operation mask; it must have the same size as src1 and CV_8UC1 type.</li></ul></dd></dl><dl><dt class="spec value" id="val-psnr"><a href="#val-psnr" class="anchor"></a><code><span class="keyword">val</span> psnr : <span>?&#8288;r:float</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float</code></dt><dd><p>Usage: <code>psnr ?r src1 src2</code></p><p>Computes the Peak Signal-to-Noise Ratio (PSNR) image quality metric.</p><p>This function calculates the Peak Signal-to-Noise Ratio (PSNR) image quality metric in decibels (dB), between two input arrays src1 and src2. The arrays must have the same type.</p><p>The PSNR is calculated as follows:</p><p><code> 
\texttt{PSNR} = 10 \cdot \log_{10}{\left( \frac{R^2}{MSE} \right) }
 </code></p><p>where R is the maximum integer value of depth (e.g. 255 in the case of CV_8U data) and MSE is the mean squared error between the two arrays.</p><ul><li>Parameter: <code>src1</code>: first input array.</li><li>Parameter: <code>src2</code>: second input array of the same size as src1.</li><li>Parameter: <code>r</code>: the maximum pixel value (255 by default)</li></ul></dd></dl><dl><dt class="spec value" id="val-batch_distance"><a href="#val-batch_distance" class="anchor"></a><code><span class="keyword">val</span> batch_distance : <span>?&#8288;dist:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;nidx:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;norm_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;k:int</span> <span>&#45;&gt;</span> <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;update:int</span> <span>&#45;&gt;</span> <span>?&#8288;crosscheck:bool</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>batch_distance ?dist ?nidx ?norm_type ?k ?mask ?update ?crosscheck src1 src2 dtype</code></p><p>naive nearest neighbor finder</p><p>see http://en.wikipedia.org/wiki/Nearest_neighbor_search TODO document</p></dd></dl><dl><dt class="spec value" id="val-normalize"><a href="#val-normalize" class="anchor"></a><code><span class="keyword">val</span> normalize : <span>?&#8288;alpha:float</span> <span>&#45;&gt;</span> <span>?&#8288;beta:float</span> <span>&#45;&gt;</span> <span>?&#8288;norm_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;dtype:int</span> <span>&#45;&gt;</span> <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>normalize ?alpha ?beta ?norm_type ?dtype ?mask src dst</code></p><p>Normalizes the norm or value range of an array.</p><p>The function cv::normalize normalizes scale and shift the input array elements so that <code> \| \texttt{dst} \| _{L_p}= \texttt{alpha} </code> (where p=Inf, 1 or 2) when normType=NORM_INF, NORM_L1, or NORM_L2, respectively; or so that <code> \min _I  \texttt{dst} (I)= \texttt{alpha} , \, \, \max _I  \texttt{dst} (I)= \texttt{beta} </code></p><p>when normType=NORM_MINMAX (for dense arrays only). The optional mask specifies a sub-array to be normalized. This means that the norm or min-n-max are calculated over the sub-array, and then this sub-array is modified to be normalized. If you want to only use the mask to calculate the norm or min-max but modify the whole array, you can use norm and Mat::convertTo.</p><p>In case of sparse matrices, only the non-zero values are analyzed and transformed. Because of this, the range transformation for sparse matrices is not allowed since it can shift the zero level.</p><p>Possible usage with some positive example data:</p><pre><code class="ml">vector&lt;double&gt; positiveData = { 2.0, 8.0, 10.0 };
vector&lt;double&gt; normalizedData_l1, normalizedData_l2, normalizedData_inf, normalizedData_minmax;

// Norm to probability (total count)
// sum(numbers) = 20.0
// 2.0      0.1     (2.0/20.0)
// 8.0      0.4     (8.0/20.0)
// 10.0     0.5     (10.0/20.0)
normalize(positiveData, normalizedData_l1, 1.0, 0.0, NORM_L1);

// Norm to unit vector: ||positiveData|| = 1.0
// 2.0      0.15
// 8.0      0.62
// 10.0     0.77
normalize(positiveData, normalizedData_l2, 1.0, 0.0, NORM_L2);

// Norm to max element
// 2.0      0.2     (2.0/10.0)
// 8.0      0.8     (8.0/10.0)
// 10.0     1.0     (10.0/10.0)
normalize(positiveData, normalizedData_inf, 1.0, 0.0, NORM_INF);

// Norm to range [0.0;1.0]
// 2.0      0.0     (shift to left border)
// 8.0      0.75    (6.0/8.0)
// 10.0     1.0     (shift to right border)
normalize(positiveData, normalizedData_minmax, 1.0, 0.0, NORM_MINMAX);</code></pre><ul><li>Parameter: <code>src</code>: input array.</li><li>Parameter: <code>dst</code>: output array of the same size as src .</li><li>Parameter: <code>alpha</code>: norm value to normalize to or the lower range boundary in case of the range normalization.</li><li>Parameter: <code>beta</code>: upper range boundary in case of the range normalization; it is not used for the norm normalization.</li><li>Parameter: <code>norm_type</code>: normalization type (see cv::NormTypes).</li><li>Parameter: <code>dtype</code>: when negative, the output array has the same type as src; otherwise, it has the same number of channels as src and the depth =CV_MAT_DEPTH(dtype).</li><li>Parameter: <code>mask</code>: optional operation mask. See also: norm, Mat::convertTo, SparseMat::convertTo</li></ul></dd></dl><dl><dt class="spec value" id="val-min_max_loc"><a href="#val-min_max_loc" class="anchor"></a><code><span class="keyword">val</span> min_max_loc : <span>?&#8288;max_val:float</span> <span>&#45;&gt;</span> <span>?&#8288;min_loc:<a href="index.html#type-point2i">point2i</a></span> <span>&#45;&gt;</span> <span>?&#8288;max_loc:<a href="index.html#type-point2i">point2i</a></span> <span>&#45;&gt;</span> <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>min_max_loc ?max_val ?min_loc ?max_loc ?mask src min_val</code></p><p>Finds the global minimum and maximum in an array.</p><p>The function cv::minMaxLoc finds the minimum and maximum element values and their positions. The extremums are searched across the whole array or, if mask is not an empty array, in the specified array region.</p><p>The function do not work with multi-channel arrays. If you need to find minimum or maximum elements across all the channels, use Mat::reshape first to reinterpret the array as single-channel. Or you may extract the particular channel using either extractImageCOI , or mixChannels , or split .</p><ul><li>Parameter: <code>src</code>: input single-channel array.</li><li>Parameter: <code>min_val</code>: pointer to the returned minimum value; NULL is used if not required.</li><li>Parameter: <code>max_val</code>: pointer to the returned maximum value; NULL is used if not required.</li><li>Parameter: <code>min_loc</code>: pointer to the returned minimum location (in 2D case); NULL is used if not required.</li><li>Parameter: <code>max_loc</code>: pointer to the returned maximum location (in 2D case); NULL is used if not required.</li><li>Parameter: <code>mask</code>: optional mask used to select a sub-array. See also: max, min, compare, inRange, extractImageCOI, mixChannels, split, Mat::reshape</li></ul></dd></dl><dl><dt class="spec value" id="val-reduce"><a href="#val-reduce" class="anchor"></a><code><span class="keyword">val</span> reduce : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;dtype:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>reduce ?dst ?dtype src dim rtype</code></p><p>Reduces a matrix to a vector.</p><p>The function #reduce reduces the matrix to a vector by treating the matrix rows/columns as a set of 1D vectors and performing the specified operation on the vectors until a single row/column is obtained. For example, the function can be used to compute horizontal and vertical projections of a raster image. In case of #REDUCE_MAX and #REDUCE_MIN , the output image should have the same type as the source one. In case of #REDUCE_SUM and #REDUCE_AVG , the output may have a larger element bit-depth to preserve accuracy. And multi-channel arrays are also supported in these two reduction modes.</p><p>The following code demonstrates its usage for a single channel matrix. Snippet: snippets/core_reduce.cpp example</p><p>And the following code demonstrates its usage for a two-channel matrix. Snippet: snippets/core_reduce.cpp example2</p><ul><li>Parameter: <code>src</code>: input 2D matrix.</li><li>Parameter: <code>dst</code>: output vector. Its size and type is defined by dim and dtype parameters.</li><li>Parameter: <code>dim</code>: dimension index along which the matrix is reduced. 0 means that the matrix is reduced to a single row. 1 means that the matrix is reduced to a single column.</li><li>Parameter: <code>rtype</code>: reduction operation that could be one of #ReduceTypes</li><li>Parameter: <code>dtype</code>: when negative, the output vector will have the same type as the input matrix, otherwise, its type will be CV_MAKE_TYPE(CV_MAT_DEPTH(dtype), src.channels()). See also: repeat</li></ul></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">val</span> merge : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span><a href="Cvdata/index.html#type-t">Cvdata.t</a> list</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>merge ?dst mv</code></p><ul><li>Parameter: <code>mv</code>: input vector of matrices to be merged; all the matrices in mv must have the same size and the same depth.</li><li>Parameter: <code>dst</code>: output array of the same size and the same depth as mv<code>0</code>; The number of channels will be the total number of channels in the matrix array.</li></ul></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">val</span> split : <span>?&#8288;mv:<span><span><a href="Cvdata/index.html#type-t">Cvdata.t</a> list</span> Stdlib.ref</span></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <span><a href="Cvdata/index.html#type-t">Cvdata.t</a> list</span></code></dt><dd><p>Usage: <code>split ?mv m</code></p><ul><li>Parameter: <code>m</code>: input multi-channel array.</li><li>Parameter: <code>mv</code>: output vector of arrays; the arrays themselves are reallocated, if needed.</li></ul></dd></dl><dl><dt class="spec value" id="val-mix_channels"><a href="#val-mix_channels" class="anchor"></a><code><span class="keyword">val</span> mix_channels : <span><a href="Cvdata/index.html#type-t">Cvdata.t</a> list</span> <span>&#45;&gt;</span> <span><span><a href="Cvdata/index.html#type-t">Cvdata.t</a> list</span> Stdlib.ref</span> <span>&#45;&gt;</span> <span>int list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>mix_channels src dst from_to</code></p><ul><li>Parameter: <code>src</code>: input array or vector of matrices; all of the matrices must have the same size and the same depth.</li><li>Parameter: <code>dst</code>: output array or vector of matrices; all the matrices **must be allocated**; their size and depth must be the same as in src<code>0</code>.</li><li>Parameter: <code>from_to</code>: array of index pairs specifying which channels are copied and where; fromTo<code>k\*2</code> is a 0-based index of the input channel in src, fromTo<code>k\*2+1</code> is an index of the output channel in dst; the continuous channel numbering is used: the first input image channels are indexed from 0 to src<code>0</code>.channels()-1, the second input image channels are indexed from src<code>0</code>.channels() to src<code>0</code>.channels() + src<code>1</code>.channels()-1, and so on, the same scheme is used for the output image channels; as a special case, when fromTo<code>k\*2</code> is negative, the corresponding output channel is filled with zero .</li></ul></dd></dl><dl><dt class="spec value" id="val-extract_channel"><a href="#val-extract_channel" class="anchor"></a><code><span class="keyword">val</span> extract_channel : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>extract_channel ?dst src coi</code></p><p>Extracts a single channel from src (coi is 0-based index)</p><ul><li>Parameter: <code>src</code>: input array</li><li>Parameter: <code>dst</code>: output array</li><li>Parameter: <code>coi</code>: index of channel to extract See also: mixChannels, split</li></ul></dd></dl><dl><dt class="spec value" id="val-insert_channel"><a href="#val-insert_channel" class="anchor"></a><code><span class="keyword">val</span> insert_channel : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>insert_channel src dst coi</code></p><p>Inserts a single channel to dst (coi is 0-based index)</p><ul><li>Parameter: <code>src</code>: input array</li><li>Parameter: <code>dst</code>: output array</li><li>Parameter: <code>coi</code>: index of channel for insertion See also: mixChannels, merge</li></ul></dd></dl><dl><dt class="spec value" id="val-flip"><a href="#val-flip" class="anchor"></a><code><span class="keyword">val</span> flip : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>flip ?dst src flip_code</code></p><p>Flips a 2D array around vertical, horizontal, or both axes.</p><p>The function cv::flip flips the array in one of three different ways (row and column indices are 0-based): <code> \texttt{dst} _{ij} =
\left\{
\begin{array}{l l}
\texttt{src} _{\texttt{src.rows}-i-1,j} &amp; if\;  \texttt{flipCode} = 0 \\
\texttt{src} _{i, \texttt{src.cols} -j-1} &amp; if\;  \texttt{flipCode} &gt; 0 \\
\texttt{src} _{ \texttt{src.rows} -i-1, \texttt{src.cols} -j-1} &amp; if\; \texttt{flipCode} &lt; 0 \\
\end{array}
\right. </code> The example scenarios of using the function are the following: * Vertical flipping of the image (flipCode == 0) to switch between top-left and bottom-left image origin. This is a typical operation in video processing on Microsoft Windows\* OS. * Horizontal flipping of the image with the subsequent horizontal shift and absolute difference calculation to check for a vertical-axis symmetry (flipCode \&gt; 0). * Simultaneous horizontal and vertical flipping of the image with the subsequent shift and absolute difference calculation to check for a central symmetry (flipCode \&lt; 0). * Reversing the order of point arrays (flipCode \&gt; 0 or flipCode == 0).</p><ul><li>Parameter: <code>src</code>: input array.</li><li>Parameter: <code>dst</code>: output array of the same size and type as src.</li><li>Parameter: <code>flip_code</code>: a flag to specify how to flip the array; 0 means flipping around the x-axis and positive value (for example, 1) means flipping around y-axis. Negative value (for example, -1) means flipping around both axes. See also: transpose , repeat , completeSymm</li></ul></dd></dl><dl><dt class="spec value" id="val-rotate"><a href="#val-rotate" class="anchor"></a><code><span class="keyword">val</span> rotate : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>rotate ?dst src rotate_code</code></p><p>Rotates a 2D array in multiples of 90 degrees. The function cv::rotate rotates the array in one of three different ways: * Rotate by 90 degrees clockwise (rotateCode = ROTATE_90_CLOCKWISE). * Rotate by 180 degrees clockwise (rotateCode = ROTATE_180). * Rotate by 270 degrees clockwise (rotateCode = ROTATE_90_COUNTERCLOCKWISE).</p><ul><li>Parameter: <code>src</code>: input array.</li><li>Parameter: <code>dst</code>: output array of the same type as src. The size is the same with ROTATE_180, and the rows and cols are switched for ROTATE_90_CLOCKWISE and ROTATE_90_COUNTERCLOCKWISE.</li><li>Parameter: <code>rotate_code</code>: an enum to specify how to rotate the array; see the enum #RotateFlags See also: transpose , repeat , completeSymm, flip, RotateFlags</li></ul></dd></dl><dl><dt class="spec value" id="val-repeat"><a href="#val-repeat" class="anchor"></a><code><span class="keyword">val</span> repeat : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>repeat ?dst src ny nx</code></p><p>Fills the output array with repeated copies of the input array.</p><p>The function cv::repeat duplicates the input array one or more times along each of the two axes: <code> \texttt{dst} _{ij}= \texttt{src} _{i\mod src.rows, \; j\mod src.cols } </code> The second variant of the function is more convenient to use with MatrixExpressions.</p><ul><li>Parameter: <code>src</code>: input array to replicate.</li><li>Parameter: <code>ny</code>: Flag to specify how many times the <code>src</code> is repeated along the vertical axis.</li><li>Parameter: <code>nx</code>: Flag to specify how many times the <code>src</code> is repeated along the horizontal axis.</li><li>Parameter: <code>dst</code>: output array of the same type as <code>src</code>. See also: cv::reduce</li></ul></dd></dl><dl><dt class="spec value" id="val-hconcat"><a href="#val-hconcat" class="anchor"></a><code><span class="keyword">val</span> hconcat : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span><a href="Cvdata/index.html#type-t">Cvdata.t</a> list</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>hconcat ?dst src</code></p><pre><code class="ml">std::vector&lt;cv::Mat&gt; matrices = { cv::Mat(4, 1, CV_8UC1, cv::Scalar(1)),
                                  cv::Mat(4, 1, CV_8UC1, cv::Scalar(2)),
                                  cv::Mat(4, 1, CV_8UC1, cv::Scalar(3)),};

cv::Mat out;
cv::hconcat( matrices, out );
//out:
//[1, 2, 3;
// 1, 2, 3;
// 1, 2, 3;
// 1, 2, 3]</code></pre><ul><li>Parameter: <code>src</code>: input array or vector of matrices. all of the matrices must have the same number of rows and the same depth.</li><li>Parameter: <code>dst</code>: output array. It has the same number of rows and depth as the src, and the sum of cols of the src. same depth.</li></ul></dd></dl><dl><dt class="spec value" id="val-vconcat"><a href="#val-vconcat" class="anchor"></a><code><span class="keyword">val</span> vconcat : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span><a href="Cvdata/index.html#type-t">Cvdata.t</a> list</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>vconcat ?dst src</code></p><pre><code class="ml">std::vector&lt;cv::Mat&gt; matrices = { cv::Mat(1, 4, CV_8UC1, cv::Scalar(1)),
                                  cv::Mat(1, 4, CV_8UC1, cv::Scalar(2)),
                                  cv::Mat(1, 4, CV_8UC1, cv::Scalar(3)),};

cv::Mat out;
cv::vconcat( matrices, out );
//out:
//[1,   1,   1,   1;
// 2,   2,   2,   2;
// 3,   3,   3,   3]</code></pre><ul><li>Parameter: <code>src</code>: input array or vector of matrices. all of the matrices must have the same number of cols and the same depth</li><li>Parameter: <code>dst</code>: output array. It has the same number of cols and depth as the src, and the sum of rows of the src. same depth.</li></ul></dd></dl><dl><dt class="spec value" id="val-bitwise_and"><a href="#val-bitwise_and" class="anchor"></a><code><span class="keyword">val</span> bitwise_and : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>bitwise_and ?dst ?mask src1 src2</code></p><p>computes bitwise conjunction of the two arrays (dst = src1 &amp; src2) Calculates the per-element bit-wise conjunction of two arrays or an array and a scalar.</p><p>The function cv::bitwise_and calculates the per-element bit-wise logical conjunction for: * Two arrays when src1 and src2 have the same size: <code> \texttt{dst} (I) =  \texttt{src1} (I)  \wedge \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0 </code> * An array and a scalar when src2 is constructed from Scalar or has the same number of elements as <code>src1.channels()</code>: <code> \texttt{dst} (I) =  \texttt{src1} (I)  \wedge \texttt{src2} \quad \texttt{if mask} (I) \ne0 </code> * A scalar and an array when src1 is constructed from Scalar or has the same number of elements as <code>src2.channels()</code>: <code> \texttt{dst} (I) =  \texttt{src1}  \wedge \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0 </code> In case of floating-point arrays, their machine-specific bit representations (usually IEEE754-compliant) are used for the operation. In case of multi-channel arrays, each channel is processed independently. In the second and third cases above, the scalar is first converted to the array type.</p><ul><li>Parameter: <code>src1</code>: first input array or a scalar.</li><li>Parameter: <code>src2</code>: second input array or a scalar.</li><li>Parameter: <code>dst</code>: output array that has the same size and type as the input arrays.</li><li>Parameter: <code>mask</code>: optional operation mask, 8-bit single channel array, that specifies elements of the output array to be changed.</li></ul></dd></dl><dl><dt class="spec value" id="val-bitwise_or"><a href="#val-bitwise_or" class="anchor"></a><code><span class="keyword">val</span> bitwise_or : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>bitwise_or ?dst ?mask src1 src2</code></p><p>Calculates the per-element bit-wise disjunction of two arrays or an array and a scalar.</p><p>The function cv::bitwise_or calculates the per-element bit-wise logical disjunction for: * Two arrays when src1 and src2 have the same size: <code> \texttt{dst} (I) =  \texttt{src1} (I)  \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0 </code> * An array and a scalar when src2 is constructed from Scalar or has the same number of elements as <code>src1.channels()</code>: <code> \texttt{dst} (I) =  \texttt{src1} (I)  \vee \texttt{src2} \quad \texttt{if mask} (I) \ne0 </code> * A scalar and an array when src1 is constructed from Scalar or has the same number of elements as <code>src2.channels()</code>: <code> \texttt{dst} (I) =  \texttt{src1}  \vee \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0 </code> In case of floating-point arrays, their machine-specific bit representations (usually IEEE754-compliant) are used for the operation. In case of multi-channel arrays, each channel is processed independently. In the second and third cases above, the scalar is first converted to the array type.</p><ul><li>Parameter: <code>src1</code>: first input array or a scalar.</li><li>Parameter: <code>src2</code>: second input array or a scalar.</li><li>Parameter: <code>dst</code>: output array that has the same size and type as the input arrays.</li><li>Parameter: <code>mask</code>: optional operation mask, 8-bit single channel array, that specifies elements of the output array to be changed.</li></ul></dd></dl><dl><dt class="spec value" id="val-bitwise_xor"><a href="#val-bitwise_xor" class="anchor"></a><code><span class="keyword">val</span> bitwise_xor : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>bitwise_xor ?dst ?mask src1 src2</code></p><p>Calculates the per-element bit-wise &quot;exclusive or&quot; operation on two arrays or an array and a scalar.</p><p>The function cv::bitwise_xor calculates the per-element bit-wise logical &quot;exclusive-or&quot; operation for: * Two arrays when src1 and src2 have the same size: <code> \texttt{dst} (I) =  \texttt{src1} (I)  \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0 </code> * An array and a scalar when src2 is constructed from Scalar or has the same number of elements as <code>src1.channels()</code>: <code> \texttt{dst} (I) =  \texttt{src1} (I)  \oplus \texttt{src2} \quad \texttt{if mask} (I) \ne0 </code> * A scalar and an array when src1 is constructed from Scalar or has the same number of elements as <code>src2.channels()</code>: <code> \texttt{dst} (I) =  \texttt{src1}  \oplus \texttt{src2} (I) \quad \texttt{if mask} (I) \ne0 </code> In case of floating-point arrays, their machine-specific bit representations (usually IEEE754-compliant) are used for the operation. In case of multi-channel arrays, each channel is processed independently. In the 2nd and 3rd cases above, the scalar is first converted to the array type.</p><ul><li>Parameter: <code>src1</code>: first input array or a scalar.</li><li>Parameter: <code>src2</code>: second input array or a scalar.</li><li>Parameter: <code>dst</code>: output array that has the same size and type as the input arrays.</li><li>Parameter: <code>mask</code>: optional operation mask, 8-bit single channel array, that specifies elements of the output array to be changed.</li></ul></dd></dl><dl><dt class="spec value" id="val-bitwise_not"><a href="#val-bitwise_not" class="anchor"></a><code><span class="keyword">val</span> bitwise_not : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>bitwise_not ?dst ?mask src</code></p><p>Inverts every bit of an array.</p><p>The function cv::bitwise_not calculates per-element bit-wise inversion of the input array: <code> \texttt{dst} (I) =  \neg \texttt{src} (I) </code> In case of a floating-point input array, its machine-specific bit representation (usually IEEE754-compliant) is used for the operation. In case of multi-channel arrays, each channel is processed independently.</p><ul><li>Parameter: <code>src</code>: input array.</li><li>Parameter: <code>dst</code>: output array that has the same size and type as the input array.</li><li>Parameter: <code>mask</code>: optional operation mask, 8-bit single channel array, that specifies elements of the output array to be changed.</li></ul></dd></dl><dl><dt class="spec value" id="val-absdiff"><a href="#val-absdiff" class="anchor"></a><code><span class="keyword">val</span> absdiff : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>absdiff ?dst src1 src2</code></p><p>Calculates the per-element absolute difference between two arrays or between an array and a scalar.</p><p>The function cv::absdiff calculates: * Absolute difference between two arrays when they have the same size and type: <code> \texttt{dst}(I) =  \texttt{saturate} (| \texttt{src1}(I) -  \texttt{src2}(I)|) </code> * Absolute difference between an array and a scalar when the second array is constructed from Scalar or has as many elements as the number of channels in <code>src1</code>: <code> \texttt{dst}(I) =  \texttt{saturate} (| \texttt{src1}(I) -  \texttt{src2} |) </code> * Absolute difference between a scalar and an array when the first array is constructed from Scalar or has as many elements as the number of channels in <code>src2</code>: <code> \texttt{dst}(I) =  \texttt{saturate} (| \texttt{src1} -  \texttt{src2}(I) |) </code> where I is a multi-dimensional index of array elements. In case of multi-channel arrays, each channel is processed independently. Note: Saturation is not applied when the arrays have the depth CV_32S. You may even get a negative value in the case of overflow.</p><ul><li>Parameter: <code>src1</code>: first input array or a scalar.</li><li>Parameter: <code>src2</code>: second input array or a scalar.</li><li>Parameter: <code>dst</code>: output array that has the same size and type as input arrays. See also: cv::abs(const Mat&amp;)</li></ul></dd></dl><dl><dt class="spec value" id="val-copy_to"><a href="#val-copy_to" class="anchor"></a><code><span class="keyword">val</span> copy_to : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>copy_to ?dst src mask</code></p><p>This is an overloaded member function, provided for convenience (python) Copies the matrix to another one. When the operation mask is specified, if the Mat::create call shown above reallocates the matrix, the newly allocated matrix is initialized with all zeros before copying the data.</p><ul><li>Parameter: <code>src</code>: source matrix.</li><li>Parameter: <code>dst</code>: Destination matrix. If it does not have a proper size or type before the operation, it is reallocated.</li><li>Parameter: <code>mask</code>: Operation mask of the same size as \*this. Its non-zero elements indicate which matrix elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels.</li></ul></dd></dl><dl><dt class="spec value" id="val-in_range"><a href="#val-in_range" class="anchor"></a><code><span class="keyword">val</span> in_range : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>in_range ?dst src lowerb upperb</code></p><p>Checks if array elements lie between the elements of two other arrays.</p><p>The function checks the range as follows:</p><ul><li>For every element of a single-channel input array: <code> \texttt{dst} (I)= \texttt{lowerb} (I)_0  \leq \texttt{src} (I)_0 \leq  \texttt{upperb} (I)_0 </code></li><li>For two-channel arrays: <code> \texttt{dst} (I)= \texttt{lowerb} (I)_0  \leq \texttt{src} (I)_0 \leq  \texttt{upperb} (I)_0  \land \texttt{lowerb} (I)_1  \leq \texttt{src} (I)_1 \leq  \texttt{upperb} (I)_1 </code></li><li>and so forth.</li></ul><p>That is, dst (I) is set to 255 (all 1 -bits) if src (I) is within the specified 1D, 2D, 3D, ... box and 0 otherwise.</p><p>When the lower and/or upper boundary parameters are scalars, the indexes (I) at lowerb and upperb in the above formulas should be omitted.</p><ul><li>Parameter: <code>src</code>: first input array.</li><li>Parameter: <code>lowerb</code>: inclusive lower boundary array or a scalar.</li><li>Parameter: <code>upperb</code>: inclusive upper boundary array or a scalar.</li><li>Parameter: <code>dst</code>: output array of the same size as src and CV_8U type.</li></ul></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">val</span> compare : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>compare ?dst src1 src2 cmpop</code></p><p>Performs the per-element comparison of two arrays or an array and scalar value.</p><p>The function compares: * Elements of two arrays when src1 and src2 have the same size: <code> \texttt{dst} (I) =  \texttt{src1} (I)  \,\texttt{cmpop}\, \texttt{src2} (I) </code> * Elements of src1 with a scalar src2 when src2 is constructed from Scalar or has a single element: <code> \texttt{dst} (I) =  \texttt{src1}(I) \,\texttt{cmpop}\,  \texttt{src2} </code> * src1 with elements of src2 when src1 is constructed from Scalar or has a single element: <code> \texttt{dst} (I) =  \texttt{src1}  \,\texttt{cmpop}\, \texttt{src2} (I) </code> When the comparison result is true, the corresponding element of output array is set to 255. The comparison operations can be replaced with the equivalent matrix expressions:</p><pre><code class="ml">Mat dst1 = src1 &gt;= src2;
Mat dst2 = src1 &lt; 8;
...</code></pre><ul><li>Parameter: <code>src1</code>: first input array or a scalar; when it is an array, it must have a single channel.</li><li>Parameter: <code>src2</code>: second input array or a scalar; when it is an array, it must have a single channel.</li><li>Parameter: <code>dst</code>: output array of type ref CV_8U that has the same size and the same number of channels as the input arrays.</li><li>Parameter: <code>cmpop</code>: a flag, that specifies correspondence between the arrays (cv::CmpTypes) See also: checkRange, min, max, threshold</li></ul></dd></dl><dl><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">val</span> min : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>min ?dst src1 src2</code></p><p>Calculates per-element minimum of two arrays or an array and a scalar.</p><p>The function cv::min calculates the per-element minimum of two arrays: <code> \texttt{dst} (I)= \min ( \texttt{src1} (I), \texttt{src2} (I)) </code> or array and a scalar: <code> \texttt{dst} (I)= \min ( \texttt{src1} (I), \texttt{value} ) </code></p><ul><li>Parameter: <code>src1</code>: first input array.</li><li>Parameter: <code>src2</code>: second input array of the same size and type as src1.</li><li>Parameter: <code>dst</code>: output array of the same size and type as src1. See also: max, compare, inRange, minMaxLoc</li></ul></dd></dl><dl><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">val</span> max : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>max ?dst src1 src2</code></p><p>Calculates per-element maximum of two arrays or an array and a scalar.</p><p>The function cv::max calculates the per-element maximum of two arrays: <code> \texttt{dst} (I)= \max ( \texttt{src1} (I), \texttt{src2} (I)) </code> or array and a scalar: <code> \texttt{dst} (I)= \max ( \texttt{src1} (I), \texttt{value} ) </code></p><ul><li>Parameter: <code>src1</code>: first input array.</li><li>Parameter: <code>src2</code>: second input array of the same size and type as src1 .</li><li>Parameter: <code>dst</code>: output array of the same size and type as src1. See also: min, compare, inRange, minMaxLoc, MatrixExpressions</li></ul></dd></dl><dl><dt class="spec value" id="val-sqrt"><a href="#val-sqrt" class="anchor"></a><code><span class="keyword">val</span> sqrt : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>sqrt ?dst src</code></p><p>Calculates a square root of array elements.</p><p>The function cv::sqrt calculates a square root of each input array element. In case of multi-channel arrays, each channel is processed independently. The accuracy is approximately the same as of the built-in std::sqrt .</p><ul><li>Parameter: <code>src</code>: input floating-point array.</li><li>Parameter: <code>dst</code>: output array of the same size and type as src.</li></ul></dd></dl><dl><dt class="spec value" id="val-pow"><a href="#val-pow" class="anchor"></a><code><span class="keyword">val</span> pow : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>pow ?dst src power</code></p><p>Raises every array element to a power.</p><p>The function cv::pow raises every element of the input array to power : <code> \texttt{dst} (I) =  \fork{\texttt{src}(I)^{power}}{if \(\texttt{power}\) is integer}{ |\texttt{src}(I)|^{power}}{otherwise} </code></p><p>So, for a non-integer power exponent, the absolute values of input array elements are used. However, it is possible to get true values for negative values using some extra operations. In the example below, computing the 5th root of array src shows:</p><pre><code class="ml">Mat mask = src &lt; 0;
pow(src, 1./5, dst);
subtract(Scalar::all(0), dst, dst, mask);</code></pre><p>For some values of power, such as integer values, 0.5 and -0.5, specialized faster algorithms are used.</p><p>Special values (NaN, Inf) are not handled.</p><ul><li>Parameter: <code>src</code>: input array.</li><li>Parameter: <code>power</code>: exponent of power.</li><li>Parameter: <code>dst</code>: output array of the same size and type as src. See also: sqrt, exp, log, cartToPolar, polarToCart</li></ul></dd></dl><dl><dt class="spec value" id="val-exp"><a href="#val-exp" class="anchor"></a><code><span class="keyword">val</span> exp : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>exp ?dst src</code></p><p>Calculates the exponent of every array element.</p><p>The function cv::exp calculates the exponent of every element of the input array: <code> \texttt{dst} [I] = e^{ src(I) } </code></p><p>The maximum relative error is about 7e-6 for single-precision input and less than 1e-10 for double-precision input. Currently, the function converts denormalized values to zeros on output. Special values (NaN, Inf) are not handled.</p><ul><li>Parameter: <code>src</code>: input array.</li><li>Parameter: <code>dst</code>: output array of the same size and type as src. See also: log , cartToPolar , polarToCart , phase , pow , sqrt , magnitude</li></ul></dd></dl><dl><dt class="spec value" id="val-log"><a href="#val-log" class="anchor"></a><code><span class="keyword">val</span> log : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>log ?dst src</code></p><p>Calculates the natural logarithm of every array element.</p><p>The function cv::log calculates the natural logarithm of every element of the input array: <code> \texttt{dst} (I) =  \log (\texttt{src}(I))  </code></p><p>Output on zero, negative and special (NaN, Inf) values is undefined.</p><ul><li>Parameter: <code>src</code>: input array.</li><li>Parameter: <code>dst</code>: output array of the same size and type as src . See also: exp, cartToPolar, polarToCart, phase, pow, sqrt, magnitude</li></ul></dd></dl><dl><dt class="spec value" id="val-polar_to_cart"><a href="#val-polar_to_cart" class="anchor"></a><code><span class="keyword">val</span> polar_to_cart : <span>?&#8288;x:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;y:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;angle_in_degrees:bool</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>polar_to_cart ?x ?y ?angle_in_degrees magnitude angle</code></p><p>Calculates x and y coordinates of 2D vectors from their magnitude and angle.</p><p>The function cv::polarToCart calculates the Cartesian coordinates of each 2D vector represented by the corresponding elements of magnitude and angle: <code> \begin{array}{l} \texttt{x} (I) =  \texttt{magnitude} (I) \cos ( \texttt{angle} (I)) \\ \texttt{y} (I) =  \texttt{magnitude} (I) \sin ( \texttt{angle} (I)) \\ \end{array} </code></p><p>The relative accuracy of the estimated coordinates is about 1e-6.</p><ul><li>Parameter: <code>magnitude</code>: input floating-point array of magnitudes of 2D vectors; it can be an empty matrix (=Mat()), in this case, the function assumes that all the magnitudes are =1; if it is not empty, it must have the same size and type as angle.</li><li>Parameter: <code>angle</code>: input floating-point array of angles of 2D vectors.</li><li>Parameter: <code>x</code>: output array of x-coordinates of 2D vectors; it has the same size and type as angle.</li><li>Parameter: <code>y</code>: output array of y-coordinates of 2D vectors; it has the same size and type as angle.</li><li>Parameter: <code>angle_in_degrees</code>: when true, the input angles are measured in degrees, otherwise, they are measured in radians. See also: cartToPolar, magnitude, phase, exp, log, pow, sqrt</li></ul></dd></dl><dl><dt class="spec value" id="val-cart_to_polar"><a href="#val-cart_to_polar" class="anchor"></a><code><span class="keyword">val</span> cart_to_polar : <span>?&#8288;magnitude:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;angle:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;angle_in_degrees:bool</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>cart_to_polar ?magnitude ?angle ?angle_in_degrees x y</code></p><p>Calculates the magnitude and angle of 2D vectors.</p><p>The function cv::cartToPolar calculates either the magnitude, angle, or both for every 2D vector (x(I),y(I)): <code> \begin{array}{l} \texttt{magnitude} (I)= \sqrt{\texttt{x}(I)^2+\texttt{y}(I)^2} , \\ \texttt{angle} (I)= \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I))[ \cdot180 / \pi ] \end{array} </code></p><p>The angles are calculated with accuracy about 0.3 degrees. For the point (0,0), the angle is set to 0.</p><ul><li>Parameter: <code>x</code>: array of x-coordinates; this must be a single-precision or double-precision floating-point array.</li><li>Parameter: <code>y</code>: array of y-coordinates, that must have the same size and same type as x.</li><li>Parameter: <code>magnitude</code>: output array of magnitudes of the same size and type as x.</li><li>Parameter: <code>angle</code>: output array of angles that has the same size and type as x; the angles are measured in radians (from 0 to 2\*Pi) or in degrees (0 to 360 degrees).</li><li>Parameter: <code>angle_in_degrees</code>: a flag, indicating whether the angles are measured in radians (which is by default), or in degrees. See also: Sobel, Scharr</li></ul></dd></dl><dl><dt class="spec value" id="val-phase"><a href="#val-phase" class="anchor"></a><code><span class="keyword">val</span> phase : <span>?&#8288;angle:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;angle_in_degrees:bool</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>phase ?angle ?angle_in_degrees x y</code></p><p>Calculates the rotation angle of 2D vectors.</p><p>The function cv::phase calculates the rotation angle of each 2D vector that is formed from the corresponding elements of x and y : <code> \texttt{angle} (I) =  \texttt{atan2} ( \texttt{y} (I), \texttt{x} (I)) </code></p><p>The angle estimation accuracy is about 0.3 degrees. When x(I)=y(I)=0 , the corresponding angle(I) is set to 0.</p><ul><li>Parameter: <code>x</code>: input floating-point array of x-coordinates of 2D vectors.</li><li>Parameter: <code>y</code>: input array of y-coordinates of 2D vectors; it must have the same size and the same type as x.</li><li>Parameter: <code>angle</code>: output array of vector angles; it has the same size and same type as x .</li><li>Parameter: <code>angle_in_degrees</code>: when true, the function calculates the angle in degrees, otherwise, they are measured in radians.</li></ul></dd></dl><dl><dt class="spec value" id="val-magnitude"><a href="#val-magnitude" class="anchor"></a><code><span class="keyword">val</span> magnitude : <span>?&#8288;magnitude:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>magnitude ?magnitude x y</code></p><p>Calculates the magnitude of 2D vectors.</p><p>The function cv::magnitude calculates the magnitude of 2D vectors formed from the corresponding elements of x and y arrays: <code> \texttt{dst} (I) =  \sqrt{\texttt{x}(I)^2 + \texttt{y}(I)^2} </code></p><ul><li>Parameter: <code>x</code>: floating-point array of x-coordinates of the vectors.</li><li>Parameter: <code>y</code>: floating-point array of y-coordinates of the vectors; it must have the same size as x.</li><li>Parameter: <code>magnitude</code>: output array of the same size and type as x. See also: cartToPolar, polarToCart, phase, sqrt</li></ul></dd></dl><dl><dt class="spec value" id="val-check_range"><a href="#val-check_range" class="anchor"></a><code><span class="keyword">val</span> check_range : <span>?&#8288;quiet:bool</span> <span>&#45;&gt;</span> <span>?&#8288;pos:<a href="index.html#type-point2i">point2i</a></span> <span>&#45;&gt;</span> <span>?&#8288;min_val:float</span> <span>&#45;&gt;</span> <span>?&#8288;max_val:float</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Usage: <code>check_range ?quiet ?pos ?min_val ?max_val a</code></p><p>Checks every element of an input array for invalid values.</p><p>The function cv::checkRange checks that every array element is neither NaN nor infinite. When minVal \&gt; -DBL_MAX and maxVal \&lt; DBL_MAX, the function also checks that each value is between minVal and maxVal. In case of multi-channel arrays, each channel is processed independently. If some values are out of range, position of the first outlier is stored in pos (when pos != NULL). Then, the function either returns false (when quiet=true) or throws an exception.</p><ul><li>Parameter: <code>a</code>: input array.</li><li>Parameter: <code>quiet</code>: a flag, indicating whether the functions quietly return false when the array elements are out of range or they throw an exception.</li><li>Parameter: <code>pos</code>: optional output parameter, when not NULL, must be a pointer to array of src.dims elements.</li><li>Parameter: <code>min_val</code>: inclusive lower boundary of valid values range.</li><li>Parameter: <code>max_val</code>: exclusive upper boundary of valid values range.</li></ul></dd></dl><dl><dt class="spec value" id="val-patch_na_ns"><a href="#val-patch_na_ns" class="anchor"></a><code><span class="keyword">val</span> patch_na_ns : <span>?&#8288;cv_val:float</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>patch_na_ns ?cv_val a</code></p><p>converts NaNs to the given number</p><ul><li>Parameter: <code>a</code>: input/output matrix (CV_32F type).</li><li>Parameter: <code>cv_val</code>: value to convert the NaNs</li></ul></dd></dl><dl><dt class="spec value" id="val-gemm"><a href="#val-gemm" class="anchor"></a><code><span class="keyword">val</span> gemm : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;flags:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>gemm ?dst ?flags src1 src2 alpha src3 beta</code></p><p>Performs generalized matrix multiplication.</p><p>The function cv::gemm performs generalized matrix multiplication similar to the gemm functions in BLAS level 3. For example, <code>gemm(src1, src2, alpha, src3, beta, dst, GEMM_1_T + GEMM_3_T)</code> corresponds to <code> \texttt{dst} =  \texttt{alpha} \cdot \texttt{src1} ^T  \cdot \texttt{src2} +  \texttt{beta} \cdot \texttt{src3} ^T </code></p><p>In case of complex (two-channel) data, performed a complex matrix multiplication.</p><p>The function can be replaced with a matrix expression. For example, the above call can be replaced with:</p><pre><code class="ml">dst = alpha*src1.t()*src2 + beta*src3.t();</code></pre><ul><li>Parameter: <code>src1</code>: first multiplied input matrix that could be real(CV_32FC1, CV_64FC1) or complex(CV_32FC2, CV_64FC2).</li><li>Parameter: <code>src2</code>: second multiplied input matrix of the same type as src1.</li><li>Parameter: <code>alpha</code>: weight of the matrix product.</li><li>Parameter: <code>src3</code>: third optional delta matrix added to the matrix product; it should have the same type as src1 and src2.</li><li>Parameter: <code>beta</code>: weight of src3.</li><li>Parameter: <code>dst</code>: output matrix; it has the proper size and the same type as input matrices.</li><li>Parameter: <code>flags</code>: operation flags (cv::GemmFlags) See also: mulTransposed , transform</li></ul></dd></dl><dl><dt class="spec value" id="val-mul_transposed"><a href="#val-mul_transposed" class="anchor"></a><code><span class="keyword">val</span> mul_transposed : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;delta:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;scale:float</span> <span>&#45;&gt;</span> <span>?&#8288;dtype:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>mul_transposed ?dst ?delta ?scale ?dtype src a_ta</code></p><p>Calculates the product of a matrix and its transposition.</p><p>The function cv::mulTransposed calculates the product of src and its transposition: <code> \texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} )^T ( \texttt{src} - \texttt{delta} ) </code> if aTa=true , and <code> \texttt{dst} = \texttt{scale} ( \texttt{src} - \texttt{delta} ) ( \texttt{src} - \texttt{delta} )^T </code> otherwise. The function is used to calculate the covariance matrix. With zero delta, it can be used as a faster substitute for general matrix product A\*B when B=A'</p><ul><li>Parameter: <code>src</code>: input single-channel matrix. Note that unlike gemm, the function can multiply not only floating-point matrices.</li><li>Parameter: <code>dst</code>: output square matrix.</li><li>Parameter: <code>a_ta</code>: Flag specifying the multiplication ordering. See the description below.</li><li>Parameter: <code>delta</code>: Optional delta matrix subtracted from src before the multiplication. When the matrix is empty ( delta=noArray() ), it is assumed to be zero, that is, nothing is subtracted. If it has the same size as src , it is simply subtracted. Otherwise, it is &quot;repeated&quot; (see repeat ) to cover the full src and then subtracted. Type of the delta matrix, when it is not empty, must be the same as the type of created output matrix. See the dtype parameter description below.</li><li>Parameter: <code>scale</code>: Optional scale factor for the matrix product.</li><li>Parameter: <code>dtype</code>: Optional type of the output matrix. When it is negative, the output matrix will have the same type as src . Otherwise, it will be type=CV_MAT_DEPTH(dtype) that should be either CV_32F or CV_64F . See also: calcCovarMatrix, gemm, repeat, reduce</li></ul></dd></dl><dl><dt class="spec value" id="val-transpose"><a href="#val-transpose" class="anchor"></a><code><span class="keyword">val</span> transpose : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>transpose ?dst src</code></p><p>Transposes a matrix.</p><p>The function cv::transpose transposes the matrix src : <code> \texttt{dst} (i,j) =  \texttt{src} (j,i) </code> Note: No complex conjugation is done in case of a complex matrix. It should be done separately if needed.</p><ul><li>Parameter: <code>src</code>: input array.</li><li>Parameter: <code>dst</code>: output array of the same type as src.</li></ul></dd></dl><dl><dt class="spec value" id="val-transform"><a href="#val-transform" class="anchor"></a><code><span class="keyword">val</span> transform : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>transform ?dst src m</code></p><p>Performs the matrix transformation of every array element.</p><p>The function cv::transform performs the matrix transformation of every element of the array src and stores the results in dst : <code> \texttt{dst} (I) =  \texttt{m} \cdot \texttt{src} (I) </code> (when m.cols=src.channels() ), or <code> \texttt{dst} (I) =  \texttt{m} \cdot [ \texttt{src} (I); 1] </code> (when m.cols=src.channels()+1 )</p><p>Every element of the N -channel array src is interpreted as N -element vector that is transformed using the M x N or M x (N+1) matrix m to M-element vector - the corresponding element of the output array dst .</p><p>The function may be used for geometrical transformation of N -dimensional points, arbitrary linear color space transformation (such as various kinds of RGB to YUV transforms), shuffling the image channels, and so forth.</p><ul><li>Parameter: <code>src</code>: input array that must have as many channels (1 to 4) as m.cols or m.cols-1.</li><li>Parameter: <code>dst</code>: output array of the same size and depth as src; it has as many channels as m.rows.</li><li>Parameter: <code>m</code>: transformation 2x2 or 2x3 floating-point matrix. See also: perspectiveTransform, getAffineTransform, estimateAffine2D, warpAffine, warpPerspective</li></ul></dd></dl><dl><dt class="spec value" id="val-perspective_transform"><a href="#val-perspective_transform" class="anchor"></a><code><span class="keyword">val</span> perspective_transform : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>perspective_transform ?dst src m</code></p><p>Performs the perspective matrix transformation of vectors.</p><p>The function cv::perspectiveTransform transforms every element of src by treating it as a 2D or 3D vector, in the following way: <code> (x, y, z)  \rightarrow (x'/w, y'/w, z'/w) </code> where <code> (x', y', z', w') =  \texttt{mat} \cdot \begin{bmatrix} x &amp; y &amp; z &amp; 1  \end{bmatrix} </code> and <code> w =  \fork{w'}{if \(w' \ne 0\)}{\infty}{otherwise} </code></p><p>Here a 3D vector transformation is shown. In case of a 2D vector transformation, the z component is omitted.</p><p>Note: The function transforms a sparse set of 2D or 3D vectors. If you want to transform an image using perspective transformation, use warpPerspective . If you have an inverse problem, that is, you want to compute the most probable perspective transformation out of several pairs of corresponding points, you can use getPerspectiveTransform or findHomography .</p><ul><li>Parameter: <code>src</code>: input two-channel or three-channel floating-point array; each element is a 2D/3D vector to be transformed.</li><li>Parameter: <code>dst</code>: output array of the same size and type as src.</li><li>Parameter: <code>m</code>: 3x3 or 4x4 floating-point transformation matrix. See also: transform, warpPerspective, getPerspectiveTransform, findHomography</li></ul></dd></dl><dl><dt class="spec value" id="val-complete_symm"><a href="#val-complete_symm" class="anchor"></a><code><span class="keyword">val</span> complete_symm : <span>?&#8288;lower_to_upper:bool</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>complete_symm ?lower_to_upper m</code></p><p>Copies the lower or the upper half of a square matrix to its another half.</p><p>The function cv::completeSymm copies the lower or the upper half of a square matrix to its another half. The matrix diagonal remains unchanged:</p><ul><li><code> \texttt{m}_{ij}=\texttt{m}_{ji} </code> for <code> i &gt; j </code> if lowerToUpper=false</li><li><code> \texttt{m}_{ij}=\texttt{m}_{ji} </code> for <code> i &lt; j </code> if lowerToUpper=true</li></ul><ul><li>Parameter: <code>m</code>: input-output floating-point square matrix.</li><li>Parameter: <code>lower_to_upper</code>: operation flag; if true, the lower half is copied to the upper half. Otherwise, the upper half is copied to the lower half. See also: flip, transpose</li></ul></dd></dl><dl><dt class="spec value" id="val-set_identity"><a href="#val-set_identity" class="anchor"></a><code><span class="keyword">val</span> set_identity : <span>?&#8288;s:<a href="Scalar/index.html#type-t">Scalar.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>set_identity ?s mtx</code></p><p>Initializes a scaled identity matrix.</p><p>The function cv::setIdentity initializes a scaled identity matrix: <code> \texttt{mtx} (i,j)= \fork{\texttt{value}}{ if \(i=j\)}{0}{otherwise} </code></p><p>The function can also be emulated using the matrix initializers and the matrix expressions:</p><pre><code class="ml">Mat A = Mat::eye(4, 3, CV_32F)*5;
// A will be set to [[5, 0, 0], [0, 5, 0], [0, 0, 5], [0, 0, 0]]</code></pre><ul><li>Parameter: <code>mtx</code>: matrix to initialize (not necessarily square).</li><li>Parameter: <code>s</code>: value to assign to diagonal elements. See also: Mat::zeros, Mat::ones, Mat::setTo, Mat::operator=</li></ul></dd></dl><dl><dt class="spec value" id="val-determinant"><a href="#val-determinant" class="anchor"></a><code><span class="keyword">val</span> determinant : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float</code></dt><dd><p>Usage: <code>determinant mtx</code></p><p>Returns the determinant of a square floating-point matrix.</p><p>The function cv::determinant calculates and returns the determinant of the specified matrix. For small matrices ( mtx.cols=mtx.rows\&lt;=3 ), the direct method is used. For larger matrices, the function uses LU factorization with partial pivoting.</p><p>For symmetric positively-determined matrices, it is also possible to use eigen decomposition to calculate the determinant.</p><ul><li>Parameter: <code>mtx</code>: input matrix that must have CV_32FC1 or CV_64FC1 type and square size. See also: trace, invert, solve, eigen, MatrixExpressions</li></ul></dd></dl><dl><dt class="spec value" id="val-trace"><a href="#val-trace" class="anchor"></a><code><span class="keyword">val</span> trace : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a></code></dt><dd><p>Usage: <code>trace mtx</code></p><p>Returns the trace of a matrix.</p><p>The function cv::trace returns the sum of the diagonal elements of the matrix mtx . <code> \mathrm{tr} ( \texttt{mtx} ) =  \sum _i  \texttt{mtx} (i,i) </code></p><ul><li>Parameter: <code>mtx</code>: input matrix.</li></ul></dd></dl><dl><dt class="spec value" id="val-invert"><a href="#val-invert" class="anchor"></a><code><span class="keyword">val</span> invert : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;flags:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * float</code></dt><dd><p>Usage: <code>invert ?dst ?flags src</code></p><p>Finds the inverse or pseudo-inverse of a matrix.</p><p>The function cv::invert inverts the matrix src and stores the result in dst . When the matrix src is singular or non-square, the function calculates the pseudo-inverse matrix (the dst matrix) so that norm(src\*dst - I) is minimal, where I is an identity matrix.</p><p>In case of the #DECOMP_LU method, the function returns non-zero value if the inverse has been successfully calculated and 0 if src is singular.</p><p>In case of the #DECOMP_SVD method, the function returns the inverse condition number of src (the ratio of the smallest singular value to the largest singular value) and 0 if src is singular. The SVD method calculates a pseudo-inverse matrix if src is singular.</p><p>Similarly to #DECOMP_LU, the method #DECOMP_CHOLESKY works only with non-singular square matrices that should also be symmetrical and positively defined. In this case, the function stores the inverted matrix in dst and returns non-zero. Otherwise, it returns 0.</p><ul><li>Parameter: <code>src</code>: input floating-point M x N matrix.</li><li>Parameter: <code>dst</code>: output matrix of N x M size and the same type as src.</li><li>Parameter: <code>flags</code>: inversion method (cv::DecompTypes) See also: solve, SVD</li></ul></dd></dl><dl><dt class="spec value" id="val-solve"><a href="#val-solve" class="anchor"></a><code><span class="keyword">val</span> solve : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;flags:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * bool</code></dt><dd><p>Usage: <code>solve ?dst ?flags src1 src2</code></p><p>Solves one or more linear systems or least-squares problems.</p><p>The function cv::solve solves a linear system or least-squares problem (the latter is possible with SVD or QR methods, or by specifying the flag #DECOMP_NORMAL ): <code> \texttt{dst} =  \arg \min _X \| \texttt{src1} \cdot \texttt{X} -  \texttt{src2} \| </code></p><p>If #DECOMP_LU or #DECOMP_CHOLESKY method is used, the function returns 1 if src1 (or <code> \texttt{src1}^T\texttt{src1} </code> ) is non-singular. Otherwise, it returns 0. In the latter case, dst is not valid. Other methods find a pseudo-solution in case of a singular left-hand side part.</p><p>Note: If you want to find a unity-norm solution of an under-defined singular system <code> \texttt{src1}\cdot\texttt{dst}=0 </code> , the function solve will not do the work. Use SVD::solveZ instead.</p><ul><li>Parameter: <code>src1</code>: input matrix on the left-hand side of the system.</li><li>Parameter: <code>src2</code>: input matrix on the right-hand side of the system.</li><li>Parameter: <code>dst</code>: output solution.</li><li>Parameter: <code>flags</code>: solution (matrix inversion) method (#DecompTypes) See also: invert, SVD, eigen</li></ul></dd></dl><dl><dt class="spec value" id="val-sort"><a href="#val-sort" class="anchor"></a><code><span class="keyword">val</span> sort : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>sort ?dst src flags</code></p><p>Sorts each row or each column of a matrix.</p><p>The function cv::sort sorts each matrix row or each matrix column in ascending or descending order. So you should pass two operation flags to get desired behaviour. If you want to sort matrix rows or columns lexicographically, you can use STL std::sort generic function with the proper comparison predicate.</p><ul><li>Parameter: <code>src</code>: input single-channel array.</li><li>Parameter: <code>dst</code>: output array of the same size and type as src.</li><li>Parameter: <code>flags</code>: operation flags, a combination of #SortFlags See also: sortIdx, randShuffle</li></ul></dd></dl><dl><dt class="spec value" id="val-sort_idx"><a href="#val-sort_idx" class="anchor"></a><code><span class="keyword">val</span> sort_idx : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>sort_idx ?dst src flags</code></p><p>Sorts each row or each column of a matrix.</p><p>The function cv::sortIdx sorts each matrix row or each matrix column in the ascending or descending order. So you should pass two operation flags to get desired behaviour. Instead of reordering the elements themselves, it stores the indices of sorted elements in the output array. For example:</p><pre><code class="ml">Mat A = Mat::eye(3,3,CV_32F), B;
sortIdx(A, B, SORT_EVERY_ROW + SORT_ASCENDING);
// B will probably contain
// (because of equal elements in A some permutations are possible):
// [[1, 2, 0], [0, 2, 1], [0, 1, 2]]</code></pre><ul><li>Parameter: <code>src</code>: input single-channel array.</li><li>Parameter: <code>dst</code>: output integer array of the same size as src.</li><li>Parameter: <code>flags</code>: operation flags that could be a combination of cv::SortFlags See also: sort, randShuffle</li></ul></dd></dl><dl><dt class="spec value" id="val-solve_cubic"><a href="#val-solve_cubic" class="anchor"></a><code><span class="keyword">val</span> solve_cubic : <span>?&#8288;roots:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * int</code></dt><dd><p>Usage: <code>solve_cubic ?roots coeffs</code></p><p>Finds the real roots of a cubic equation.</p><p>The function solveCubic finds the real roots of a cubic equation:</p><ul><li>if coeffs is a 4-element vector: <code> \texttt{coeffs} [0] x^3 +  \texttt{coeffs} [1] x^2 +  \texttt{coeffs} [2] x +  \texttt{coeffs} [3] = 0 </code></li><li>if coeffs is a 3-element vector: <code> x^3 +  \texttt{coeffs} [0] x^2 +  \texttt{coeffs} [1] x +  \texttt{coeffs} [2] = 0 </code></li></ul><p>The roots are stored in the roots array.</p><ul><li>Parameter: <code>coeffs</code>: equation coefficients, an array of 3 or 4 elements.</li><li>Parameter: <code>roots</code>: output array of real roots that has 1 or 3 elements.</li><li>Returns: number of real roots. It can be 0, 1 or 2.</li></ul></dd></dl><dl><dt class="spec value" id="val-solve_poly"><a href="#val-solve_poly" class="anchor"></a><code><span class="keyword">val</span> solve_poly : <span>?&#8288;roots:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;max_iters:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * float</code></dt><dd><p>Usage: <code>solve_poly ?roots ?max_iters coeffs</code></p><p>Finds the real or complex roots of a polynomial equation.</p><p>The function cv::solvePoly finds real and complex roots of a polynomial equation: <code> \texttt{coeffs} [n] x^{n} +  \texttt{coeffs} [n-1] x^{n-1} + ... +  \texttt{coeffs} [1] x +  \texttt{coeffs} [0] = 0 </code></p><ul><li>Parameter: <code>coeffs</code>: array of polynomial coefficients.</li><li>Parameter: <code>roots</code>: output (complex) array of roots.</li><li>Parameter: <code>max_iters</code>: maximum number of iterations the algorithm does.</li></ul></dd></dl><dl><dt class="spec value" id="val-eigen"><a href="#val-eigen" class="anchor"></a><code><span class="keyword">val</span> eigen : <span>?&#8288;eigenvalues:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;eigenvectors:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a> * bool</code></dt><dd><p>Usage: <code>eigen ?eigenvalues ?eigenvectors src</code></p><p>Calculates eigenvalues and eigenvectors of a symmetric matrix.</p><p>The function cv::eigen calculates just eigenvalues, or eigenvalues and eigenvectors of the symmetric matrix src:</p><pre><code class="ml">src*eigenvectors.row(i).t() = eigenvalues.at&lt;srcType&gt;(i)*eigenvectors.row(i).t()</code></pre><p>Note: Use cv::eigenNonSymmetric for calculation of real eigenvalues and eigenvectors of non-symmetric matrix.</p><ul><li>Parameter: <code>src</code>: input matrix that must have CV_32FC1 or CV_64FC1 type, square size and be symmetrical (src ^T^ == src).</li><li>Parameter: <code>eigenvalues</code>: output vector of eigenvalues of the same type as src; the eigenvalues are stored in the descending order.</li><li>Parameter: <code>eigenvectors</code>: output matrix of eigenvectors; it has the same size and type as src; the eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues. See also: eigenNonSymmetric, completeSymm , PCA</li></ul></dd></dl><dl><dt class="spec value" id="val-eigen_non_symmetric"><a href="#val-eigen_non_symmetric" class="anchor"></a><code><span class="keyword">val</span> eigen_non_symmetric : <span>?&#8288;eigenvalues:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;eigenvectors:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>eigen_non_symmetric ?eigenvalues ?eigenvectors src</code></p><p>Calculates eigenvalues and eigenvectors of a non-symmetric matrix (real eigenvalues only).</p><p>Note: Assumes real eigenvalues.</p><p>The function calculates eigenvalues and eigenvectors (optional) of the square matrix src:</p><pre><code class="ml">src*eigenvectors.row(i).t() = eigenvalues.at&lt;srcType&gt;(i)*eigenvectors.row(i).t()</code></pre><ul><li>Parameter: <code>src</code>: input matrix (CV_32FC1 or CV_64FC1 type).</li><li>Parameter: <code>eigenvalues</code>: output vector of eigenvalues (type is the same type as src).</li><li>Parameter: <code>eigenvectors</code>: output matrix of eigenvectors (type is the same type as src). The eigenvectors are stored as subsequent matrix rows, in the same order as the corresponding eigenvalues. See also: eigen</li></ul></dd></dl><dl><dt class="spec value" id="val-calc_covar_matrix"><a href="#val-calc_covar_matrix" class="anchor"></a><code><span class="keyword">val</span> calc_covar_matrix : <span>?&#8288;covar:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;ctype:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>calc_covar_matrix ?covar ?ctype samples mean flags</code></p><p>Note: use #COVAR_ROWS or #COVAR_COLS flag</p><ul><li>Parameter: <code>samples</code>: samples stored as rows/columns of a single matrix.</li><li>Parameter: <code>covar</code>: output covariance matrix of the type ctype and square size.</li><li>Parameter: <code>mean</code>: input or output (depending on the flags) array as the average value of the input vectors.</li><li>Parameter: <code>flags</code>: operation flags as a combination of #CovarFlags</li><li>Parameter: <code>ctype</code>: type of the matrixl; it equals 'CV_64F' by default.</li></ul></dd></dl><dl><dt class="spec value" id="val-pca_compute1"><a href="#val-pca_compute1" class="anchor"></a><code><span class="keyword">val</span> pca_compute1 : <span>?&#8288;eigenvectors:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;max_components:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>pca_compute1 ?eigenvectors ?max_components data mean</code></p><p>wrap PCA::operator()</p></dd></dl><dl><dt class="spec value" id="val-pca_compute2"><a href="#val-pca_compute2" class="anchor"></a><code><span class="keyword">val</span> pca_compute2 : <span>?&#8288;eigenvectors:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;eigenvalues:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;max_components:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>pca_compute2 ?eigenvectors ?eigenvalues ?max_components data mean</code></p><p>wrap PCA::operator() and add eigenvalues output parameter</p></dd></dl><dl><dt class="spec value" id="val-pca_compute3"><a href="#val-pca_compute3" class="anchor"></a><code><span class="keyword">val</span> pca_compute3 : <span>?&#8288;eigenvectors:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>pca_compute3 ?eigenvectors data mean retained_variance</code></p><p>wrap PCA::operator()</p></dd></dl><dl><dt class="spec value" id="val-pca_compute4"><a href="#val-pca_compute4" class="anchor"></a><code><span class="keyword">val</span> pca_compute4 : <span>?&#8288;eigenvectors:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;eigenvalues:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>pca_compute4 ?eigenvectors ?eigenvalues data mean retained_variance</code></p><p>wrap PCA::operator() and add eigenvalues output parameter</p></dd></dl><dl><dt class="spec value" id="val-pca_project"><a href="#val-pca_project" class="anchor"></a><code><span class="keyword">val</span> pca_project : <span>?&#8288;result:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>pca_project ?result data mean eigenvectors</code></p><p>wrap PCA::project</p></dd></dl><dl><dt class="spec value" id="val-pca_back_project"><a href="#val-pca_back_project" class="anchor"></a><code><span class="keyword">val</span> pca_back_project : <span>?&#8288;result:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>pca_back_project ?result data mean eigenvectors</code></p><p>wrap PCA::backProject</p></dd></dl><dl><dt class="spec value" id="val-sv_decomp"><a href="#val-sv_decomp" class="anchor"></a><code><span class="keyword">val</span> sv_decomp : <span>?&#8288;w:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;u:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;vt:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;flags:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>sv_decomp ?w ?u ?vt ?flags src</code></p><p>wrap SVD::compute</p></dd></dl><dl><dt class="spec value" id="val-sv_back_subst"><a href="#val-sv_back_subst" class="anchor"></a><code><span class="keyword">val</span> sv_back_subst : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>sv_back_subst ?dst w u vt rhs</code></p><p>wrap SVD::backSubst</p></dd></dl><dl><dt class="spec value" id="val-mahalanobis"><a href="#val-mahalanobis" class="anchor"></a><code><span class="keyword">val</span> mahalanobis : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float</code></dt><dd><p>Usage: <code>mahalanobis v1 v2 icovar</code></p><p>Calculates the Mahalanobis distance between two vectors.</p><p>The function cv::Mahalanobis calculates and returns the weighted distance between two vectors: <code> d( \texttt{vec1} , \texttt{vec2} )= \sqrt{\sum_{i,j}{\texttt{icovar(i,j)}\cdot(\texttt{vec1}(I)-\texttt{vec2}(I))\cdot(\texttt{vec1(j)}-\texttt{vec2(j)})} } </code> The covariance matrix may be calculated using the #calcCovarMatrix function and then inverted using the invert function (preferably using the #DECOMP_SVD method, as the most accurate).</p><ul><li>Parameter: <code>v1</code>: first 1D input vector.</li><li>Parameter: <code>v2</code>: second 1D input vector.</li><li>Parameter: <code>icovar</code>: inverse covariance matrix.</li></ul></dd></dl><dl><dt class="spec value" id="val-dft"><a href="#val-dft" class="anchor"></a><code><span class="keyword">val</span> dft : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;flags:int</span> <span>&#45;&gt;</span> <span>?&#8288;nonzero_rows:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>dft ?dst ?flags ?nonzero_rows src</code></p><p>Performs a forward or inverse Discrete Fourier transform of a 1D or 2D floating-point array.</p><p>The function cv::dft performs one of the following:</p><ul><li>Forward the Fourier transform of a 1D vector of N elements: <code> Y = F^{(N)}  \cdot X, </code> where <code> F^{(N)}_{jk}=\exp(-2\pi i j k/N) </code> and <code> i=\sqrt{-1} </code></li><li>Inverse the Fourier transform of a 1D vector of N elements: <code> \begin{array}{l} X'=  \left (F^{(N)} \right )^{-1}  \cdot Y =  \left (F^{(N)} \right )^*  \cdot y  \\ X = (1/N)  \cdot X, \end{array} </code> where <code> F^*=\left(\textrm{Re}(F^{(N)})-\textrm{Im}(F^{(N)})\right)^T </code></li><li>Forward the 2D Fourier transform of a M x N matrix: <code> Y = F^{(M)}  \cdot X  \cdot F^{(N)} </code></li><li>Inverse the 2D Fourier transform of a M x N matrix: <code> \begin{array}{l} X'=  \left (F^{(M)} \right )^*  \cdot Y  \cdot \left (F^{(N)} \right )^* \\ X =  \frac{1}{M \cdot N} \cdot X' \end{array} </code></li></ul><p>In case of real (single-channel) data, the output spectrum of the forward Fourier transform or input spectrum of the inverse Fourier transform can be represented in a packed format called *CCS* (complex-conjugate-symmetrical). It was borrowed from IPL (Intel\* Image Processing Library). Here is how 2D *CCS* spectrum looks: <code> \begin{bmatrix} Re Y_{0,0} &amp; Re Y_{0,1} &amp; Im Y_{0,1} &amp; Re Y_{0,2} &amp; Im Y_{0,2} &amp;  \cdots &amp; Re Y_{0,N/2-1} &amp; Im Y_{0,N/2-1} &amp; Re Y_{0,N/2}  \\ Re Y_{1,0} &amp; Re Y_{1,1} &amp; Im Y_{1,1} &amp; Re Y_{1,2} &amp; Im Y_{1,2} &amp;  \cdots &amp; Re Y_{1,N/2-1} &amp; Im Y_{1,N/2-1} &amp; Re Y_{1,N/2}  \\ Im Y_{1,0} &amp; Re Y_{2,1} &amp; Im Y_{2,1} &amp; Re Y_{2,2} &amp; Im Y_{2,2} &amp;  \cdots &amp; Re Y_{2,N/2-1} &amp; Im Y_{2,N/2-1} &amp; Im Y_{1,N/2}  \\ \hdotsfor{9} \\ Re Y_{M/2-1,0} &amp;  Re Y_{M-3,1}  &amp; Im Y_{M-3,1} &amp;  \hdotsfor{3} &amp; Re Y_{M-3,N/2-1} &amp; Im Y_{M-3,N/2-1}&amp; Re Y_{M/2-1,N/2}  \\ Im Y_{M/2-1,0} &amp;  Re Y_{M-2,1}  &amp; Im Y_{M-2,1} &amp;  \hdotsfor{3} &amp; Re Y_{M-2,N/2-1} &amp; Im Y_{M-2,N/2-1}&amp; Im Y_{M/2-1,N/2}  \\ Re Y_{M/2,0}  &amp;  Re Y_{M-1,1} &amp;  Im Y_{M-1,1} &amp;  \hdotsfor{3} &amp; Re Y_{M-1,N/2-1} &amp; Im Y_{M-1,N/2-1}&amp; Re Y_{M/2,N/2} \end{bmatrix} </code></p><p>In case of 1D transform of a real vector, the output looks like the first row of the matrix above.</p><p>So, the function chooses an operation mode depending on the flags and size of the input array:</p><ul><li>If #DFT_ROWS is set or the input array has a single row or single column, the function performs a 1D forward or inverse transform of each row of a matrix when #DFT_ROWS is set. Otherwise, it performs a 2D transform.</li><li>If the input array is real and #DFT_INVERSE is not set, the function performs a forward 1D or 2D transform:</li><li>When #DFT_COMPLEX_OUTPUT is set, the output is a complex matrix of the same size as input.</li><li>When #DFT_COMPLEX_OUTPUT is not set, the output is a real matrix of the same size as input. In case of 2D transform, it uses the packed format as shown above. In case of a single 1D transform, it looks like the first row of the matrix above. In case of multiple 1D transforms (when using the #DFT_ROWS flag), each row of the output matrix looks like the first row of the matrix above.</li><li>If the input array is complex and either #DFT_INVERSE or #DFT_REAL_OUTPUT are not set, the output is a complex array of the same size as input. The function performs a forward or inverse 1D or 2D transform of the whole input array or each row of the input array independently, depending on the flags DFT_INVERSE and DFT_ROWS.</li><li>When #DFT_INVERSE is set and the input array is real, or it is complex but #DFT_REAL_OUTPUT is set, the output is a real array of the same size as input. The function performs a 1D or 2D inverse transformation of the whole input array or each individual row, depending on the flags #DFT_INVERSE and #DFT_ROWS.</li></ul><p>If #DFT_SCALE is set, the scaling is done after the transformation.</p><p>Unlike dct , the function supports arrays of arbitrary size. But only those arrays are processed efficiently, whose sizes can be factorized in a product of small prime numbers (2, 3, and 5 in the current implementation). Such an efficient DFT size can be calculated using the getOptimalDFTSize method.</p><p>The sample below illustrates how to calculate a DFT-based convolution of two 2D real arrays:</p><pre><code class="ml">void convolveDFT(InputArray A, InputArray B, OutputArray C)
{
    // reallocate the output array if needed
    C.create(abs(A.rows - B.rows)+1, abs(A.cols - B.cols)+1, A.type());
    Size dftSize;
    // calculate the size of DFT transform
    dftSize.width = getOptimalDFTSize(A.cols + B.cols - 1);
    dftSize.height = getOptimalDFTSize(A.rows + B.rows - 1);

    // allocate temporary buffers and initialize them with 0's
    Mat tempA(dftSize, A.type(), Scalar::all(0));
    Mat tempB(dftSize, B.type(), Scalar::all(0));

    // copy A and B to the top-left corners of tempA and tempB, respectively
    Mat roiA(tempA, Rect(0,0,A.cols,A.rows));
    A.copyTo(roiA);
    Mat roiB(tempB, Rect(0,0,B.cols,B.rows));
    B.copyTo(roiB);

    // now transform the padded A &amp; B in-place;
    // use &quot;nonzeroRows&quot; hint for faster processing
    dft(tempA, tempA, 0, A.rows);
    dft(tempB, tempB, 0, B.rows);

    // multiply the spectrums;
    // the function handles packed spectrum representations well
    mulSpectrums(tempA, tempB, tempA);

    // transform the product back from the frequency domain.
    // Even though all the result rows will be non-zero,
    // you need only the first C.rows of them, and thus you
    // pass nonzeroRows == C.rows
    dft(tempA, tempA, DFT_INVERSE + DFT_SCALE, C.rows);

    // now copy the result back to C.
    tempA(Rect(0, 0, C.cols, C.rows)).copyTo(C);

    // all the temporary buffers will be deallocated automatically
}</code></pre><p>To optimize this sample, consider the following approaches:</p><ul><li>Since nonzeroRows != 0 is passed to the forward transform calls and since A and B are copied to the top-left corners of tempA and tempB, respectively, it is not necessary to clear the whole tempA and tempB. It is only necessary to clear the tempA.cols - A.cols ( tempB.cols - B.cols) rightmost columns of the matrices.</li><li>This DFT-based convolution does not have to be applied to the whole big arrays, especially if B is significantly smaller than A or vice versa. Instead, you can calculate convolution by parts. To do this, you need to split the output array C into multiple tiles. For each tile, estimate which parts of A and B are required to calculate convolution in this tile. If the tiles in C are too small, the speed will decrease a lot because of repeated work. In the ultimate case, when each tile in C is a single pixel, the algorithm becomes equivalent to the naive convolution algorithm. If the tiles are too big, the temporary arrays tempA and tempB become too big and there is also a slowdown because of bad cache locality. So, there is an optimal tile size somewhere in the middle.</li><li>If different tiles in C can be calculated in parallel and, thus, the convolution is done by parts, the loop can be threaded.</li></ul><p>All of the above improvements have been implemented in #matchTemplate and #filter2D . Therefore, by using them, you can get the performance even better than with the above theoretically optimal implementation. Though, those two functions actually calculate cross-correlation, not convolution, so you need to &quot;flip&quot; the second convolution operand B vertically and horizontally using flip . Note:</p><ul><li>An example using the discrete fourier transform can be found at opencv_source_code/samples/cpp/dft.cpp</li><li>(Python) An example using the dft functionality to perform Wiener deconvolution can be found at opencv_source/samples/python/deconvolution.py</li><li>(Python) An example rearranging the quadrants of a Fourier image can be found at opencv_source/samples/python/dft.py</li><li>Parameter: <code>src</code>: input array that could be real or complex.</li><li>Parameter: <code>dst</code>: output array whose size and type depends on the flags .</li><li>Parameter: <code>flags</code>: transformation flags, representing a combination of the #DftFlags</li><li>Parameter: <code>nonzero_rows</code>: when the parameter is not zero, the function assumes that only the first nonzeroRows rows of the input array (#DFT_INVERSE is not set) or only the first nonzeroRows of the output array (#DFT_INVERSE is set) contain non-zeros, thus, the function can handle the rest of the rows more efficiently and save some time; this technique is very useful for calculating array cross-correlation or convolution using DFT. See also: dct , getOptimalDFTSize , mulSpectrums, filter2D , matchTemplate , flip , cartToPolar , magnitude , phase</li></ul></dd></dl><dl><dt class="spec value" id="val-idft"><a href="#val-idft" class="anchor"></a><code><span class="keyword">val</span> idft : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;flags:int</span> <span>&#45;&gt;</span> <span>?&#8288;nonzero_rows:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>idft ?dst ?flags ?nonzero_rows src</code></p><p>Calculates the inverse Discrete Fourier Transform of a 1D or 2D array.</p><p>idft(src, dst, flags) is equivalent to dft(src, dst, flags | #DFT_INVERSE) . Note: None of dft and idft scales the result by default. So, you should pass #DFT_SCALE to one of dft or idft explicitly to make these transforms mutually inverse. See also: dft, dct, idct, mulSpectrums, getOptimalDFTSize</p><ul><li>Parameter: <code>src</code>: input floating-point real or complex array.</li><li>Parameter: <code>dst</code>: output array whose size and type depend on the flags.</li><li>Parameter: <code>flags</code>: operation flags (see dft and #DftFlags).</li><li>Parameter: <code>nonzero_rows</code>: number of dst rows to process; the rest of the rows have undefined content (see the convolution sample in dft description.</li></ul></dd></dl><dl><dt class="spec value" id="val-dct"><a href="#val-dct" class="anchor"></a><code><span class="keyword">val</span> dct : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;flags:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>dct ?dst ?flags src</code></p><p>Performs a forward or inverse discrete Cosine transform of 1D or 2D array.</p><p>The function cv::dct performs a forward or inverse discrete Cosine transform (DCT) of a 1D or 2D floating-point array:</p><ul><li>Forward Cosine transform of a 1D vector of N elements: <code> Y = C^{(N)}  \cdot X </code> where <code> C^{(N)}_{jk}= \sqrt{\alpha_j/N} \cos \left ( \frac{\pi(2k+1)j}{2N} \right ) </code> and <code> \alpha_0=1 </code>, <code> \alpha_j=2 </code> for *j \&gt; 0*.</li><li>Inverse Cosine transform of a 1D vector of N elements: <code> X =  \left (C^{(N)} \right )^{-1}  \cdot Y =  \left (C^{(N)} \right )^T  \cdot Y </code> (since <code> C^{(N)} </code> is an orthogonal matrix, <code> C^{(N)} \cdot \left(C^{(N)}\right)^T = I </code> )</li><li>Forward 2D Cosine transform of M x N matrix: <code> Y = C^{(N)}  \cdot X  \cdot \left (C^{(N)} \right )^T </code></li><li>Inverse 2D Cosine transform of M x N matrix: <code> X =  \left (C^{(N)} \right )^T  \cdot X  \cdot C^{(N)} </code></li></ul><p>The function chooses the mode of operation by looking at the flags and size of the input array:</p><ul><li>If (flags &amp; #DCT_INVERSE) == 0 , the function does a forward 1D or 2D transform. Otherwise, it is an inverse 1D or 2D transform.</li><li>If (flags &amp; #DCT_ROWS) != 0 , the function performs a 1D transform of each row.</li><li>If the array is a single column or a single row, the function performs a 1D transform.</li><li>If none of the above is true, the function performs a 2D transform.</li></ul><p>Note: Currently dct supports even-size arrays (2, 4, 6 ...). For data analysis and approximation, you can pad the array when necessary. Also, the function performance depends very much, and not monotonically, on the array size (see getOptimalDFTSize ). In the current implementation DCT of a vector of size N is calculated via DFT of a vector of size N/2 . Thus, the optimal DCT size N1 \&gt;= N can be calculated as:</p><pre><code class="ml">size_t getOptimalDCTSize(size_t N) { return 2*getOptimalDFTSize((N+1)/2); }
N1 = getOptimalDCTSize(N);</code></pre><ul><li>Parameter: <code>src</code>: input floating-point array.</li><li>Parameter: <code>dst</code>: output array of the same size and type as src .</li><li>Parameter: <code>flags</code>: transformation flags as a combination of cv::DftFlags (DCT_* ) See also: dft , getOptimalDFTSize , idct</li></ul></dd></dl><dl><dt class="spec value" id="val-idct"><a href="#val-idct" class="anchor"></a><code><span class="keyword">val</span> idct : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;flags:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>idct ?dst ?flags src</code></p><p>Calculates the inverse Discrete Cosine Transform of a 1D or 2D array.</p><p>idct(src, dst, flags) is equivalent to dct(src, dst, flags | DCT_INVERSE).</p><ul><li>Parameter: <code>src</code>: input floating-point single-channel array.</li><li>Parameter: <code>dst</code>: output array of the same size and type as src.</li><li>Parameter: <code>flags</code>: operation flags. See also: dct, dft, idft, getOptimalDFTSize</li></ul></dd></dl><dl><dt class="spec value" id="val-mul_spectrums"><a href="#val-mul_spectrums" class="anchor"></a><code><span class="keyword">val</span> mul_spectrums : <span>?&#8288;c:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;conj_b:bool</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>mul_spectrums ?c ?conj_b a b flags</code></p><p>Performs the per-element multiplication of two Fourier spectrums.</p><p>The function cv::mulSpectrums performs the per-element multiplication of the two CCS-packed or complex matrices that are results of a real or complex Fourier transform.</p><p>The function, together with dft and idft , may be used to calculate convolution (pass conjB=false ) or correlation (pass conjB=true ) of two arrays rapidly. When the arrays are complex, they are simply multiplied (per element) with an optional conjugation of the second-array elements. When the arrays are real, they are assumed to be CCS-packed (see dft for details).</p><ul><li>Parameter: <code>a</code>: first input array.</li><li>Parameter: <code>b</code>: second input array of the same size and type as src1 .</li><li>Parameter: <code>c</code>: output array of the same size and type as src1 .</li><li>Parameter: <code>flags</code>: operation flags; currently, the only supported flag is cv::DFT_ROWS, which indicates that each row of src1 and src2 is an independent 1D Fourier spectrum. If you do not want to use this flag, then simply add a <code>0</code> as value.</li><li>Parameter: <code>conj_b</code>: optional flag that conjugates the second input array before the multiplication (true) or not (false).</li></ul></dd></dl><dl><dt class="spec value" id="val-get_optimal_dft_size"><a href="#val-get_optimal_dft_size" class="anchor"></a><code><span class="keyword">val</span> get_optimal_dft_size : int <span>&#45;&gt;</span> int</code></dt><dd><p>Usage: <code>get_optimal_dft_size vecsize</code></p><p>Returns the optimal DFT size for a given vector size.</p><p>DFT performance is not a monotonic function of a vector size. Therefore, when you calculate convolution of two arrays or perform the spectral analysis of an array, it usually makes sense to pad the input data with zeros to get a bit larger array that can be transformed much faster than the original one. Arrays whose size is a power-of-two (2, 4, 8, 16, 32, ...) are the fastest to process. Though, the arrays whose size is a product of 2's, 3's, and 5's (for example, 300 = 5\*5\*3\*2\*2) are also processed quite efficiently.</p><p>The function cv::getOptimalDFTSize returns the minimum number N that is greater than or equal to vecsize so that the DFT of a vector of size N can be processed efficiently. In the current implementation N = 2 ^p^ \* 3 ^q^ \* 5 ^r^ for some integer p, q, r.</p><p>The function returns a negative number if vecsize is too large (very close to INT_MAX ).</p><p>While the function cannot be used directly to estimate the optimal vector size for DCT transform (since the current DCT implementation supports only even-size vectors), it can be easily processed as getOptimalDFTSize((vecsize+1)/2)\*2.</p><ul><li>Parameter: <code>vecsize</code>: vector size. See also: dft , dct , idft , idct , mulSpectrums</li></ul></dd></dl><dl><dt class="spec value" id="val-set_rng_seed"><a href="#val-set_rng_seed" class="anchor"></a><code><span class="keyword">val</span> set_rng_seed : int <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>set_rng_seed seed</code></p><p>Sets state of default random number generator.</p><p>The function cv::setRNGSeed sets state of default random number generator to custom value.</p><ul><li>Parameter: <code>seed</code>: new state for default random number generator See also: RNG, randu, randn</li></ul></dd></dl><dl><dt class="spec value" id="val-randu"><a href="#val-randu" class="anchor"></a><code><span class="keyword">val</span> randu : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>randu dst low high</code></p><p>Generates a single uniformly-distributed random number or an array of random numbers.</p><p>Non-template variant of the function fills the matrix dst with uniformly-distributed random numbers from the specified range: <code> \texttt{low} _c  \leq \texttt{dst} (I)_c &lt;  \texttt{high} _c </code></p><ul><li>Parameter: <code>dst</code>: output array of random numbers; the array must be pre-allocated.</li><li>Parameter: <code>low</code>: inclusive lower boundary of the generated random numbers.</li><li>Parameter: <code>high</code>: exclusive upper boundary of the generated random numbers. See also: RNG, randn, theRNG</li></ul></dd></dl><dl><dt class="spec value" id="val-randn"><a href="#val-randn" class="anchor"></a><code><span class="keyword">val</span> randn : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>randn dst mean stddev</code></p><p>Fills the array with normally distributed random numbers.</p><p>The function cv::randn fills the matrix dst with normally distributed random numbers with the specified mean vector and the standard deviation matrix. The generated random numbers are clipped to fit the value range of the output array data type.</p><ul><li>Parameter: <code>dst</code>: output array of random numbers; the array must be pre-allocated and have 1 to 4 channels.</li><li>Parameter: <code>mean</code>: mean value (expectation) of the generated random numbers.</li><li>Parameter: <code>stddev</code>: standard deviation of the generated random numbers; it can be either a vector (in which case a diagonal standard deviation matrix is assumed) or a square matrix. See also: RNG, randu</li></ul></dd></dl><dl><dt class="spec value" id="val-rand_shuffle"><a href="#val-rand_shuffle" class="anchor"></a><code><span class="keyword">val</span> rand_shuffle : <span>?&#8288;iter_factor:float</span> <span>&#45;&gt;</span> <span>?&#8288;rng:<a href="Rng/index.html#type-t">Rng.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>rand_shuffle ?iter_factor ?rng dst</code></p><p>Shuffles the array elements randomly.</p><p>The function cv::randShuffle shuffles the specified 1D array by randomly choosing pairs of elements and swapping them. The number of such swap operations will be dst.rows\*dst.cols\*iterFactor .</p><ul><li>Parameter: <code>dst</code>: input/output numerical 1D array.</li><li>Parameter: <code>iter_factor</code>: scale factor that determines the number of random swap operations (see the details below).</li><li>Parameter: <code>rng</code>: optional random number generator used for shuffling; if it is zero, theRNG () is used instead. See also: RNG, sort</li></ul></dd></dl><dl><dt class="spec value" id="val-get_gaussian_kernel"><a href="#val-get_gaussian_kernel" class="anchor"></a><code><span class="keyword">val</span> get_gaussian_kernel : <span>?&#8288;ktype:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Mat/index.html#type-t">Mat.t</a></code></dt><dd><p>Usage: <code>get_gaussian_kernel ?ktype ksize sigma</code></p><p>Returns Gaussian filter coefficients.</p><p>The function computes and returns the <code> \texttt{ksize} \times 1 </code> matrix of Gaussian filter coefficients:</p><p><code> G_i= \alpha *e^{-(i-( \texttt{ksize} -1)/2)^2/(2* \texttt{sigma}^2)}, </code></p><p>where <code> i=0..\texttt{ksize}-1 </code> and <code> \alpha </code> is the scale factor chosen so that <code> \sum_i G_i=1 </code>.</p><p>Two of such generated kernels can be passed to sepFilter2D. Those functions automatically recognize smoothing kernels (a symmetrical kernel with sum of weights equal to 1) and handle them accordingly. You may also use the higher-level GaussianBlur.</p><ul><li>Parameter: <code>ksize</code>: Aperture size. It should be odd ( <code> \texttt{ksize} \mod 2 = 1 </code> ) and positive.</li><li>Parameter: <code>sigma</code>: Gaussian standard deviation. If it is non-positive, it is computed from ksize as <code>sigma = 0.3*((ksize-1)*0.5 - 1) + 0.8</code>.</li><li>Parameter: <code>ktype</code>: Type of filter coefficients. It can be CV_32F or CV_64F . See also: sepFilter2D, getDerivKernels, getStructuringElement, GaussianBlur</li></ul></dd></dl><dl><dt class="spec value" id="val-get_deriv_kernels"><a href="#val-get_deriv_kernels" class="anchor"></a><code><span class="keyword">val</span> get_deriv_kernels : <span>?&#8288;kx:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;ky:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;normalize:bool</span> <span>&#45;&gt;</span> <span>?&#8288;ktype:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>get_deriv_kernels ?kx ?ky ?normalize ?ktype dx dy ksize</code></p><p>Returns filter coefficients for computing spatial image derivatives.</p><p>The function computes and returns the filter coefficients for spatial image derivatives. When <code>ksize=FILTER_SCHARR</code>, the Scharr <code> 3 \times 3 </code> kernels are generated (see #Scharr). Otherwise, Sobel kernels are generated (see #Sobel). The filters are normally passed to #sepFilter2D or to</p><ul><li>Parameter: <code>kx</code>: Output matrix of row filter coefficients. It has the type ktype .</li><li>Parameter: <code>ky</code>: Output matrix of column filter coefficients. It has the type ktype .</li><li>Parameter: <code>dx</code>: Derivative order in respect of x.</li><li>Parameter: <code>dy</code>: Derivative order in respect of y.</li><li>Parameter: <code>ksize</code>: Aperture size. It can be FILTER_SCHARR, 1, 3, 5, or 7.</li><li>Parameter: <code>normalize</code>: Flag indicating whether to normalize (scale down) the filter coefficients or not. Theoretically, the coefficients should have the denominator <code> =2^{ksize*2-dx-dy-2} </code>. If you are going to filter floating-point images, you are likely to use the normalized kernels. But if you compute derivatives of an 8-bit image, store the results in a 16-bit image, and wish to preserve all the fractional bits, you may want to set normalize=false .</li><li>Parameter: <code>ktype</code>: Type of filter coefficients. It can be CV_32f or CV_64F .</li></ul></dd></dl><dl><dt class="spec value" id="val-get_gabor_kernel"><a href="#val-get_gabor_kernel" class="anchor"></a><code><span class="keyword">val</span> get_gabor_kernel : <span>?&#8288;psi:float</span> <span>&#45;&gt;</span> <span>?&#8288;ktype:int</span> <span>&#45;&gt;</span> <a href="index.html#type-size2i">size2i</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Mat/index.html#type-t">Mat.t</a></code></dt><dd><p>Usage: <code>get_gabor_kernel ?psi ?ktype ksize sigma theta lambd gamma</code></p><p>Returns Gabor filter coefficients.</p><p>For more details about gabor filter equations and parameters, see: <code>Gabor
Filter</code>(http://en.wikipedia.org/wiki/Gabor_filter).</p><ul><li>Parameter: <code>ksize</code>: Size of the filter returned.</li><li>Parameter: <code>sigma</code>: Standard deviation of the gaussian envelope.</li><li>Parameter: <code>theta</code>: Orientation of the normal to the parallel stripes of a Gabor function.</li><li>Parameter: <code>lambd</code>: Wavelength of the sinusoidal factor.</li><li>Parameter: <code>gamma</code>: Spatial aspect ratio.</li><li>Parameter: <code>psi</code>: Phase offset.</li><li>Parameter: <code>ktype</code>: Type of filter coefficients. It can be CV_32F or CV_64F .</li></ul></dd></dl><dl><dt class="spec value" id="val-get_structuring_element"><a href="#val-get_structuring_element" class="anchor"></a><code><span class="keyword">val</span> get_structuring_element : <span>?&#8288;anchor:<a href="index.html#type-point2i">point2i</a></span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-size2i">size2i</a> <span>&#45;&gt;</span> <a href="Mat/index.html#type-t">Mat.t</a></code></dt><dd><p>Usage: <code>get_structuring_element ?anchor shape ksize</code></p><p>Returns a structuring element of the specified size and shape for morphological operations.</p><p>The function constructs and returns the structuring element that can be further passed to #erode, #dilate or #morphologyEx. But you can also construct an arbitrary binary mask yourself and use it as the structuring element.</p><ul><li>Parameter: <code>shape</code>: Element shape that could be one of #MorphShapes</li><li>Parameter: <code>ksize</code>: Size of the structuring element.</li><li>Parameter: <code>anchor</code>: Anchor position within the element. The default value <code> (-1, -1) </code> means that the anchor is at the center. Note that only the shape of a cross-shaped element depends on the anchor position. In other cases the anchor just regulates how much the result of the morphological operation is shifted.</li></ul></dd></dl><dl><dt class="spec value" id="val-median_blur"><a href="#val-median_blur" class="anchor"></a><code><span class="keyword">val</span> median_blur : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>median_blur ?dst src ksize</code></p><p>Blurs an image using the median filter.</p><p>The function smoothes an image using the median filter with the <code> \texttt{ksize} \times
\texttt{ksize} </code> aperture. Each channel of a multi-channel image is processed independently. In-place operation is supported.</p><p>Note: The median filter uses #BORDER_REPLICATE internally to cope with border pixels, see #BorderTypes</p><ul><li>Parameter: <code>src</code>: input 1-, 3-, or 4-channel image; when ksize is 3 or 5, the image depth should be CV_8U, CV_16U, or CV_32F, for larger aperture sizes, it can only be CV_8U.</li><li>Parameter: <code>dst</code>: destination array of the same size and type as src.</li><li>Parameter: <code>ksize</code>: aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ... See also: bilateralFilter, blur, boxFilter, GaussianBlur</li></ul></dd></dl><dl><dt class="spec value" id="val-gaussian_blur"><a href="#val-gaussian_blur" class="anchor"></a><code><span class="keyword">val</span> gaussian_blur : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;sigma_y:float</span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-size2i">size2i</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>gaussian_blur ?dst ?sigma_y ?border_type src ksize sigma_x</code></p><p>Blurs an image using a Gaussian filter.</p><p>The function convolves the source image with the specified Gaussian kernel. In-place filtering is supported.</p><ul><li>Parameter: <code>src</code>: input image; the image can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</li><li>Parameter: <code>dst</code>: output image of the same size and type as src.</li><li>Parameter: <code>ksize</code>: Gaussian kernel size. ksize.width and ksize.height can differ but they both must be positive and odd. Or, they can be zero's and then they are computed from sigma.</li><li>Parameter: <code>sigma_x</code>: Gaussian kernel standard deviation in X direction.</li><li>Parameter: <code>sigma_y</code>: Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height, respectively (see #getGaussianKernel for details); to fully control the result regardless of possible future modifications of all this semantics, it is recommended to specify all of ksize, sigmaX, and sigmaY.</li><li>Parameter: <code>border_type</code>: pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.</li></ul><p>See also: sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur</p></dd></dl><dl><dt class="spec value" id="val-bilateral_filter"><a href="#val-bilateral_filter" class="anchor"></a><code><span class="keyword">val</span> bilateral_filter : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>bilateral_filter ?dst ?border_type src d sigma_color sigma_space</code></p><p>Applies the bilateral filter to an image.</p><p>The function applies bilateral filtering to the input image, as described in http://www.dai.ed.ac.uk/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html bilateralFilter can reduce unwanted noise very well while keeping edges fairly sharp. However, it is very slow compared to most filters.</p><p>_Sigma values_: For simplicity, you can set the 2 sigma values to be the same. If they are small (\&lt; 10), the filter will not have much effect, whereas if they are large (\&gt; 150), they will have a very strong effect, making the image look &quot;cartoonish&quot;.</p><p>_Filter size_: Large filters (d \&gt; 5) are very slow, so it is recommended to use d=5 for real-time applications, and perhaps d=9 for offline applications that need heavy noise filtering.</p><p>This filter does not work inplace.</p><ul><li>Parameter: <code>src</code>: Source 8-bit or floating-point, 1-channel or 3-channel image.</li><li>Parameter: <code>dst</code>: Destination image of the same size and type as src .</li><li>Parameter: <code>d</code>: Diameter of each pixel neighborhood that is used during filtering. If it is non-positive, it is computed from sigmaSpace.</li><li>Parameter: <code>sigma_color</code>: Filter sigma in the color space. A larger value of the parameter means that farther colors within the pixel neighborhood (see sigmaSpace) will be mixed together, resulting in larger areas of semi-equal color.</li><li>Parameter: <code>sigma_space</code>: Filter sigma in the coordinate space. A larger value of the parameter means that farther pixels will influence each other as long as their colors are close enough (see sigmaColor ). When d\&gt;0, it specifies the neighborhood size regardless of sigmaSpace. Otherwise, d is proportional to sigmaSpace.</li><li>Parameter: <code>border_type</code>: border mode used to extrapolate pixels outside of the image, see #BorderTypes</li></ul></dd></dl><dl><dt class="spec value" id="val-box_filter"><a href="#val-box_filter" class="anchor"></a><code><span class="keyword">val</span> box_filter : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;anchor:<a href="index.html#type-point2i">point2i</a></span> <span>&#45;&gt;</span> <span>?&#8288;normalize:bool</span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-size2i">size2i</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>box_filter ?dst ?anchor ?normalize ?border_type src ddepth ksize</code></p><p>Blurs an image using the box filter.</p><p>The function smooths an image using the kernel:</p><p><code> \texttt{K} =  \alpha \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \hdotsfor{6} \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1 \end{bmatrix} </code></p><p>where</p><p><code> \alpha = \begin{cases} \frac{1}{\texttt{ksize.width*ksize.height}} &amp; \texttt{when } \texttt{normalize=true}  \\1 &amp; \texttt{otherwise}\end{cases} </code></p><p>Unnormalized box filter is useful for computing various integral characteristics over each pixel neighborhood, such as covariance matrices of image derivatives (used in dense optical flow algorithms, and so on). If you need to compute pixel sums over variable-size windows, use #integral.</p><ul><li>Parameter: <code>src</code>: input image.</li><li>Parameter: <code>dst</code>: output image of the same size and type as src.</li><li>Parameter: <code>ddepth</code>: the output image depth (-1 to use src.depth()).</li><li>Parameter: <code>ksize</code>: blurring kernel size.</li><li>Parameter: <code>anchor</code>: anchor point; default value Point(-1,-1) means that the anchor is at the kernel center.</li><li>Parameter: <code>normalize</code>: flag, specifying whether the kernel is normalized by its area or not.</li><li>Parameter: <code>border_type</code>: border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported. See also: blur, bilateralFilter, GaussianBlur, medianBlur, integral</li></ul></dd></dl><dl><dt class="spec value" id="val-sqr_box_filter"><a href="#val-sqr_box_filter" class="anchor"></a><code><span class="keyword">val</span> sqr_box_filter : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;anchor:<a href="index.html#type-point2i">point2i</a></span> <span>&#45;&gt;</span> <span>?&#8288;normalize:bool</span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-size2i">size2i</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>sqr_box_filter ?dst ?anchor ?normalize ?border_type src ddepth ksize</code></p><p>Calculates the normalized sum of squares of the pixel values overlapping the filter.</p><p>For every pixel <code>  (x, y)  </code> in the source image, the function calculates the sum of squares of those neighboring pixel values which overlap the filter placed over the pixel <code>  (x, y)  </code>.</p><p>The unnormalized square box filter can be useful in computing local image statistics such as the the local variance and standard deviation around the neighborhood of a pixel.</p><ul><li>Parameter: <code>src</code>: input image</li><li>Parameter: <code>dst</code>: output image of the same size and type as _src</li><li>Parameter: <code>ddepth</code>: the output image depth (-1 to use src.depth())</li><li>Parameter: <code>ksize</code>: kernel size</li><li>Parameter: <code>anchor</code>: kernel anchor point. The default value of Point(-1, -1) denotes that the anchor is at the kernel center.</li><li>Parameter: <code>normalize</code>: flag, specifying whether the kernel is to be normalized by it's area or not.</li><li>Parameter: <code>border_type</code>: border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported. See also: boxFilter</li></ul></dd></dl><dl><dt class="spec value" id="val-blur"><a href="#val-blur" class="anchor"></a><code><span class="keyword">val</span> blur : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;anchor:<a href="index.html#type-point2i">point2i</a></span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-size2i">size2i</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>blur ?dst ?anchor ?border_type src ksize</code></p><p>Blurs an image using the normalized box filter.</p><p>The function smooths an image using the kernel:</p><p><code> \texttt{K} =  \frac{1}{\texttt{ksize.width*ksize.height}} \begin{bmatrix} 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \hdotsfor{6} \\ 1 &amp; 1 &amp; 1 &amp;  \cdots &amp; 1 &amp; 1  \\ \end{bmatrix} </code></p><p>The call <code>blur(src, dst, ksize, anchor, borderType)</code> is equivalent to `boxFilter(src, dst, src.type(), ksize, anchor, true, borderType)`.</p><ul><li>Parameter: <code>src</code>: input image; it can have any number of channels, which are processed independently, but the depth should be CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</li><li>Parameter: <code>dst</code>: output image of the same size and type as src.</li><li>Parameter: <code>ksize</code>: blurring kernel size.</li><li>Parameter: <code>anchor</code>: anchor point; default value Point(-1,-1) means that the anchor is at the kernel center.</li><li>Parameter: <code>border_type</code>: border mode used to extrapolate pixels outside of the image, see #BorderTypes. #BORDER_WRAP is not supported. See also: boxFilter, bilateralFilter, GaussianBlur, medianBlur</li></ul></dd></dl><dl><dt class="spec value" id="val-filter2_d"><a href="#val-filter2_d" class="anchor"></a><code><span class="keyword">val</span> filter2_d : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;anchor:<a href="index.html#type-point2i">point2i</a></span> <span>&#45;&gt;</span> <span>?&#8288;delta:float</span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>filter2_d ?dst ?anchor ?delta ?border_type src ddepth kernel</code></p><p>Convolves an image with the kernel.</p><p>The function applies an arbitrary linear filter to an image. In-place operation is supported. When the aperture is partially outside the image, the function interpolates outlier pixel values according to the specified border mode.</p><p>The function does actually compute correlation, not the convolution:</p><p><code> \texttt{dst} (x,y) =  \sum _{ \substack{0\leq x' &lt; \texttt{kernel.cols}\\{0\leq y' &lt; \texttt{kernel.rows}}}}  \texttt{kernel} (x',y')* \texttt{src} (x+x'- \texttt{anchor.x} ,y+y'- \texttt{anchor.y} ) </code></p><p>That is, the kernel is not mirrored around the anchor point. If you need a real convolution, flip the kernel using #flip and set the new anchor to `(kernel.cols - anchor.x - 1, kernel.rows - anchor.y - 1)`.</p><p>The function uses the DFT-based algorithm in case of sufficiently large kernels (~<code>11 x 11</code> or larger) and the direct algorithm for small kernels.</p><ul><li>Parameter: <code>src</code>: input image.</li><li>Parameter: <code>dst</code>: output image of the same size and the same number of channels as src.</li><li>Parameter: <code>ddepth</code>: desired depth of the destination image, see filter_depths &quot;combinations&quot;</li><li>Parameter: <code>kernel</code>: convolution kernel (or rather a correlation kernel), a single-channel floating point matrix; if you want to apply different kernels to different channels, split the image into separate color planes using split and process them individually.</li><li>Parameter: <code>anchor</code>: anchor of the kernel that indicates the relative position of a filtered point within the kernel; the anchor should lie within the kernel; default value (-1,-1) means that the anchor is at the kernel center.</li><li>Parameter: <code>delta</code>: optional value added to the filtered pixels before storing them in dst.</li><li>Parameter: <code>border_type</code>: pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. See also: sepFilter2D, dft, matchTemplate</li></ul></dd></dl><dl><dt class="spec value" id="val-sep_filter2_d"><a href="#val-sep_filter2_d" class="anchor"></a><code><span class="keyword">val</span> sep_filter2_d : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;anchor:<a href="index.html#type-point2i">point2i</a></span> <span>&#45;&gt;</span> <span>?&#8288;delta:float</span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>sep_filter2_d ?dst ?anchor ?delta ?border_type src ddepth kernel_x kernel_y</code></p><p>Applies a separable linear filter to an image.</p><p>The function applies a separable linear filter to the image. That is, first, every row of src is filtered with the 1D kernel kernelX. Then, every column of the result is filtered with the 1D kernel kernelY. The final result shifted by delta is stored in dst .</p><ul><li>Parameter: <code>src</code>: Source image.</li><li>Parameter: <code>dst</code>: Destination image of the same size and the same number of channels as src .</li><li>Parameter: <code>ddepth</code>: Destination image depth, see filter_depths &quot;combinations&quot;</li><li>Parameter: <code>kernel_x</code>: Coefficients for filtering each row.</li><li>Parameter: <code>kernel_y</code>: Coefficients for filtering each column.</li><li>Parameter: <code>anchor</code>: Anchor position within the kernel. The default value <code> (-1,-1) </code> means that the anchor is at the kernel center.</li><li>Parameter: <code>delta</code>: Value added to the filtered results before storing them.</li><li>Parameter: <code>border_type</code>: Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. See also: filter2D, Sobel, GaussianBlur, boxFilter, blur</li></ul></dd></dl><dl><dt class="spec value" id="val-sobel"><a href="#val-sobel" class="anchor"></a><code><span class="keyword">val</span> sobel : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;ksize:int</span> <span>&#45;&gt;</span> <span>?&#8288;scale:float</span> <span>&#45;&gt;</span> <span>?&#8288;delta:float</span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>sobel ?dst ?ksize ?scale ?delta ?border_type src ddepth dx dy</code></p><p>Calculates the first, second, third, or mixed image derivatives using an extended Sobel operator.</p><p>In all cases except one, the <code> \texttt{ksize} \times \texttt{ksize} </code> separable kernel is used to calculate the derivative. When <code> \texttt{ksize = 1} </code>, the <code> 3 \times 1 </code> or <code> 1 \times 3 </code> kernel is used (that is, no Gaussian smoothing is done). <code>ksize = 1</code> can only be used for the first or the second x- or y- derivatives.</p><p>There is also the special value <code>ksize = #FILTER_SCHARR (-1)</code> that corresponds to the <code> 3\times3 </code> Scharr filter that may give more accurate results than the <code> 3\times3 </code> Sobel. The Scharr aperture is</p><p><code> \vecthreethree{-3}{0}{3}{-10}{0}{10}{-3}{0}{3} </code></p><p>for the x-derivative, or transposed for the y-derivative.</p><p>The function calculates an image derivative by convolving the image with the appropriate kernel:</p><p><code> \texttt{dst} =  \frac{\partial^{xorder+yorder} \texttt{src}}{\partial x^{xorder} \partial y^{yorder}} </code></p><p>The Sobel operators combine Gaussian smoothing and differentiation, so the result is more or less resistant to the noise. Most often, the function is called with ( xorder = 1, yorder = 0, ksize = 3) or ( xorder = 0, yorder = 1, ksize = 3) to calculate the first x- or y- image derivative. The first case corresponds to a kernel of:</p><p><code> \vecthreethree{-1}{0}{1}{-2}{0}{2}{-1}{0}{1} </code></p><p>The second case corresponds to a kernel of:</p><p><code> \vecthreethree{-1}{-2}{-1}{0}{0}{0}{1}{2}{1} </code></p><ul><li>Parameter: <code>src</code>: input image.</li><li>Parameter: <code>dst</code>: output image of the same size and the same number of channels as src .</li><li>Parameter: <code>ddepth</code>: output image depth, see filter_depths &quot;combinations&quot;; in the case of 8-bit input images it will result in truncated derivatives.</li><li>Parameter: <code>dx</code>: order of the derivative x.</li><li>Parameter: <code>dy</code>: order of the derivative y.</li><li>Parameter: <code>ksize</code>: size of the extended Sobel kernel; it must be 1, 3, 5, or 7.</li><li>Parameter: <code>scale</code>: optional scale factor for the computed derivative values; by default, no scaling is applied (see #getDerivKernels for details).</li><li>Parameter: <code>delta</code>: optional delta value that is added to the results prior to storing them in dst.</li><li>Parameter: <code>border_type</code>: pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. See also: Scharr, Laplacian, sepFilter2D, filter2D, GaussianBlur, cartToPolar</li></ul></dd></dl><dl><dt class="spec value" id="val-spatial_gradient"><a href="#val-spatial_gradient" class="anchor"></a><code><span class="keyword">val</span> spatial_gradient : <span>?&#8288;dx:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;dy:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;ksize:int</span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>spatial_gradient ?dx ?dy ?ksize ?border_type src</code></p><p>Calculates the first order image derivative in both x and y using a Sobel operator</p><p>Equivalent to calling:</p><pre><code class="ml">Sobel( src, dx, CV_16SC1, 1, 0, 3 );
Sobel( src, dy, CV_16SC1, 0, 1, 3 );</code></pre><ul><li>Parameter: <code>src</code>: input image.</li><li>Parameter: <code>dx</code>: output image with first-order derivative in x.</li><li>Parameter: <code>dy</code>: output image with first-order derivative in y.</li><li>Parameter: <code>ksize</code>: size of Sobel kernel. It must be 3.</li><li>Parameter: <code>border_type</code>: pixel extrapolation method, see #BorderTypes. Only #BORDER_DEFAULT=#BORDER_REFLECT_101 and #BORDER_REPLICATE are supported.</li></ul><p>See also: Sobel</p></dd></dl><dl><dt class="spec value" id="val-scharr"><a href="#val-scharr" class="anchor"></a><code><span class="keyword">val</span> scharr : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;scale:float</span> <span>&#45;&gt;</span> <span>?&#8288;delta:float</span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>scharr ?dst ?scale ?delta ?border_type src ddepth dx dy</code></p><p>Calculates the first x- or y- image derivative using Scharr operator.</p><p>The function computes the first x- or y- spatial image derivative using the Scharr operator. The call</p><p><code> \texttt{Scharr(src, dst, ddepth, dx, dy, scale, delta, borderType)} </code></p><p>is equivalent to</p><p><code> \texttt{Sobel(src, dst, ddepth, dx, dy, FILTER_SCHARR, scale, delta, borderType)} . </code></p><ul><li>Parameter: <code>src</code>: input image.</li><li>Parameter: <code>dst</code>: output image of the same size and the same number of channels as src.</li><li>Parameter: <code>ddepth</code>: output image depth, see filter_depths &quot;combinations&quot;</li><li>Parameter: <code>dx</code>: order of the derivative x.</li><li>Parameter: <code>dy</code>: order of the derivative y.</li><li>Parameter: <code>scale</code>: optional scale factor for the computed derivative values; by default, no scaling is applied (see #getDerivKernels for details).</li><li>Parameter: <code>delta</code>: optional delta value that is added to the results prior to storing them in dst.</li><li>Parameter: <code>border_type</code>: pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. See also: cartToPolar</li></ul></dd></dl><dl><dt class="spec value" id="val-laplacian"><a href="#val-laplacian" class="anchor"></a><code><span class="keyword">val</span> laplacian : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;ksize:int</span> <span>&#45;&gt;</span> <span>?&#8288;scale:float</span> <span>&#45;&gt;</span> <span>?&#8288;delta:float</span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>laplacian ?dst ?ksize ?scale ?delta ?border_type src ddepth</code></p><p>Calculates the Laplacian of an image.</p><p>The function calculates the Laplacian of the source image by adding up the second x and y derivatives calculated using the Sobel operator:</p><p><code> \texttt{dst} =  \Delta \texttt{src} =  \frac{\partial^2 \texttt{src}}{\partial x^2} +  \frac{\partial^2 \texttt{src}}{\partial y^2} </code></p><p>This is done when <code>ksize &gt; 1</code>. When <code>ksize == 1</code>, the Laplacian is computed by filtering the image with the following <code> 3 \times 3 </code> aperture:</p><p><code> \vecthreethree {0}{1}{0}{1}{-4}{1}{0}{1}{0} </code></p><ul><li>Parameter: <code>src</code>: Source image.</li><li>Parameter: <code>dst</code>: Destination image of the same size and the same number of channels as src .</li><li>Parameter: <code>ddepth</code>: Desired depth of the destination image.</li><li>Parameter: <code>ksize</code>: Aperture size used to compute the second-derivative filters. See #getDerivKernels for details. The size must be positive and odd.</li><li>Parameter: <code>scale</code>: Optional scale factor for the computed Laplacian values. By default, no scaling is applied. See #getDerivKernels for details.</li><li>Parameter: <code>delta</code>: Optional delta value that is added to the results prior to storing them in dst .</li><li>Parameter: <code>border_type</code>: Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported. See also: Sobel, Scharr</li></ul></dd></dl><dl><dt class="spec value" id="val-canny1"><a href="#val-canny1" class="anchor"></a><code><span class="keyword">val</span> canny1 : <span>?&#8288;edges:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;aperture_size:int</span> <span>&#45;&gt;</span> <span>?&#8288;l2gradient:bool</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>canny1 ?edges ?aperture_size ?l2gradient image threshold1 threshold2</code></p><p>Finds edges in an image using the Canny algorithm Canny86 .</p><p>The function finds edges in the input image and marks them in the output map edges using the Canny algorithm. The smallest value between threshold1 and threshold2 is used for edge linking. The largest value is used to find initial segments of strong edges. See &lt;http://en.wikipedia.org/wiki/Canny_edge_detector&gt;</p><ul><li>Parameter: <code>image</code>: 8-bit input image.</li><li>Parameter: <code>edges</code>: output edge map; single channels 8-bit image, which has the same size as image .</li><li>Parameter: <code>threshold1</code>: first threshold for the hysteresis procedure.</li><li>Parameter: <code>threshold2</code>: second threshold for the hysteresis procedure.</li><li>Parameter: <code>aperture_size</code>: aperture size for the Sobel operator.</li><li>Parameter: <code>l2gradient</code>: a flag, indicating whether a more accurate <code> L_2 </code> norm <code> =\sqrt{(dI/dx)^2 + (dI/dy)^2} </code> should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default <code> L_1 </code> norm <code> =|dI/dx|+|dI/dy| </code> is enough ( L2gradient=false ).</li></ul></dd></dl><dl><dt class="spec value" id="val-canny2"><a href="#val-canny2" class="anchor"></a><code><span class="keyword">val</span> canny2 : <span>?&#8288;edges:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;l2gradient:bool</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>canny2 ?edges ?l2gradient dx dy threshold1 threshold2</code></p><p>\overload</p><p>Finds edges in an image using the Canny algorithm with custom image gradient.</p><ul><li>Parameter: <code>dx</code>: 16-bit x derivative of input image (CV_16SC1 or CV_16SC3).</li><li>Parameter: <code>dy</code>: 16-bit y derivative of input image (same type as dx).</li><li>Parameter: <code>edges</code>: output edge map; single channels 8-bit image, which has the same size as image .</li><li>Parameter: <code>threshold1</code>: first threshold for the hysteresis procedure.</li><li>Parameter: <code>threshold2</code>: second threshold for the hysteresis procedure.</li><li>Parameter: <code>l2gradient</code>: a flag, indicating whether a more accurate <code> L_2 </code> norm <code> =\sqrt{(dI/dx)^2 + (dI/dy)^2} </code> should be used to calculate the image gradient magnitude ( L2gradient=true ), or whether the default <code> L_1 </code> norm <code> =|dI/dx|+|dI/dy| </code> is enough ( L2gradient=false ).</li></ul></dd></dl><dl><dt class="spec value" id="val-corner_min_eigen_val"><a href="#val-corner_min_eigen_val" class="anchor"></a><code><span class="keyword">val</span> corner_min_eigen_val : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;ksize:int</span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>corner_min_eigen_val ?dst ?ksize ?border_type src block_size</code></p><p>Calculates the minimal eigenvalue of gradient matrices for corner detection.</p><p>The function is similar to cornerEigenValsAndVecs but it calculates and stores only the minimal eigenvalue of the covariance matrix of derivatives, that is, <code> \min(\lambda_1, \lambda_2) </code> in terms of the formulae in the cornerEigenValsAndVecs description.</p><ul><li>Parameter: <code>src</code>: Input single-channel 8-bit or floating-point image.</li><li>Parameter: <code>dst</code>: Image to store the minimal eigenvalues. It has the type CV_32FC1 and the same size as src .</li><li>Parameter: <code>block_size</code>: Neighborhood size (see the details on #cornerEigenValsAndVecs ).</li><li>Parameter: <code>ksize</code>: Aperture parameter for the Sobel operator.</li><li>Parameter: <code>border_type</code>: Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.</li></ul></dd></dl><dl><dt class="spec value" id="val-corner_harris"><a href="#val-corner_harris" class="anchor"></a><code><span class="keyword">val</span> corner_harris : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>corner_harris ?dst ?border_type src block_size ksize k</code></p><p>Harris corner detector.</p><p>The function runs the Harris corner detector on the image. Similarly to cornerMinEigenVal and cornerEigenValsAndVecs , for each pixel <code> (x, y) </code> it calculates a <code> 2\times2 </code> gradient covariance matrix <code> M^{(x,y)} </code> over a <code> \texttt{blockSize} \times \texttt{blockSize} </code> neighborhood. Then, it computes the following characteristic:</p><p><code> \texttt{dst} (x,y) =  \mathrm{det} M^{(x,y)} - k  \cdot \left ( \mathrm{tr} M^{(x,y)} \right )^2 </code></p><p>Corners in the image can be found as the local maxima of this response map.</p><ul><li>Parameter: <code>src</code>: Input single-channel 8-bit or floating-point image.</li><li>Parameter: <code>dst</code>: Image to store the Harris detector responses. It has the type CV_32FC1 and the same size as src .</li><li>Parameter: <code>block_size</code>: Neighborhood size (see the details on #cornerEigenValsAndVecs ).</li><li>Parameter: <code>ksize</code>: Aperture parameter for the Sobel operator.</li><li>Parameter: <code>k</code>: Harris detector free parameter. See the formula above.</li><li>Parameter: <code>border_type</code>: Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.</li></ul></dd></dl><dl><dt class="spec value" id="val-corner_eigen_vals_and_vecs"><a href="#val-corner_eigen_vals_and_vecs" class="anchor"></a><code><span class="keyword">val</span> corner_eigen_vals_and_vecs : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>corner_eigen_vals_and_vecs ?dst ?border_type src block_size ksize</code></p><p>Calculates eigenvalues and eigenvectors of image blocks for corner detection.</p><p>For every pixel <code> p </code> , the function cornerEigenValsAndVecs considers a blockSize <code> \times </code> blockSize neighborhood <code> S(p) </code> . It calculates the covariation matrix of derivatives over the neighborhood as:</p><p><code> M =  \begin{bmatrix} \sum _{S(p)}(dI/dx)^2 &amp;  \sum _{S(p)}dI/dx dI/dy  \\ \sum _{S(p)}dI/dx dI/dy &amp;  \sum _{S(p)}(dI/dy)^2 \end{bmatrix} </code></p><p>where the derivatives are computed using the Sobel operator.</p><p>After that, it finds eigenvectors and eigenvalues of <code> M </code> and stores them in the destination image as <code> (\lambda_1, \lambda_2, x_1, y_1, x_2, y_2) </code> where</p><ul><li><code> \lambda_1, \lambda_2 </code> are the non-sorted eigenvalues of <code> M </code></li><li><code> x_1, y_1 </code> are the eigenvectors corresponding to <code> \lambda_1 </code></li><li><code> x_2, y_2 </code> are the eigenvectors corresponding to <code> \lambda_2 </code></li></ul><p>The output of the function can be used for robust edge or corner detection.</p><ul><li>Parameter: <code>src</code>: Input single-channel 8-bit or floating-point image.</li><li>Parameter: <code>dst</code>: Image to store the results. It has the same size as src and the type CV_32FC(6) .</li><li>Parameter: <code>block_size</code>: Neighborhood size (see details below).</li><li>Parameter: <code>ksize</code>: Aperture parameter for the Sobel operator.</li><li>Parameter: <code>border_type</code>: Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.</li></ul><p>See also: cornerMinEigenVal, cornerHarris, preCornerDetect</p></dd></dl><dl><dt class="spec value" id="val-pre_corner_detect"><a href="#val-pre_corner_detect" class="anchor"></a><code><span class="keyword">val</span> pre_corner_detect : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>pre_corner_detect ?dst ?border_type src ksize</code></p><p>Calculates a feature map for corner detection.</p><p>The function calculates the complex spatial derivative-based function of the source image</p><p><code> \texttt{dst} = (D_x  \texttt{src} )^2  \cdot D_{yy}  \texttt{src} + (D_y  \texttt{src} )^2  \cdot D_{xx}  \texttt{src} - 2 D_x  \texttt{src} \cdot D_y  \texttt{src} \cdot D_{xy}  \texttt{src} </code></p><p>where <code> D_x </code>,<code> D_y </code> are the first image derivatives, <code> D_{xx} </code>,<code> D_{yy} </code> are the second image derivatives, and <code> D_{xy} </code> is the mixed derivative.</p><p>The corners can be found as local maximums of the functions, as shown below:</p><pre><code class="ml">Mat corners, dilated_corners;
preCornerDetect(image, corners, 3);
// dilation with 3x3 rectangular structuring element
dilate(corners, dilated_corners, Mat(), 1);
Mat corner_mask = corners == dilated_corners;</code></pre><ul><li>Parameter: <code>src</code>: Source single-channel 8-bit of floating-point image.</li><li>Parameter: <code>dst</code>: Output image that has the type CV_32F and the same size as src .</li><li>Parameter: <code>ksize</code>: %Aperture size of the Sobel .</li><li>Parameter: <code>border_type</code>: Pixel extrapolation method. See #BorderTypes. #BORDER_WRAP is not supported.</li></ul></dd></dl><dl><dt class="spec value" id="val-good_features_to_track1"><a href="#val-good_features_to_track1" class="anchor"></a><code><span class="keyword">val</span> good_features_to_track1 : <span>?&#8288;corners:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;block_size:int</span> <span>&#45;&gt;</span> <span>?&#8288;use_harris_detector:bool</span> <span>&#45;&gt;</span> <span>?&#8288;k:float</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>good_features_to_track1 ?corners ?mask ?block_size ?use_harris_detector ?k image max_corners quality_level min_distance</code></p><p>Determines strong corners on an image.</p><p>The function finds the most prominent corners in the image or in the specified image region, as described in Shi94</p><ul><li>Function calculates the corner quality measure at every source image pixel using the #cornerMinEigenVal or #cornerHarris .</li><li>Function performs a non-maximum suppression (the local maximums in *3 x 3* neighborhood are retained).</li><li>The corners with the minimal eigenvalue less than <code> \texttt{qualityLevel} \cdot \max_{x,y} qualityMeasureMap(x,y) </code> are rejected.</li><li>The remaining corners are sorted by the quality measure in the descending order.</li><li>Function throws away each corner for which there is a stronger corner at a distance less than maxDistance.</li></ul><p>The function can be used to initialize a point-based tracker of an object.</p><p>Note: If the function is called with different values A and B of the parameter qualityLevel , and A \&gt; B, the vector of returned corners with qualityLevel=A will be the prefix of the output vector with qualityLevel=B .</p><ul><li>Parameter: <code>image</code>: Input 8-bit or floating-point 32-bit, single-channel image.</li><li>Parameter: <code>corners</code>: Output vector of detected corners.</li><li>Parameter: <code>max_corners</code>: Maximum number of corners to return. If there are more corners than are found, the strongest of them is returned. <code>maxCorners &lt;= 0</code> implies that no limit on the maximum is set and all detected corners are returned.</li><li>Parameter: <code>quality_level</code>: Parameter characterizing the minimal accepted quality of image corners. The parameter value is multiplied by the best corner quality measure, which is the minimal eigenvalue (see #cornerMinEigenVal ) or the Harris function response (see #cornerHarris ). The corners with the quality measure less than the product are rejected. For example, if the best corner has the quality measure = 1500, and the qualityLevel=0.01 , then all the corners with the quality measure less than 15 are rejected.</li><li>Parameter: <code>min_distance</code>: Minimum possible Euclidean distance between the returned corners.</li><li>Parameter: <code>mask</code>: Optional region of interest. If the image is not empty (it needs to have the type CV_8UC1 and the same size as image ), it specifies the region in which the corners are detected.</li><li>Parameter: <code>block_size</code>: Size of an average block for computing a derivative covariation matrix over each pixel neighborhood. See cornerEigenValsAndVecs .</li><li>Parameter: <code>use_harris_detector</code>: Parameter indicating whether to use a Harris detector (see #cornerHarris) or #cornerMinEigenVal.</li><li>Parameter: <code>k</code>: Free parameter of the Harris detector.</li></ul><p>See also: cornerMinEigenVal, cornerHarris, calcOpticalFlowPyrLK, estimateRigidTransform,</p></dd></dl><dl><dt class="spec value" id="val-good_features_to_track2"><a href="#val-good_features_to_track2" class="anchor"></a><code><span class="keyword">val</span> good_features_to_track2 : <span>?&#8288;corners:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;use_harris_detector:bool</span> <span>&#45;&gt;</span> <span>?&#8288;k:float</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>good_features_to_track2 ?corners ?use_harris_detector ?k image max_corners quality_level min_distance mask block_size gradient_size</code></p></dd></dl><dl><dt class="spec value" id="val-hough_lines"><a href="#val-hough_lines" class="anchor"></a><code><span class="keyword">val</span> hough_lines : <span>?&#8288;lines:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;srn:float</span> <span>&#45;&gt;</span> <span>?&#8288;stn:float</span> <span>&#45;&gt;</span> <span>?&#8288;min_theta:float</span> <span>&#45;&gt;</span> <span>?&#8288;max_theta:float</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>hough_lines ?lines ?srn ?stn ?min_theta ?max_theta image rho theta threshold</code></p><p>Finds lines in a binary image using the standard Hough transform.</p><p>The function implements the standard or standard multi-scale Hough transform algorithm for line detection. See &lt;http://homepages.inf.ed.ac.uk/rbf/HIPR2/hough.htm&gt; for a good explanation of Hough transform.</p><ul><li>Parameter: <code>image</code>: 8-bit, single-channel binary source image. The image may be modified by the function.</li><li>Parameter: <code>lines</code>: Output vector of lines. Each line is represented by a 2 or 3 element vector <code> (\rho, \theta) </code> or <code> (\rho, \theta, \textrm{votes}) </code> . <code> \rho </code> is the distance from the coordinate origin <code> (0,0) </code> (top-left corner of the image). <code> \theta </code> is the line rotation angle in radians ( <code> 0 \sim \textrm{vertical line}, \pi/2 \sim \textrm{horizontal line} </code> ). <code> \textrm{votes} </code> is the value of accumulator.</li><li>Parameter: <code>rho</code>: Distance resolution of the accumulator in pixels.</li><li>Parameter: <code>theta</code>: Angle resolution of the accumulator in radians.</li><li>Parameter: <code>threshold</code>: Accumulator threshold parameter. Only those lines are returned that get enough votes ( <code> &gt;\texttt{threshold} </code> ).</li><li>Parameter: <code>srn</code>: For the multi-scale Hough transform, it is a divisor for the distance resolution rho . The coarse accumulator distance resolution is rho and the accurate accumulator resolution is rho/srn . If both srn=0 and stn=0 , the classical Hough transform is used. Otherwise, both these parameters should be positive.</li><li>Parameter: <code>stn</code>: For the multi-scale Hough transform, it is a divisor for the distance resolution theta.</li><li>Parameter: <code>min_theta</code>: For standard and multi-scale Hough transform, minimum angle to check for lines. Must fall between 0 and max_theta.</li><li>Parameter: <code>max_theta</code>: For standard and multi-scale Hough transform, maximum angle to check for lines. Must fall between min_theta and CV_PI.</li></ul></dd></dl><dl><dt class="spec value" id="val-hough_lines_p"><a href="#val-hough_lines_p" class="anchor"></a><code><span class="keyword">val</span> hough_lines_p : <span>?&#8288;lines:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;min_line_length:float</span> <span>&#45;&gt;</span> <span>?&#8288;max_line_gap:float</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>hough_lines_p ?lines ?min_line_length ?max_line_gap image rho theta threshold</code></p><p>Finds line segments in a binary image using the probabilistic Hough transform.</p><p>The function implements the probabilistic Hough transform algorithm for line detection, described in Matas00</p><p>See the line detection example below: Include: snippets/imgproc_HoughLinesP.cpp This is a sample picture the function parameters have been tuned for:</p><p>!<code>image</code>(pics/building.jpg)</p><p>And this is the output of the above program in case of the probabilistic Hough transform:</p><p>!<code>image</code>(pics/houghp.png)</p><ul><li>Parameter: <code>image</code>: 8-bit, single-channel binary source image. The image may be modified by the function.</li><li>Parameter: <code>lines</code>: Output vector of lines. Each line is represented by a 4-element vector <code> (x_1, y_1, x_2, y_2) </code> , where <code> (x_1,y_1) </code> and <code> (x_2, y_2) </code> are the ending points of each detected line segment.</li><li>Parameter: <code>rho</code>: Distance resolution of the accumulator in pixels.</li><li>Parameter: <code>theta</code>: Angle resolution of the accumulator in radians.</li><li>Parameter: <code>threshold</code>: Accumulator threshold parameter. Only those lines are returned that get enough votes ( <code> &gt;\texttt{threshold} </code> ).</li><li>Parameter: <code>min_line_length</code>: Minimum line length. Line segments shorter than that are rejected.</li><li>Parameter: <code>max_line_gap</code>: Maximum allowed gap between points on the same line to link them.</li></ul><p>See also: LineSegmentDetector</p></dd></dl><dl><dt class="spec value" id="val-hough_lines_point_set"><a href="#val-hough_lines_point_set" class="anchor"></a><code><span class="keyword">val</span> hough_lines_point_set : <span>?&#8288;_lines:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>hough_lines_point_set ?_lines _point lines_max threshold min_rho max_rho rho_step min_theta max_theta theta_step</code></p><p>Finds lines in a set of points using the standard Hough transform.</p><p>The function finds lines in a set of points using a modification of the Hough transform. Include: snippets/imgproc_HoughLinesPointSet.cpp</p><ul><li>Parameter: <code>_point</code>: Input vector of points. Each vector must be encoded as a Point vector <code> (x,y) </code>. Type must be CV_32FC2 or CV_32SC2.</li><li>Parameter: <code>_lines</code>: Output vector of found lines. Each vector is encoded as a vector&lt;Vec3d&gt; <code> (votes, rho, theta) </code>. The larger the value of 'votes', the higher the reliability of the Hough line.</li><li>Parameter: <code>lines_max</code>: Max count of hough lines.</li><li>Parameter: <code>threshold</code>: Accumulator threshold parameter. Only those lines are returned that get enough votes ( <code> &gt;\texttt{threshold} </code> )</li><li>Parameter: <code>min_rho</code>: Minimum Distance value of the accumulator in pixels.</li><li>Parameter: <code>max_rho</code>: Maximum Distance value of the accumulator in pixels.</li><li>Parameter: <code>rho_step</code>: Distance resolution of the accumulator in pixels.</li><li>Parameter: <code>min_theta</code>: Minimum angle value of the accumulator in radians.</li><li>Parameter: <code>max_theta</code>: Maximum angle value of the accumulator in radians.</li><li>Parameter: <code>theta_step</code>: Angle resolution of the accumulator in radians.</li></ul></dd></dl><dl><dt class="spec value" id="val-hough_circles"><a href="#val-hough_circles" class="anchor"></a><code><span class="keyword">val</span> hough_circles : <span>?&#8288;circles:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;param1:float</span> <span>&#45;&gt;</span> <span>?&#8288;param2:float</span> <span>&#45;&gt;</span> <span>?&#8288;min_radius:int</span> <span>&#45;&gt;</span> <span>?&#8288;max_radius:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>hough_circles ?circles ?param1 ?param2 ?min_radius ?max_radius image cv_method dp min_dist</code></p><p>Finds circles in a grayscale image using the Hough transform.</p><p>The function finds circles in a grayscale image using a modification of the Hough transform.</p><p>Example: : Include: snippets/imgproc_HoughLinesCircles.cpp</p><p>Note: Usually the function detects the centers of circles well. However, it may fail to find correct radii. You can assist to the function by specifying the radius range ( minRadius and maxRadius ) if you know it. Or, in the case of #HOUGH_GRADIENT method you may set maxRadius to a negative number to return centers only without radius search, and find the correct radius using an additional procedure.</p><p>It also helps to smooth image a bit unless it's already soft. For example, GaussianBlur() with 7x7 kernel and 1.5x1.5 sigma or similar blurring may help.</p><ul><li>Parameter: <code>image</code>: 8-bit, single-channel, grayscale input image.</li><li>Parameter: <code>circles</code>: Output vector of found circles. Each vector is encoded as 3 or 4 element floating-point vector <code> (x, y, radius) </code> or <code> (x, y, radius, votes) </code> .</li><li>Parameter: <code>cv_method</code>: Detection method, see #HoughModes. The available methods are #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT.</li><li>Parameter: <code>dp</code>: Inverse ratio of the accumulator resolution to the image resolution. For example, if dp=1 , the accumulator has the same resolution as the input image. If dp=2 , the accumulator has half as big width and height. For #HOUGH_GRADIENT_ALT the recommended value is dp=1.5, unless some small very circles need to be detected.</li><li>Parameter: <code>min_dist</code>: Minimum distance between the centers of the detected circles. If the parameter is too small, multiple neighbor circles may be falsely detected in addition to a true one. If it is too large, some circles may be missed.</li><li>Parameter: <code>param1</code>: First method-specific parameter. In case of #HOUGH_GRADIENT and #HOUGH_GRADIENT_ALT, it is the higher threshold of the two passed to the Canny edge detector (the lower one is twice smaller). Note that #HOUGH_GRADIENT_ALT uses #Scharr algorithm to compute image derivatives, so the threshold value shough normally be higher, such as 300 or normally exposed and contrasty images.</li><li>Parameter: <code>param2</code>: Second method-specific parameter. In case of #HOUGH_GRADIENT, it is the accumulator threshold for the circle centers at the detection stage. The smaller it is, the more false circles may be detected. Circles, corresponding to the larger accumulator values, will be returned first. In the case of #HOUGH_GRADIENT_ALT algorithm, this is the circle &quot;perfectness&quot; measure. The closer it to 1, the better shaped circles algorithm selects. In most cases 0.9 should be fine. If you want get better detection of small circles, you may decrease it to 0.85, 0.8 or even less. But then also try to limit the search range <code>minRadius, maxRadius</code> to avoid many false circles.</li><li>Parameter: <code>min_radius</code>: Minimum circle radius.</li><li>Parameter: <code>max_radius</code>: Maximum circle radius. If &lt;= 0, uses the maximum image dimension. If &lt; 0, #HOUGH_GRADIENT returns centers without finding the radius. #HOUGH_GRADIENT_ALT always computes circle radiuses.</li></ul><p>See also: fitEllipse, minEnclosingCircle</p></dd></dl><dl><dt class="spec value" id="val-erode"><a href="#val-erode" class="anchor"></a><code><span class="keyword">val</span> erode : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;anchor:<a href="index.html#type-point2i">point2i</a></span> <span>&#45;&gt;</span> <span>?&#8288;iterations:int</span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;border_value:<a href="Scalar/index.html#type-t">Scalar.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>erode ?dst ?anchor ?iterations ?border_type ?border_value src kernel</code></p><p>Erodes an image by using a specific structuring element.</p><p>The function erodes the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the minimum is taken:</p><p><code>  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y') </code></p><p>The function supports the in-place mode. Erosion can be applied several ( iterations ) times. In case of multi-channel images, each channel is processed independently.</p><ul><li>Parameter: <code>src</code>: input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</li><li>Parameter: <code>dst</code>: output image of the same size and type as src.</li><li>Parameter: <code>kernel</code>: structuring element used for erosion; if <code>element=Mat()</code>, a <code>3 x 3</code> rectangular structuring element is used. Kernel can be created using #getStructuringElement.</li><li>Parameter: <code>anchor</code>: position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center.</li><li>Parameter: <code>iterations</code>: number of times erosion is applied.</li><li>Parameter: <code>border_type</code>: pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.</li><li>Parameter: <code>border_value</code>: border value in case of a constant border See also: dilate, morphologyEx, getStructuringElement</li></ul></dd></dl><dl><dt class="spec value" id="val-dilate"><a href="#val-dilate" class="anchor"></a><code><span class="keyword">val</span> dilate : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;anchor:<a href="index.html#type-point2i">point2i</a></span> <span>&#45;&gt;</span> <span>?&#8288;iterations:int</span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;border_value:<a href="Scalar/index.html#type-t">Scalar.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>dilate ?dst ?anchor ?iterations ?border_type ?border_value src kernel</code></p><p>Dilates an image by using a specific structuring element.</p><p>The function dilates the source image using the specified structuring element that determines the shape of a pixel neighborhood over which the maximum is taken: <code>  \, \texttt{element} (x',y') \ne0 } \texttt{src} (x+x',y+y') </code></p><p>The function supports the in-place mode. Dilation can be applied several ( iterations ) times. In case of multi-channel images, each channel is processed independently.</p><ul><li>Parameter: <code>src</code>: input image; the number of channels can be arbitrary, but the depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</li><li>Parameter: <code>dst</code>: output image of the same size and type as src.</li><li>Parameter: <code>kernel</code>: structuring element used for dilation; if elemenat=Mat(), a 3 x 3 rectangular structuring element is used. Kernel can be created using #getStructuringElement</li><li>Parameter: <code>anchor</code>: position of the anchor within the element; default value (-1, -1) means that the anchor is at the element center.</li><li>Parameter: <code>iterations</code>: number of times dilation is applied.</li><li>Parameter: <code>border_type</code>: pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not suported.</li><li>Parameter: <code>border_value</code>: border value in case of a constant border See also: erode, morphologyEx, getStructuringElement</li></ul></dd></dl><dl><dt class="spec value" id="val-morphology_ex"><a href="#val-morphology_ex" class="anchor"></a><code><span class="keyword">val</span> morphology_ex : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;anchor:<a href="index.html#type-point2i">point2i</a></span> <span>&#45;&gt;</span> <span>?&#8288;iterations:int</span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;border_value:<a href="Scalar/index.html#type-t">Scalar.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>morphology_ex ?dst ?anchor ?iterations ?border_type ?border_value src op kernel</code></p><p>Performs advanced morphological transformations.</p><p>The function cv::morphologyEx can perform advanced morphological transformations using an erosion and dilation as basic operations.</p><p>Any of the operations can be done in-place. In case of multi-channel images, each channel is processed independently.</p><ul><li>Parameter: <code>src</code>: Source image. The number of channels can be arbitrary. The depth should be one of CV_8U, CV_16U, CV_16S, CV_32F or CV_64F.</li><li>Parameter: <code>dst</code>: Destination image of the same size and type as source image.</li><li>Parameter: <code>op</code>: Type of a morphological operation, see #MorphTypes</li><li>Parameter: <code>kernel</code>: Structuring element. It can be created using #getStructuringElement.</li><li>Parameter: <code>anchor</code>: Anchor position with the kernel. Negative values mean that the anchor is at the kernel center.</li><li>Parameter: <code>iterations</code>: Number of times erosion and dilation are applied.</li><li>Parameter: <code>border_type</code>: Pixel extrapolation method, see #BorderTypes. #BORDER_WRAP is not supported.</li><li>Parameter: <code>border_value</code>: Border value in case of a constant border. The default value has a special meaning. See also: dilate, erode, getStructuringElement Note: The number of iterations is the number of times erosion or dilatation operation will be applied. For instance, an opening operation (#MORPH_OPEN) with two iterations is equivalent to apply successively: erode -&gt; erode -&gt; dilate -&gt; dilate (and not erode -&gt; dilate -&gt; erode -&gt; dilate).</li></ul></dd></dl><dl><dt class="spec value" id="val-resize"><a href="#val-resize" class="anchor"></a><code><span class="keyword">val</span> resize : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;fx:float</span> <span>&#45;&gt;</span> <span>?&#8288;fy:float</span> <span>&#45;&gt;</span> <span>?&#8288;interpolation:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-size2i">size2i</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>resize ?dst ?fx ?fy ?interpolation src dsize</code></p><p>Resizes an image.</p><p>The function resize resizes the image src down to or up to the specified size. Note that the initial dst type or size are not taken into account. Instead, the size and type are derived from the <code>src</code>,<code>dsize</code>,<code>fx</code>, and <code>fy</code>. If you want to resize src so that it fits the pre-created dst, you may call the function as follows:</p><pre><code class="ml">// explicitly specify dsize=dst.size(); fx and fy will be computed from that.
resize(src, dst, dst.size(), 0, 0, interpolation);</code></pre><p>If you want to decimate the image by factor of 2 in each direction, you can call the function this way:</p><pre><code class="ml">// specify fx and fy and let the function compute the destination image size.
resize(src, dst, Size(), 0.5, 0.5, interpolation);</code></pre><p>To shrink an image, it will generally look best with #INTER_AREA interpolation, whereas to enlarge an image, it will generally look best with c#INTER_CUBIC (slow) or #INTER_LINEAR (faster but still looks OK).</p><ul><li>Parameter: <code>src</code>: input image.</li><li>Parameter: <code>dst</code>: output image; it has the size dsize (when it is non-zero) or the size computed from src.size(), fx, and fy; the type of dst is the same as of src.</li><li>Parameter: <code>dsize</code>: output image size; if it equals zero, it is computed as: <code> \texttt{dsize = Size(round(fx*src.cols), round(fy*src.rows))} </code> Either dsize or both fx and fy must be non-zero.</li><li>Parameter: <code>fx</code>: scale factor along the horizontal axis; when it equals 0, it is computed as <code> \texttt{(double)dsize.width/src.cols} </code></li><li>Parameter: <code>fy</code>: scale factor along the vertical axis; when it equals 0, it is computed as <code> \texttt{(double)dsize.height/src.rows} </code></li><li>Parameter: <code>interpolation</code>: interpolation method, see #InterpolationFlags</li></ul><p>See also: warpAffine, warpPerspective, remap</p></dd></dl><dl><dt class="spec value" id="val-warp_affine"><a href="#val-warp_affine" class="anchor"></a><code><span class="keyword">val</span> warp_affine : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;flags:int</span> <span>&#45;&gt;</span> <span>?&#8288;border_mode:int</span> <span>&#45;&gt;</span> <span>?&#8288;border_value:<a href="Scalar/index.html#type-t">Scalar.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-size2i">size2i</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>warp_affine ?dst ?flags ?border_mode ?border_value src m dsize</code></p><p>Applies an affine transformation to an image.</p><p>The function warpAffine transforms the source image using the specified matrix:</p><p><code> \texttt{dst} (x,y) =  \texttt{src} ( \texttt{M} _{11} x +  \texttt{M} _{12} y +  \texttt{M} _{13}, \texttt{M} _{21} x +  \texttt{M} _{22} y +  \texttt{M} _{23}) </code></p><p>when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with #invertAffineTransform and then put in the formula above instead of M. The function cannot operate in-place.</p><ul><li>Parameter: <code>src</code>: input image.</li><li>Parameter: <code>dst</code>: output image that has the size dsize and the same type as src .</li><li>Parameter: <code>m</code>: <code> 2\times 3 </code> transformation matrix.</li><li>Parameter: <code>dsize</code>: size of the output image.</li><li>Parameter: <code>flags</code>: combination of interpolation methods (see #InterpolationFlags) and the optional flag #WARP_INVERSE_MAP that means that M is the inverse transformation ( <code> \texttt{dst}\rightarrow\texttt{src} </code> ).</li><li>Parameter: <code>border_mode</code>: pixel extrapolation method (see #BorderTypes); when borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image corresponding to the &quot;outliers&quot; in the source image are not modified by the function.</li><li>Parameter: <code>border_value</code>: value used in case of a constant border; by default, it is 0.</li></ul><p>See also: warpPerspective, resize, remap, getRectSubPix, transform</p></dd></dl><dl><dt class="spec value" id="val-warp_perspective"><a href="#val-warp_perspective" class="anchor"></a><code><span class="keyword">val</span> warp_perspective : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;flags:int</span> <span>&#45;&gt;</span> <span>?&#8288;border_mode:int</span> <span>&#45;&gt;</span> <span>?&#8288;border_value:<a href="Scalar/index.html#type-t">Scalar.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-size2i">size2i</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>warp_perspective ?dst ?flags ?border_mode ?border_value src m dsize</code></p><p>Applies a perspective transformation to an image.</p><p>The function warpPerspective transforms the source image using the specified matrix:</p><p><code> \texttt{dst} (x,y) =  \texttt{src} \left ( \frac{M_{11} x + M_{12} y + M_{13}}{M_{31} x + M_{32} y + M_{33}} ,
     \frac{M_{21} x + M_{22} y + M_{23}}{M_{31} x + M_{32} y + M_{33}} \right ) </code></p><p>when the flag #WARP_INVERSE_MAP is set. Otherwise, the transformation is first inverted with invert and then put in the formula above instead of M. The function cannot operate in-place.</p><ul><li>Parameter: <code>src</code>: input image.</li><li>Parameter: <code>dst</code>: output image that has the size dsize and the same type as src .</li><li>Parameter: <code>m</code>: <code> 3\times 3 </code> transformation matrix.</li><li>Parameter: <code>dsize</code>: size of the output image.</li><li>Parameter: <code>flags</code>: combination of interpolation methods (#INTER_LINEAR or #INTER_NEAREST) and the optional flag #WARP_INVERSE_MAP, that sets M as the inverse transformation ( <code> \texttt{dst}\rightarrow\texttt{src} </code> ).</li><li>Parameter: <code>border_mode</code>: pixel extrapolation method (#BORDER_CONSTANT or #BORDER_REPLICATE).</li><li>Parameter: <code>border_value</code>: value used in case of a constant border; by default, it equals 0.</li></ul><p>See also: warpAffine, resize, remap, getRectSubPix, perspectiveTransform</p></dd></dl><dl><dt class="spec value" id="val-remap"><a href="#val-remap" class="anchor"></a><code><span class="keyword">val</span> remap : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;border_mode:int</span> <span>&#45;&gt;</span> <span>?&#8288;border_value:<a href="Scalar/index.html#type-t">Scalar.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>remap ?dst ?border_mode ?border_value src map1 map2 interpolation</code></p><p>Applies a generic geometrical transformation to an image.</p><p>The function remap transforms the source image using the specified map:</p><p><code> \texttt{dst} (x,y) =  \texttt{src} (map_x(x,y),map_y(x,y)) </code></p><p>where values of pixels with non-integer coordinates are computed using one of available interpolation methods. <code> map_x </code> and <code> map_y </code> can be encoded as separate floating-point maps in <code> map_1 </code> and <code> map_2 </code> respectively, or interleaved floating-point maps of <code> (x,y) </code> in <code> map_1 </code>, or fixed-point maps created by using convertMaps. The reason you might want to convert from floating to fixed-point representations of a map is that they can yield much faster (\~2x) remapping operations. In the converted case, <code> map_1 </code> contains pairs (cvFloor(x), cvFloor(y)) and <code> map_2 </code> contains indices in a table of interpolation coefficients.</p><p>This function cannot operate in-place.</p><ul><li>Parameter: <code>src</code>: Source image.</li><li>Parameter: <code>dst</code>: Destination image. It has the same size as map1 and the same type as src .</li><li>Parameter: <code>map1</code>: The first map of either (x,y) points or just x values having the type CV_16SC2 , CV_32FC1, or CV_32FC2. See convertMaps for details on converting a floating point representation to fixed-point for speed.</li><li>Parameter: <code>map2</code>: The second map of y values having the type CV_16UC1, CV_32FC1, or none (empty map if map1 is (x,y) points), respectively.</li><li>Parameter: <code>interpolation</code>: Interpolation method (see #InterpolationFlags). The methods #INTER_AREA and #INTER_LINEAR_EXACT are not supported by this function.</li><li>Parameter: <code>border_mode</code>: Pixel extrapolation method (see #BorderTypes). When borderMode=#BORDER_TRANSPARENT, it means that the pixels in the destination image that corresponds to the &quot;outliers&quot; in the source image are not modified by the function.</li><li>Parameter: <code>border_value</code>: Value used in case of a constant border. By default, it is 0. Note: Due to current implementation limitations the size of an input and output images should be less than 32767x32767.</li></ul></dd></dl><dl><dt class="spec value" id="val-convert_maps"><a href="#val-convert_maps" class="anchor"></a><code><span class="keyword">val</span> convert_maps : <span>?&#8288;dstmap1:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;dstmap2:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;nninterpolation:bool</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>convert_maps ?dstmap1 ?dstmap2 ?nninterpolation map1 map2 dstmap1type</code></p><p>Converts image transformation maps from one representation to another.</p><p>The function converts a pair of maps for remap from one representation to another. The following options ( (map1.type(), map2.type()) <code> \rightarrow </code> (dstmap1.type(), dstmap2.type()) ) are supported:</p><ul><li><code> \texttt{(CV_32FC1, CV_32FC1)} \rightarrow \texttt{(CV_16SC2, CV_16UC1)} </code>. This is the most frequently used conversion operation, in which the original floating-point maps (see remap ) are converted to a more compact and much faster fixed-point representation. The first output array contains the rounded coordinates and the second array (created only when nninterpolation=false ) contains indices in the interpolation tables.</li></ul><ul><li><code> \texttt{(CV_32FC2)} \rightarrow \texttt{(CV_16SC2, CV_16UC1)} </code>. The same as above but the original maps are stored in one 2-channel matrix.</li></ul><ul><li>Reverse conversion. Obviously, the reconstructed floating-point maps will not be exactly the same as the originals.</li></ul><ul><li>Parameter: <code>map1</code>: The first input map of type CV_16SC2, CV_32FC1, or CV_32FC2 .</li><li>Parameter: <code>map2</code>: The second input map of type CV_16UC1, CV_32FC1, or none (empty matrix), respectively.</li><li>Parameter: <code>dstmap1</code>: The first output map that has the type dstmap1type and the same size as src .</li><li>Parameter: <code>dstmap2</code>: The second output map.</li><li>Parameter: <code>dstmap1type</code>: Type of the first output map that should be CV_16SC2, CV_32FC1, or CV_32FC2 .</li><li>Parameter: <code>nninterpolation</code>: Flag indicating whether the fixed-point maps are used for the nearest-neighbor or for a more complex interpolation.</li></ul><p>See also: remap, undistort, initUndistortRectifyMap</p></dd></dl><dl><dt class="spec value" id="val-get_rotation_matrix2_d"><a href="#val-get_rotation_matrix2_d" class="anchor"></a><code><span class="keyword">val</span> get_rotation_matrix2_d : <a href="index.html#type-point2f">point2f</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Mat/index.html#type-t">Mat.t</a></code></dt><dd><p>Usage: <code>get_rotation_matrix2_d center angle scale</code></p><p>Calculates an affine matrix of 2D rotation.</p><p>The function calculates the following matrix:</p><p><code> \begin{bmatrix} \alpha &amp;  \beta &amp; (1- \alpha )  \cdot \texttt{center.x} -  \beta \cdot \texttt{center.y} \\ - \beta &amp;  \alpha &amp;  \beta \cdot \texttt{center.x} + (1- \alpha )  \cdot \texttt{center.y} \end{bmatrix} </code></p><p>where</p><p><code> \begin{array}{l} \alpha =  \texttt{scale} \cdot \cos \texttt{angle} , \\ \beta =  \texttt{scale} \cdot \sin \texttt{angle} \end{array} </code></p><p>The transformation maps the rotation center to itself. If this is not the target, adjust the shift.</p><ul><li>Parameter: <code>center</code>: Center of the rotation in the source image.</li><li>Parameter: <code>angle</code>: Rotation angle in degrees. Positive values mean counter-clockwise rotation (the coordinate origin is assumed to be the top-left corner).</li><li>Parameter: <code>scale</code>: Isotropic scale factor.</li></ul><p>See also: getAffineTransform, warpAffine, transform</p></dd></dl><dl><dt class="spec value" id="val-invert_affine_transform"><a href="#val-invert_affine_transform" class="anchor"></a><code><span class="keyword">val</span> invert_affine_transform : <span>?&#8288;i_m:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>invert_affine_transform ?i_m m</code></p><p>Inverts an affine transformation.</p><p>The function computes an inverse affine transformation represented by <code> 2 \times 3 </code> matrix M:</p><p><code> \begin{bmatrix} a_{11} &amp; a_{12} &amp; b_1  \\ a_{21} &amp; a_{22} &amp; b_2 \end{bmatrix} </code></p><p>The result is also a <code> 2 \times 3 </code> matrix of the same type as M.</p><ul><li>Parameter: <code>m</code>: Original affine transformation.</li><li>Parameter: <code>i_m</code>: Output reverse affine transformation.</li></ul></dd></dl><dl><dt class="spec value" id="val-get_perspective_transform"><a href="#val-get_perspective_transform" class="anchor"></a><code><span class="keyword">val</span> get_perspective_transform : <span>?&#8288;solve_method:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Mat/index.html#type-t">Mat.t</a></code></dt><dd><p>Usage: <code>get_perspective_transform ?solve_method src dst</code></p><p>Calculates a perspective transform from four pairs of the corresponding points.</p><p>The function calculates the <code> 3 \times 3 </code> matrix of a perspective transform so that:</p><p><code> \begin{bmatrix} t_i x'_i \\ t_i y'_i \\ t_i \end{bmatrix} = \texttt{map_matrix} \cdot \begin{bmatrix} x_i \\ y_i \\ 1 \end{bmatrix} </code></p><p>where</p><p><code> dst(i)=(x'_i,y'_i), src(i)=(x_i, y_i), i=0,1,2,3 </code></p><ul><li>Parameter: <code>src</code>: Coordinates of quadrangle vertices in the source image.</li><li>Parameter: <code>dst</code>: Coordinates of the corresponding quadrangle vertices in the destination image.</li><li>Parameter: <code>solve_method</code>: method passed to cv::solve (#DecompTypes)</li></ul><p>See also: findHomography, warpPerspective, perspectiveTransform</p></dd></dl><dl><dt class="spec value" id="val-get_affine_transform"><a href="#val-get_affine_transform" class="anchor"></a><code><span class="keyword">val</span> get_affine_transform : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Mat/index.html#type-t">Mat.t</a></code></dt><dd><p>Usage: <code>get_affine_transform src dst</code></p></dd></dl><dl><dt class="spec value" id="val-get_rect_sub_pix"><a href="#val-get_rect_sub_pix" class="anchor"></a><code><span class="keyword">val</span> get_rect_sub_pix : <span>?&#8288;patch:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;patch_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-size2i">size2i</a> <span>&#45;&gt;</span> <a href="index.html#type-point2f">point2f</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>get_rect_sub_pix ?patch ?patch_type image patch_size center</code></p><p>Retrieves a pixel rectangle from an image with sub-pixel accuracy.</p><p>The function getRectSubPix extracts pixels from src:</p><p><code> patch(x, y) = src(x +  \texttt{center.x} - ( \texttt{dst.cols} -1)*0.5, y +  \texttt{center.y} - ( \texttt{dst.rows} -1)*0.5) </code></p><p>where the values of the pixels at non-integer coordinates are retrieved using bilinear interpolation. Every channel of multi-channel images is processed independently. Also the image should be a single channel or three channel image. While the center of the rectangle must be inside the image, parts of the rectangle may be outside.</p><ul><li>Parameter: <code>image</code>: Source image.</li><li>Parameter: <code>patch_size</code>: Size of the extracted patch.</li><li>Parameter: <code>center</code>: Floating point coordinates of the center of the extracted rectangle within the source image. The center must be inside the image.</li><li>Parameter: <code>patch</code>: Extracted patch that has the size patchSize and the same number of channels as src .</li><li>Parameter: <code>patch_type</code>: Depth of the extracted pixels. By default, they have the same depth as src .</li></ul><p>See also: warpAffine, warpPerspective</p></dd></dl><dl><dt class="spec value" id="val-log_polar"><a href="#val-log_polar" class="anchor"></a><code><span class="keyword">val</span> log_polar : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-point2f">point2f</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>log_polar ?dst src center m flags</code></p><p>Remaps an image to semilog-polar coordinates space.</p><dl><dt>deprecated</dt><dd><p>This function produces same result as cv::warpPolar(src, dst, src.size(), center, maxRadius, flags+WARP_POLAR_LOG);</p><p>Transform the source image using the following transformation (See polar_remaps_reference_image &quot;Polar remaps reference image d)&quot;): <code> \begin{array}{l}
  dst( \rho , \phi ) = src(x,y) \\
  dst.size() \leftarrow src.size()
\end{array} </code></p><p>where <code> \begin{array}{l}
  I = (dx,dy) = (x - center.x,y - center.y) \\
  \rho = M \cdot log_e(\texttt{magnitude} (I)) ,\\
  \phi = Kangle \cdot \texttt{angle} (I) \\
\end{array} </code></p><p>and <code> \begin{array}{l}
  M = src.cols / log_e(maxRadius) \\
  Kangle = src.rows / 2\Pi \\
\end{array} </code></p><p>The function emulates the human &quot;foveal&quot; vision and can be used for fast scale and rotation-invariant template matching, for object tracking and so forth.</p><ul><li>Parameter: <code>src</code>: Source image</li><li>Parameter: <code>dst</code>: Destination image. It will have same size and type as src.</li><li>Parameter: <code>center</code>: The transformation center; where the output precision is maximal</li><li>Parameter: <code>m</code>: Magnitude scale parameter. It determines the radius of the bounding circle to transform too.</li><li>Parameter: <code>flags</code>: A combination of interpolation methods, see #InterpolationFlags</li></ul><p>Note:</p><ul><li>The function can not operate in-place.</li><li>To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.</li></ul><p>See also: cv::linearPolar</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-linear_polar"><a href="#val-linear_polar" class="anchor"></a><code><span class="keyword">val</span> linear_polar : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-point2f">point2f</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>linear_polar ?dst src center max_radius flags</code></p><p>Remaps an image to polar coordinates space.</p><dl><dt>deprecated</dt><dd><p>This function produces same result as cv::warpPolar(src, dst, src.size(), center, maxRadius, flags)</p><p>Transform the source image using the following transformation (See polar_remaps_reference_image &quot;Polar remaps reference image c)&quot;): <code> \begin{array}{l}
  dst( \rho , \phi ) = src(x,y) \\
  dst.size() \leftarrow src.size()
\end{array} </code></p><p>where <code> \begin{array}{l}
  I = (dx,dy) = (x - center.x,y - center.y) \\
  \rho = Kmag \cdot \texttt{magnitude} (I) ,\\
  \phi = angle \cdot \texttt{angle} (I)
\end{array} </code></p><p>and <code> \begin{array}{l}
  Kx = src.cols / maxRadius \\
  Ky = src.rows / 2\Pi
\end{array} </code></p><ul><li>Parameter: <code>src</code>: Source image</li><li>Parameter: <code>dst</code>: Destination image. It will have same size and type as src.</li><li>Parameter: <code>center</code>: The transformation center;</li><li>Parameter: <code>max_radius</code>: The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too.</li><li>Parameter: <code>flags</code>: A combination of interpolation methods, see #InterpolationFlags</li></ul><p>Note:</p><ul><li>The function can not operate in-place.</li><li>To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.</li></ul><p>See also: cv::logPolar</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-warp_polar"><a href="#val-warp_polar" class="anchor"></a><code><span class="keyword">val</span> warp_polar : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-size2i">size2i</a> <span>&#45;&gt;</span> <a href="index.html#type-point2f">point2f</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>warp_polar ?dst src dsize center max_radius flags</code></p><p>\brief Remaps an image to polar or semilog-polar coordinates space</p><p>polar_remaps_reference_image !<code>Polar remaps reference</code>(pics/polar_remap_doc.png)</p><p>Transform the source image using the following transformation: <code> 
dst(\rho , \phi ) = src(x,y)
 </code></p><p>where <code> 
\begin{array}{l}
\vec{I} = (x - center.x, \;y - center.y) \\
\phi = Kangle \cdot \texttt{angle} (\vec{I}) \\
\rho = \left\{\begin{matrix}
Klin \cdot \texttt{magnitude} (\vec{I}) &amp; default \\
Klog \cdot log_e(\texttt{magnitude} (\vec{I})) &amp; if \; semilog \\
\end{matrix}\right.
\end{array}
 </code></p><p>and <code> 
\begin{array}{l}
Kangle = dsize.height / 2\Pi \\
Klin = dsize.width / maxRadius \\
Klog = dsize.width / log_e(maxRadius) \\
\end{array}
 </code></p><p>\par Linear vs semilog mapping</p><p>Polar mapping can be linear or semi-log. Add one of #WarpPolarMode to <code>flags</code> to specify the polar mapping mode.</p><p>Linear is the default mode.</p><p>The semilog mapping emulates the human &quot;foveal&quot; vision that permit very high acuity on the line of sight (central vision) in contrast to peripheral vision where acuity is minor.</p><p>\par Option on <code>dsize</code>:</p><ul><li>if both values in <code>dsize &lt;=0 </code> (default), the destination image will have (almost) same area of source bounding circle: <code> \begin{array}{l}
dsize.area  \leftarrow (maxRadius^2 \cdot \Pi) \\
dsize.width = \texttt{cvRound}(maxRadius) \\
dsize.height = \texttt{cvRound}(maxRadius \cdot \Pi) \\
\end{array} </code></li></ul><ul><li>if only <code>dsize.height &lt;= 0</code>, the destination image area will be proportional to the bounding circle area but scaled by <code>Kx * Kx</code>: <code> \begin{array}{l}
dsize.height = \texttt{cvRound}(dsize.width \cdot \Pi) \\
\end{array}
 </code></li></ul><ul><li>if both values in <code>dsize &gt; 0 </code>, the destination image will have the given size therefore the area of the bounding circle will be scaled to <code>dsize</code>.</li></ul><p>\par Reverse mapping</p><p>You can get reverse mapping adding #WARP_INVERSE_MAP to <code>flags</code> \snippet polar_transforms.cpp InverseMap</p><p>In addiction, to calculate the original coordinate from a polar mapped coordinate <code> (rho, phi)-&gt;(x, y) </code>: \snippet polar_transforms.cpp InverseCoordinate</p><ul><li>Parameter: <code>src</code>: Source image.</li><li>Parameter: <code>dst</code>: Destination image. It will have same type as src.</li><li>Parameter: <code>dsize</code>: The destination image size (see description for valid options).</li><li>Parameter: <code>center</code>: The transformation center.</li><li>Parameter: <code>max_radius</code>: The radius of the bounding circle to transform. It determines the inverse magnitude scale parameter too.</li><li>Parameter: <code>flags</code>: A combination of interpolation methods, #InterpolationFlags + #WarpPolarMode.</li><li>Add #WARP_POLAR_LINEAR to select linear polar mapping (default)</li><li>Add #WARP_POLAR_LOG to select semilog polar mapping</li><li>Add #WARP_INVERSE_MAP for reverse mapping. Note:</li><li>The function can not operate in-place.</li><li>To calculate magnitude and angle in degrees #cartToPolar is used internally thus angles are measured from 0 to 360 with accuracy about 0.3 degrees.</li><li>This function uses #remap. Due to current implementation limitations the size of an input and output images should be less than 32767x32767.</li></ul><p>See also: cv::remap</p></dd></dl><dl><dt class="spec value" id="val-integral1"><a href="#val-integral1" class="anchor"></a><code><span class="keyword">val</span> integral1 : <span>?&#8288;sum:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;sdepth:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>integral1 ?sum ?sdepth src</code></p></dd></dl><dl><dt class="spec value" id="val-integral2"><a href="#val-integral2" class="anchor"></a><code><span class="keyword">val</span> integral2 : <span>?&#8288;sum:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;sqsum:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;sdepth:int</span> <span>&#45;&gt;</span> <span>?&#8288;sqdepth:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>integral2 ?sum ?sqsum ?sdepth ?sqdepth src</code></p></dd></dl><dl><dt class="spec value" id="val-integral3"><a href="#val-integral3" class="anchor"></a><code><span class="keyword">val</span> integral3 : <span>?&#8288;sum:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;sqsum:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;tilted:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;sdepth:int</span> <span>&#45;&gt;</span> <span>?&#8288;sqdepth:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>integral3 ?sum ?sqsum ?tilted ?sdepth ?sqdepth src</code></p><p>Calculates the integral of an image.</p><p>The function calculates one or more integral images for the source image as follows:</p><p><code> \texttt{sum} (X,Y) =  \sum _{x&lt;X,y&lt;Y}  \texttt{image} (x,y) </code></p><p><code> \texttt{sqsum} (X,Y) =  \sum _{x&lt;X,y&lt;Y}  \texttt{image} (x,y)^2 </code></p><p><code> \texttt{tilted} (X,Y) =  \sum _{y&lt;Y,abs(x-X+1) \leq Y-y-1}  \texttt{image} (x,y) </code></p><p>Using these integral images, you can calculate sum, mean, and standard deviation over a specific up-right or rotated rectangular region of the image in a constant time, for example:</p><p><code> \sum _{x_1 \leq x &lt; x_2,  \, y_1  \leq y &lt; y_2}  \texttt{image} (x,y) =  \texttt{sum} (x_2,y_2)- \texttt{sum} (x_1,y_2)- \texttt{sum} (x_2,y_1)+ \texttt{sum} (x_1,y_1) </code></p><p>It makes possible to do a fast blurring or fast block correlation with a variable window size, for example. In case of multi-channel images, sums for each channel are accumulated independently.</p><p>As a practical example, the next figure shows the calculation of the integral of a straight rectangle Rect(3,3,3,2) and of a tilted rectangle Rect(5,1,2,3) . The selected pixels in the original image are shown, as well as the relative pixels in the integral images sum and tilted .</p><p>!<code>integral calculation example</code>(pics/integral.png)</p><ul><li>Parameter: <code>src</code>: input image as <code> W \times H </code>, 8-bit or floating-point (32f or 64f).</li><li>Parameter: <code>sum</code>: integral image as <code> (W+1)\times (H+1) </code> , 32-bit integer or floating-point (32f or 64f).</li><li>Parameter: <code>sqsum</code>: integral image for squared pixel values; it is <code> (W+1)\times (H+1) </code>, double-precision floating-point (64f) array.</li><li>Parameter: <code>tilted</code>: integral for the image rotated by 45 degrees; it is <code> (W+1)\times (H+1) </code> array with the same data type as sum.</li><li>Parameter: <code>sdepth</code>: desired depth of the integral and the tilted integral images, CV_32S, CV_32F, or CV_64F.</li><li>Parameter: <code>sqdepth</code>: desired depth of the integral image of squared pixel values, CV_32F or CV_64F.</li></ul></dd></dl><dl><dt class="spec value" id="val-accumulate"><a href="#val-accumulate" class="anchor"></a><code><span class="keyword">val</span> accumulate : <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>accumulate ?mask src dst</code></p><p>Adds an image to the accumulator image.</p><p>The function adds src or some of its elements to dst :</p><p><code> \texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0 </code></p><p>The function supports multi-channel images. Each channel is processed independently.</p><p>The function cv::accumulate can be used, for example, to collect statistics of a scene background viewed by a still camera and for the further foreground-background segmentation.</p><ul><li>Parameter: <code>src</code>: Input image of type CV_8UC(n), CV_16UC(n), CV_32FC(n) or CV_64FC(n), where n is a positive integer.</li><li>Parameter: <code>dst</code>: %Accumulator image with the same number of channels as input image, and a depth of CV_32F or CV_64F.</li><li>Parameter: <code>mask</code>: Optional operation mask.</li></ul><p>See also: accumulateSquare, accumulateProduct, accumulateWeighted</p></dd></dl><dl><dt class="spec value" id="val-accumulate_square"><a href="#val-accumulate_square" class="anchor"></a><code><span class="keyword">val</span> accumulate_square : <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>accumulate_square ?mask src dst</code></p><p>Adds the square of a source image to the accumulator image.</p><p>The function adds the input image src or its selected region, raised to a power of 2, to the accumulator dst :</p><p><code> \texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src} (x,y)^2  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0 </code></p><p>The function supports multi-channel images. Each channel is processed independently.</p><ul><li>Parameter: <code>src</code>: Input image as 1- or 3-channel, 8-bit or 32-bit floating point.</li><li>Parameter: <code>dst</code>: %Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point.</li><li>Parameter: <code>mask</code>: Optional operation mask.</li></ul><p>See also: accumulateSquare, accumulateProduct, accumulateWeighted</p></dd></dl><dl><dt class="spec value" id="val-accumulate_product"><a href="#val-accumulate_product" class="anchor"></a><code><span class="keyword">val</span> accumulate_product : <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>accumulate_product ?mask src1 src2 dst</code></p><p>Adds the per-element product of two input images to the accumulator image.</p><p>The function adds the product of two images or their selected regions to the accumulator dst :</p><p><code> \texttt{dst} (x,y)  \leftarrow \texttt{dst} (x,y) +  \texttt{src1} (x,y)  \cdot \texttt{src2} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0 </code></p><p>The function supports multi-channel images. Each channel is processed independently.</p><ul><li>Parameter: <code>src1</code>: First input image, 1- or 3-channel, 8-bit or 32-bit floating point.</li><li>Parameter: <code>src2</code>: Second input image of the same type and the same size as src1 .</li><li>Parameter: <code>dst</code>: %Accumulator image with the same number of channels as input images, 32-bit or 64-bit floating-point.</li><li>Parameter: <code>mask</code>: Optional operation mask.</li></ul><p>See also: accumulate, accumulateSquare, accumulateWeighted</p></dd></dl><dl><dt class="spec value" id="val-accumulate_weighted"><a href="#val-accumulate_weighted" class="anchor"></a><code><span class="keyword">val</span> accumulate_weighted : <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>accumulate_weighted ?mask src dst alpha</code></p><p>Updates a running average.</p><p>The function calculates the weighted sum of the input image src and the accumulator dst so that dst becomes a running average of a frame sequence:</p><p><code> \texttt{dst} (x,y)  \leftarrow (1- \texttt{alpha} )  \cdot \texttt{dst} (x,y) +  \texttt{alpha} \cdot \texttt{src} (x,y)  \quad \text{if} \quad \texttt{mask} (x,y)  \ne 0 </code></p><p>That is, alpha regulates the update speed (how fast the accumulator &quot;forgets&quot; about earlier images). The function supports multi-channel images. Each channel is processed independently.</p><ul><li>Parameter: <code>src</code>: Input image as 1- or 3-channel, 8-bit or 32-bit floating point.</li><li>Parameter: <code>dst</code>: %Accumulator image with the same number of channels as input image, 32-bit or 64-bit floating-point.</li><li>Parameter: <code>alpha</code>: Weight of the input image.</li><li>Parameter: <code>mask</code>: Optional operation mask.</li></ul><p>See also: accumulate, accumulateSquare, accumulateProduct</p></dd></dl><dl><dt class="spec value" id="val-phase_correlate"><a href="#val-phase_correlate" class="anchor"></a><code><span class="keyword">val</span> phase_correlate : <span>?&#8288;window:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;response:float</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-point2d">point2d</a></code></dt><dd><p>Usage: <code>phase_correlate ?window ?response src1 src2</code></p><p>The function is used to detect translational shifts that occur between two images.</p><p>The operation takes advantage of the Fourier shift theorem for detecting the translational shift in the frequency domain. It can be used for fast image registration as well as motion estimation. For more information please see &lt;http://en.wikipedia.org/wiki/Phase_correlation&gt;</p><p>Calculates the cross-power spectrum of two supplied source arrays. The arrays are padded if needed with getOptimalDFTSize.</p><p>The function performs the following equations:</p><ul><li>First it applies a Hanning window (see &lt;http://en.wikipedia.org/wiki/Hann_function&gt;) to each image to remove possible edge effects. This window is cached until the array size changes to speed up processing time.</li><li>Next it computes the forward DFTs of each source array: <code> \mathbf{G}_a = \mathcal{F}\{src_1\}, \; \mathbf{G}_b = \mathcal{F}\{src_2\} </code> where <code> \mathcal{F} </code> is the forward DFT.</li><li>It then computes the cross-power spectrum of each frequency domain array: <code> R = \frac{ \mathbf{G}_a \mathbf{G}_b^*}{ |\mathbf{G}_a \mathbf{G}_b^*|} </code></li><li>Next the cross-correlation is converted back into the time domain via the inverse DFT: <code> r = \mathcal{F}^{-1}\{R\} </code></li><li>Finally, it computes the peak location and computes a 5x5 weighted centroid around the peak to achieve sub-pixel accuracy. <code> (\Delta x, \Delta y) = \texttt{weightedCentroid} \{\arg \max_{(x, y)}\{r\}\} </code></li><li>If non-zero, the response parameter is computed as the sum of the elements of r within the 5x5 centroid around the peak location. It is normalized to a maximum of 1 (meaning there is a single peak) and will be smaller when there are multiple peaks.</li></ul><ul><li>Parameter: <code>src1</code>: Source floating point array (CV_32FC1 or CV_64FC1)</li><li>Parameter: <code>src2</code>: Source floating point array (CV_32FC1 or CV_64FC1)</li><li>Parameter: <code>window</code>: Floating point array with windowing coefficients to reduce edge effects (optional).</li><li>Parameter: <code>response</code>: Signal power within the 5x5 centroid around the peak, between 0 and 1 (optional).</li><li>Returns: detected phase shift (sub-pixel) between the two arrays.</li></ul><p>See also: dft, getOptimalDFTSize, idft, mulSpectrums createHanningWindow</p></dd></dl><dl><dt class="spec value" id="val-create_hanning_window"><a href="#val-create_hanning_window" class="anchor"></a><code><span class="keyword">val</span> create_hanning_window : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-size2i">size2i</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>create_hanning_window ?dst win_size cv_type</code></p><p>This function computes a Hanning window coefficients in two dimensions.</p><p>See (http://en.wikipedia.org/wiki/Hann_function) and (http://en.wikipedia.org/wiki/Window_function) for more information.</p><p>An example is shown below:</p><pre><code class="ml">// create hanning window of size 100x100 and type CV_32F
Mat hann;
createHanningWindow(hann, Size(100, 100), CV_32F);</code></pre><ul><li>Parameter: <code>dst</code>: Destination array to place Hann coefficients in</li><li>Parameter: <code>win_size</code>: The window size specifications (both width and height must be &gt; 1)</li><li>Parameter: <code>cv_type</code>: Created array type</li></ul></dd></dl><dl><dt class="spec value" id="val-threshold"><a href="#val-threshold" class="anchor"></a><code><span class="keyword">val</span> threshold : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * float</code></dt><dd><p>Usage: <code>threshold ?dst src thresh maxval cv_type</code></p><p>Applies a fixed-level threshold to each array element.</p><p>The function applies fixed-level thresholding to a multiple-channel array. The function is typically used to get a bi-level (binary) image out of a grayscale image ( #compare could be also used for this purpose) or for removing a noise, that is, filtering out pixels with too small or too large values. There are several types of thresholding supported by the function. They are determined by type parameter.</p><p>Also, the special values #THRESH_OTSU or #THRESH_TRIANGLE may be combined with one of the above values. In these cases, the function determines the optimal threshold value using the Otsu's or Triangle algorithm and uses it instead of the specified thresh.</p><p>Note: Currently, the Otsu's and Triangle methods are implemented only for 8-bit single-channel images.</p><ul><li>Parameter: <code>src</code>: input array (multiple-channel, 8-bit or 32-bit floating point).</li><li>Parameter: <code>dst</code>: output array of the same size and type and the same number of channels as src.</li><li>Parameter: <code>thresh</code>: threshold value.</li><li>Parameter: <code>maxval</code>: maximum value to use with the #THRESH_BINARY and #THRESH_BINARY_INV thresholding types.</li><li>Parameter: <code>cv_type</code>: thresholding type (see #ThresholdTypes).</li><li>Returns: the computed threshold value if Otsu's or Triangle methods used.</li></ul><p>See also: adaptiveThreshold, findContours, compare, min, max</p></dd></dl><dl><dt class="spec value" id="val-adaptive_threshold"><a href="#val-adaptive_threshold" class="anchor"></a><code><span class="keyword">val</span> adaptive_threshold : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>adaptive_threshold ?dst src max_value adaptive_method threshold_type block_size c</code></p><p>Applies an adaptive threshold to an array.</p><p>The function transforms a grayscale image to a binary image according to the formulae:</p><ul><li>**THRESH_BINARY** <code> dst(x,y) =  \fork{\texttt{maxValue}}{if \(src(x,y) &gt; T(x,y)\)}{0}{otherwise} </code></li><li>**THRESH_BINARY_INV** <code> dst(x,y) =  \fork{0}{if \(src(x,y) &gt; T(x,y)\)}{\texttt{maxValue}}{otherwise} </code> where <code> T(x,y) </code> is a threshold calculated individually for each pixel (see adaptiveMethod parameter).</li></ul><p>The function can process the image in-place.</p><ul><li>Parameter: <code>src</code>: Source 8-bit single-channel image.</li><li>Parameter: <code>dst</code>: Destination image of the same size and the same type as src.</li><li>Parameter: <code>max_value</code>: Non-zero value assigned to the pixels for which the condition is satisfied</li><li>Parameter: <code>adaptive_method</code>: Adaptive thresholding algorithm to use, see #AdaptiveThresholdTypes. The #BORDER_REPLICATE | #BORDER_ISOLATED is used to process boundaries.</li><li>Parameter: <code>threshold_type</code>: Thresholding type that must be either #THRESH_BINARY or #THRESH_BINARY_INV, see #ThresholdTypes.</li><li>Parameter: <code>block_size</code>: Size of a pixel neighborhood that is used to calculate a threshold value for the pixel: 3, 5, 7, and so on.</li><li>Parameter: <code>c</code>: Constant subtracted from the mean or weighted mean (see the details below). Normally, it is positive but may be zero or negative as well.</li></ul><p>See also: threshold, blur, GaussianBlur</p></dd></dl><dl><dt class="spec value" id="val-pyr_down"><a href="#val-pyr_down" class="anchor"></a><code><span class="keyword">val</span> pyr_down : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;dstsize:<a href="index.html#type-size2i">size2i</a></span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>pyr_down ?dst ?dstsize ?border_type src</code></p><p>Blurs an image and downsamples it.</p><p>By default, size of the output image is computed as <code>Size((src.cols+1)/2, (src.rows+1)/2)</code>, but in any case, the following conditions should be satisfied:</p><p><code> \begin{array}{l} | \texttt{dstsize.width} *2-src.cols| \leq 2 \\ | \texttt{dstsize.height} *2-src.rows| \leq 2 \end{array} </code></p><p>The function performs the downsampling step of the Gaussian pyramid construction. First, it convolves the source image with the kernel:</p><p><code> \frac{1}{256} \begin{bmatrix} 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1  \\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \\ 6 &amp; 24 &amp; 36 &amp; 24 &amp; 6  \\ 4 &amp; 16 &amp; 24 &amp; 16 &amp; 4  \\ 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1 \end{bmatrix} </code></p><p>Then, it downsamples the image by rejecting even rows and columns.</p><ul><li>Parameter: <code>src</code>: input image.</li><li>Parameter: <code>dst</code>: output image; it has the specified size and the same type as src.</li><li>Parameter: <code>dstsize</code>: size of the output image.</li><li>Parameter: <code>border_type</code>: Pixel extrapolation method, see #BorderTypes (#BORDER_CONSTANT isn't supported)</li></ul></dd></dl><dl><dt class="spec value" id="val-pyr_up"><a href="#val-pyr_up" class="anchor"></a><code><span class="keyword">val</span> pyr_up : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;dstsize:<a href="index.html#type-size2i">size2i</a></span> <span>&#45;&gt;</span> <span>?&#8288;border_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>pyr_up ?dst ?dstsize ?border_type src</code></p><p>Upsamples an image and then blurs it.</p><p>By default, size of the output image is computed as <code>Size(src.cols\*2, (src.rows\*2)</code>, but in any case, the following conditions should be satisfied:</p><p><code> \begin{array}{l} | \texttt{dstsize.width} -src.cols*2| \leq  ( \texttt{dstsize.width}   \mod  2)  \\ | \texttt{dstsize.height} -src.rows*2| \leq  ( \texttt{dstsize.height}   \mod  2) \end{array} </code></p><p>The function performs the upsampling step of the Gaussian pyramid construction, though it can actually be used to construct the Laplacian pyramid. First, it upsamples the source image by injecting even zero rows and columns and then convolves the result with the same kernel as in pyrDown multiplied by 4.</p><ul><li>Parameter: <code>src</code>: input image.</li><li>Parameter: <code>dst</code>: output image. It has the specified size and the same type as src .</li><li>Parameter: <code>dstsize</code>: size of the output image.</li><li>Parameter: <code>border_type</code>: Pixel extrapolation method, see #BorderTypes (only #BORDER_DEFAULT is supported)</li></ul></dd></dl><dl><dt class="spec value" id="val-calc_hist"><a href="#val-calc_hist" class="anchor"></a><code><span class="keyword">val</span> calc_hist : <span>?&#8288;hist:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;accumulate:bool</span> <span>&#45;&gt;</span> <span><a href="Cvdata/index.html#type-t">Cvdata.t</a> list</span> <span>&#45;&gt;</span> <span>int list</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <span>int list</span> <span>&#45;&gt;</span> <span>float list</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>calc_hist ?hist ?accumulate images channels mask hist_size ranges</code></p></dd></dl><dl><dt class="spec value" id="val-calc_back_project"><a href="#val-calc_back_project" class="anchor"></a><code><span class="keyword">val</span> calc_back_project : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span><a href="Cvdata/index.html#type-t">Cvdata.t</a> list</span> <span>&#45;&gt;</span> <span>int list</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <span>float list</span> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>calc_back_project ?dst images channels hist ranges scale</code></p></dd></dl><dl><dt class="spec value" id="val-compare_hist"><a href="#val-compare_hist" class="anchor"></a><code><span class="keyword">val</span> compare_hist : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float</code></dt><dd><p>Usage: <code>compare_hist h1 h2 cv_method</code></p><p>Compares two histograms.</p><p>The function cv::compareHist compares two dense or two sparse histograms using the specified method.</p><p>The function returns <code> d(H_1, H_2) </code> .</p><p>While the function works well with 1-, 2-, 3-dimensional dense histograms, it may not be suitable for high-dimensional sparse histograms. In such histograms, because of aliasing and sampling problems, the coordinates of non-zero histogram bins can slightly shift. To compare such histograms or more general sparse configurations of weighted points, consider using the #EMD function.</p><ul><li>Parameter: <code>h1</code>: First compared histogram.</li><li>Parameter: <code>h2</code>: Second compared histogram of the same size as H1 .</li><li>Parameter: <code>cv_method</code>: Comparison method, see #HistCompMethods</li></ul></dd></dl><dl><dt class="spec value" id="val-equalize_hist"><a href="#val-equalize_hist" class="anchor"></a><code><span class="keyword">val</span> equalize_hist : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>equalize_hist ?dst src</code></p><p>Equalizes the histogram of a grayscale image.</p><p>The function equalizes the histogram of the input image using the following algorithm:</p><ul><li>Calculate the histogram <code> H </code> for src .</li><li>Normalize the histogram so that the sum of histogram bins is 255.</li><li>Compute the integral of the histogram: <code> H'_i =  \sum _{0  \le j &lt; i} H(j) </code></li><li>Transform the image using <code> H' </code> as a look-up table: <code> \texttt{dst}(x,y) = H'(\texttt{src}(x,y)) </code></li></ul><p>The algorithm normalizes the brightness and increases the contrast of the image.</p><ul><li>Parameter: <code>src</code>: Source 8-bit single channel image.</li><li>Parameter: <code>dst</code>: Destination image of the same size and type as src .</li></ul></dd></dl><dl><dt class="spec value" id="val-watershed"><a href="#val-watershed" class="anchor"></a><code><span class="keyword">val</span> watershed : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>watershed image markers</code></p><p>Performs a marker-based image segmentation using the watershed algorithm.</p><p>The function implements one of the variants of watershed, non-parametric marker-based segmentation algorithm, described in Meyer92 .</p><p>Before passing the image to the function, you have to roughly outline the desired regions in the image markers with positive (\&gt;0) indices. So, every region is represented as one or more connected components with the pixel values 1, 2, 3, and so on. Such markers can be retrieved from a binary mask using #findContours and #drawContours (see the watershed.cpp demo). The markers are &quot;seeds&quot; of the future image regions. All the other pixels in markers , whose relation to the outlined regions is not known and should be defined by the algorithm, should be set to 0's. In the function output, each pixel in markers is set to a value of the &quot;seed&quot; components or to -1 at boundaries between the regions.</p><p>Note: Any two neighbor connected components are not necessarily separated by a watershed boundary (-1's pixels); for example, they can touch each other in the initial marker image passed to the function.</p><ul><li>Parameter: <code>image</code>: Input 8-bit 3-channel image.</li><li>Parameter: <code>markers</code>: Input/output 32-bit single-channel image (map) of markers. It should have the same size as image .</li></ul><p>See also: findContours</p><p>Group: imgproc_misc</p></dd></dl><dl><dt class="spec value" id="val-grab_cut"><a href="#val-grab_cut" class="anchor"></a><code><span class="keyword">val</span> grab_cut : <span>?&#8288;mode:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-rect2i">rect2i</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>grab_cut ?mode img mask rect bgd_model fgd_model iter_count</code></p><p>Runs the GrabCut algorithm.</p><p>The function implements the <code>GrabCut image segmentation algorithm</code>(http://en.wikipedia.org/wiki/GrabCut).</p><ul><li>Parameter: <code>img</code>: Input 8-bit 3-channel image.</li><li>Parameter: <code>mask</code>: Input/output 8-bit single-channel mask. The mask is initialized by the function when mode is set to #GC_INIT_WITH_RECT. Its elements may have one of the #GrabCutClasses.</li><li>Parameter: <code>rect</code>: ROI containing a segmented object. The pixels outside of the ROI are marked as &quot;obvious background&quot;. The parameter is only used when mode==#GC_INIT_WITH_RECT .</li><li>Parameter: <code>bgd_model</code>: Temporary array for the background model. Do not modify it while you are processing the same image.</li><li>Parameter: <code>fgd_model</code>: Temporary arrays for the foreground model. Do not modify it while you are processing the same image.</li><li>Parameter: <code>iter_count</code>: Number of iterations the algorithm should make before returning the result. Note that the result can be refined with further calls with mode==#GC_INIT_WITH_MASK or mode==GC_EVAL .</li><li>Parameter: <code>mode</code>: Operation mode that could be one of the #GrabCutModes</li></ul></dd></dl><dl><dt class="spec value" id="val-distance_transform1"><a href="#val-distance_transform1" class="anchor"></a><code><span class="keyword">val</span> distance_transform1 : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;labels:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;label_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>distance_transform1 ?dst ?labels ?label_type src distance_type mask_size</code></p><p>Calculates the distance to the closest zero pixel for each pixel of the source image.</p><p>The function cv::distanceTransform calculates the approximate or precise distance from every binary image pixel to the nearest zero pixel. For zero image pixels, the distance will obviously be zero.</p><p>When maskSize == #DIST_MASK_PRECISE and distanceType == #DIST_L2 , the function runs the algorithm described in Felzenszwalb04 . This algorithm is parallelized with the TBB library.</p><p>In other cases, the algorithm Borgefors86 is used. This means that for a pixel the function finds the shortest path to the nearest zero pixel consisting of basic shifts: horizontal, vertical, diagonal, or knight's move (the latest is available for a <code> 5\times 5 </code> mask). The overall distance is calculated as a sum of these basic distances. Since the distance function should be symmetric, all of the horizontal and vertical shifts must have the same cost (denoted as a ), all the diagonal shifts must have the same cost (denoted as <code>b</code>), and all knight's moves must have the same cost (denoted as <code>c</code>). For the #DIST_C and #DIST_L1 types, the distance is calculated precisely, whereas for #DIST_L2 (Euclidean distance) the distance can be calculated only with a relative error (a <code> 5\times 5 </code> mask gives more accurate results). For <code>a</code>,<code>b</code>, and <code>c</code>, OpenCV uses the values suggested in the original paper:</p><ul><li>DIST_L1: <code>a = 1, b = 2</code></li><li>DIST_L2:</li><li><code>3 x 3</code>: <code>a=0.955, b=1.3693</code></li><li><code>5 x 5</code>: <code>a=1, b=1.4, c=2.1969</code></li><li>DIST_C: <code>a = 1, b = 1</code></li></ul><p>Typically, for a fast, coarse distance estimation #DIST_L2, a <code> 3\times 3 </code> mask is used. For a more accurate distance estimation #DIST_L2, a <code> 5\times 5 </code> mask or the precise algorithm is used. Note that both the precise and the approximate algorithms are linear on the number of pixels.</p><p>This variant of the function does not only compute the minimum distance for each pixel <code> (x, y) </code> but also identifies the nearest connected component consisting of zero pixels (labelType==#DIST_LABEL_CCOMP) or the nearest zero pixel (labelType==#DIST_LABEL_PIXEL). Index of the component/pixel is stored in <code>labels(x, y)</code>. When labelType==#DIST_LABEL_CCOMP, the function automatically finds connected components of zero pixels in the input image and marks them with distinct labels. When labelType==#DIST_LABEL_PIXEL, the function scans through the input image and marks all the zero pixels with distinct labels.</p><p>In this mode, the complexity is still linear. That is, the function provides a very fast way to compute the Voronoi diagram for a binary image. Currently, the second variant can use only the approximate distance transform algorithm, i.e. maskSize=#DIST_MASK_PRECISE is not supported yet.</p><ul><li>Parameter: <code>src</code>: 8-bit, single-channel (binary) source image.</li><li>Parameter: <code>dst</code>: Output image with calculated distances. It is a 8-bit or 32-bit floating-point, single-channel image of the same size as src.</li><li>Parameter: <code>labels</code>: Output 2D array of labels (the discrete Voronoi diagram). It has the type CV_32SC1 and the same size as src.</li><li>Parameter: <code>distance_type</code>: Type of distance, see #DistanceTypes</li><li>Parameter: <code>mask_size</code>: Size of the distance transform mask, see #DistanceTransformMasks. #DIST_MASK_PRECISE is not supported by this variant. In case of the #DIST_L1 or #DIST_C distance type, the parameter is forced to 3 because a <code> 3\times 3 </code> mask gives the same result as <code> 5\times
5 </code> or any larger aperture.</li><li>Parameter: <code>label_type</code>: Type of the label array to build, see #DistanceTransformLabelTypes.</li></ul></dd></dl><dl><dt class="spec value" id="val-distance_transform2"><a href="#val-distance_transform2" class="anchor"></a><code><span class="keyword">val</span> distance_transform2 : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;dst_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>distance_transform2 ?dst ?dst_type src distance_type mask_size</code></p><ul><li>Parameter: <code>src</code>: 8-bit, single-channel (binary) source image.</li><li>Parameter: <code>dst</code>: Output image with calculated distances. It is a 8-bit or 32-bit floating-point, single-channel image of the same size as src .</li><li>Parameter: <code>distance_type</code>: Type of distance, see #DistanceTypes</li><li>Parameter: <code>mask_size</code>: Size of the distance transform mask, see #DistanceTransformMasks. In case of the #DIST_L1 or #DIST_C distance type, the parameter is forced to 3 because a <code> 3\times 3 </code> mask gives the same result as <code> 5\times 5 </code> or any larger aperture.</li><li>Parameter: <code>dst_type</code>: Type of output image. It can be CV_8U or CV_32F. Type CV_8U can be used only for the first variant of the function and distanceType == #DIST_L1.</li></ul></dd></dl><dl><dt class="spec value" id="val-flood_fill"><a href="#val-flood_fill" class="anchor"></a><code><span class="keyword">val</span> flood_fill : <span>?&#8288;rect:<a href="index.html#type-rect2i">rect2i</a></span> <span>&#45;&gt;</span> <span>?&#8288;lo_diff:<a href="Scalar/index.html#type-t">Scalar.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;up_diff:<a href="Scalar/index.html#type-t">Scalar.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;flags:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-point2i">point2i</a> <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Usage: <code>flood_fill ?rect ?lo_diff ?up_diff ?flags image mask seed_point new_val</code></p><p>Fills a connected component with the given color.</p><p>The function cv::floodFill fills a connected component starting from the seed point with the specified color. The connectivity is determined by the color/brightness closeness of the neighbor pixels. The pixel at <code> (x,y) </code> is considered to belong to the repainted domain if:</p><ul><li>in case of a grayscale image and floating range <code> \texttt{src} (x',y')- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} (x',y')+ \texttt{upDiff} </code></li></ul><ul><li>in case of a grayscale image and fixed range <code> \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)- \texttt{loDiff} \leq \texttt{src} (x,y)  \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)+ \texttt{upDiff} </code></li></ul><ul><li>in case of a color image and floating range <code> \texttt{src} (x',y')_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} (x',y')_r+ \texttt{upDiff} _r, </code> <code> \texttt{src} (x',y')_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} (x',y')_g+ \texttt{upDiff} _g </code> and <code> \texttt{src} (x',y')_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} (x',y')_b+ \texttt{upDiff} _b </code></li></ul><ul><li>in case of a color image and fixed range <code> \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r- \texttt{loDiff} _r \leq \texttt{src} (x,y)_r \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_r+ \texttt{upDiff} _r, </code> <code> \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g- \texttt{loDiff} _g \leq \texttt{src} (x,y)_g \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_g+ \texttt{upDiff} _g </code> and <code> \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b- \texttt{loDiff} _b \leq \texttt{src} (x,y)_b \leq \texttt{src} ( \texttt{seedPoint} .x, \texttt{seedPoint} .y)_b+ \texttt{upDiff} _b </code></li></ul><p>where <code> src(x',y') </code> is the value of one of pixel neighbors that is already known to belong to the component. That is, to be added to the connected component, a color/brightness of the pixel should be close enough to:</p><ul><li>Color/brightness of one of its neighbors that already belong to the connected component in case of a floating range.</li><li>Color/brightness of the seed point in case of a fixed range.</li></ul><p>Use these functions to either mark a connected component with the specified color in-place, or build a mask and then extract the contour, or copy the region to another image, and so on.</p><ul><li>Parameter: <code>image</code>: Input/output 1- or 3-channel, 8-bit, or floating-point image. It is modified by the function unless the #FLOODFILL_MASK_ONLY flag is set in the second variant of the function. See the details below.</li><li>Parameter: <code>mask</code>: Operation mask that should be a single-channel 8-bit image, 2 pixels wider and 2 pixels taller than image. Since this is both an input and output parameter, you must take responsibility of initializing it. Flood-filling cannot go across non-zero pixels in the input mask. For example, an edge detector output can be used as a mask to stop filling at edges. On output, pixels in the mask corresponding to filled pixels in the image are set to 1 or to the a value specified in flags as described below. Additionally, the function fills the border of the mask with ones to simplify internal processing. It is therefore possible to use the same mask in multiple calls to the function to make sure the filled areas do not overlap.</li><li>Parameter: <code>seed_point</code>: Starting point.</li><li>Parameter: <code>new_val</code>: New value of the repainted domain pixels.</li><li>Parameter: <code>lo_diff</code>: Maximal lower brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component.</li><li>Parameter: <code>up_diff</code>: Maximal upper brightness/color difference between the currently observed pixel and one of its neighbors belonging to the component, or a seed pixel being added to the component.</li><li>Parameter: <code>rect</code>: Optional output parameter set by the function to the minimum bounding rectangle of the repainted domain.</li><li>Parameter: <code>flags</code>: Operation flags. The first 8 bits contain a connectivity value. The default value of 4 means that only the four nearest neighbor pixels (those that share an edge) are considered. A connectivity value of 8 means that the eight nearest neighbor pixels (those that share a corner) will be considered. The next 8 bits (8-16) contain a value between 1 and 255 with which to fill the mask (the default value is 1). For example, 4 | ( 255 \&lt;\&lt; 8 ) will consider 4 nearest neighbours and fill the mask with a value of 255. The following additional options occupy higher bits and therefore may be further combined with the connectivity and mask fill values using bit-wise or (|), see #FloodFillFlags.</li></ul><p>Note: Since the mask is larger than the filled image, a pixel <code> (x, y) </code> in image corresponds to the pixel <code> (x+1, y+1) </code> in the mask .</p><p>See also: findContours</p></dd></dl><dl><dt class="spec value" id="val-cvt_color"><a href="#val-cvt_color" class="anchor"></a><code><span class="keyword">val</span> cvt_color : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;dst_cn:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>cvt_color ?dst ?dst_cn src code</code></p><p>Converts an image from one color space to another.</p><p>The function converts an input image from one color space to another. In case of a transformation to-from RGB color space, the order of the channels should be specified explicitly (RGB or BGR). Note that the default color format in OpenCV is often referred to as RGB but it is actually BGR (the bytes are reversed). So the first byte in a standard (24-bit) color image will be an 8-bit Blue component, the second byte will be Green, and the third byte will be Red. The fourth, fifth, and sixth bytes would then be the second pixel (Blue, then Green, then Red), and so on.</p><p>The conventional ranges for R, G, and B channel values are:</p><ul><li>0 to 255 for CV_8U images</li><li>0 to 65535 for CV_16U images</li><li>0 to 1 for CV_32F images</li></ul><p>In case of linear transformations, the range does not matter. But in case of a non-linear transformation, an input RGB image should be normalized to the proper value range to get the correct results, for example, for RGB <code> \rightarrow </code> L\*u\*v\* transformation. For example, if you have a 32-bit floating-point image directly converted from an 8-bit image without any scaling, then it will have the 0..255 value range instead of 0..1 assumed by the function. So, before calling #cvtColor , you need first to scale the image down:</p><pre><code class="ml">img *= 1./255;
cvtColor(img, img, COLOR_BGR2Luv);</code></pre><p>If you use #cvtColor with 8-bit images, the conversion will have some information lost. For many applications, this will not be noticeable but it is recommended to use 32-bit images in applications that need the full range of colors or that convert an image before an operation and then convert back.</p><p>If conversion adds the alpha channel, its value will set to the maximum of corresponding channel range: 255 for CV_8U, 65535 for CV_16U, 1 for CV_32F.</p><ul><li>Parameter: <code>src</code>: input image: 8-bit unsigned, 16-bit unsigned ( CV_16UC... ), or single-precision floating-point.</li><li>Parameter: <code>dst</code>: output image of the same size and depth as src.</li><li>Parameter: <code>code</code>: color space conversion code (see #ColorConversionCodes).</li><li>Parameter: <code>dst_cn</code>: number of channels in the destination image; if the parameter is 0, the number of the channels is derived automatically from src and code.</li></ul><p>See also imgproc_color_conversions</p></dd></dl><dl><dt class="spec value" id="val-cvt_color_two_plane"><a href="#val-cvt_color_two_plane" class="anchor"></a><code><span class="keyword">val</span> cvt_color_two_plane : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>cvt_color_two_plane ?dst src1 src2 code</code></p><p>Converts an image from one color space to another where the source image is stored in two planes.</p><p>This function only supports YUV420 to RGB conversion as of now.</p><ul><li>Parameter: <code>src1</code>:: 8-bit image (#CV_8U) of the Y plane.</li><li>Parameter: <code>src2</code>:: image containing interleaved U/V plane.</li><li>Parameter: <code>dst</code>:: output image.</li><li>Parameter: <code>code</code>:: Specifies the type of conversion. It can take any of the following values:</li><li>#COLOR_YUV2BGR_NV12</li><li>#COLOR_YUV2RGB_NV12</li><li>#COLOR_YUV2BGRA_NV12</li><li>#COLOR_YUV2RGBA_NV12</li><li>#COLOR_YUV2BGR_NV21</li><li>#COLOR_YUV2RGB_NV21</li><li>#COLOR_YUV2BGRA_NV21</li><li>#COLOR_YUV2RGBA_NV21</li></ul></dd></dl><dl><dt class="spec value" id="val-demosaicing"><a href="#val-demosaicing" class="anchor"></a><code><span class="keyword">val</span> demosaicing : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;dst_cn:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>demosaicing ?dst ?dst_cn src code</code></p><p>main function for all demosaicing processes</p><ul><li>Parameter: <code>src</code>: input image: 8-bit unsigned or 16-bit unsigned.</li><li>Parameter: <code>dst</code>: output image of the same size and depth as src.</li><li>Parameter: <code>code</code>: Color space conversion code (see the description below).</li><li>Parameter: <code>dst_cn</code>: number of channels in the destination image; if the parameter is 0, the number of the channels is derived automatically from src and code.</li></ul><p>The function can do the following transformations:</p><ul><li>Demosaicing using bilinear interpolation</li></ul><p>#COLOR_BayerBG2BGR , #COLOR_BayerGB2BGR , #COLOR_BayerRG2BGR , #COLOR_BayerGR2BGR</p><p>#COLOR_BayerBG2GRAY , #COLOR_BayerGB2GRAY , #COLOR_BayerRG2GRAY , #COLOR_BayerGR2GRAY</p><ul><li>Demosaicing using Variable Number of Gradients.</li></ul><p>#COLOR_BayerBG2BGR_VNG , #COLOR_BayerGB2BGR_VNG , #COLOR_BayerRG2BGR_VNG , #COLOR_BayerGR2BGR_VNG</p><ul><li>Edge-Aware Demosaicing.</li></ul><p>#COLOR_BayerBG2BGR_EA , #COLOR_BayerGB2BGR_EA , #COLOR_BayerRG2BGR_EA , #COLOR_BayerGR2BGR_EA</p><ul><li>Demosaicing with alpha channel</li></ul><p>#COLOR_BayerBG2BGRA , #COLOR_BayerGB2BGRA , #COLOR_BayerRG2BGRA , #COLOR_BayerGR2BGRA</p><p>See also: cvtColor</p></dd></dl><dl><dt class="spec value" id="val-match_template"><a href="#val-match_template" class="anchor"></a><code><span class="keyword">val</span> match_template : <span>?&#8288;result:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;mask:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>match_template ?result ?mask image templ cv_method</code></p><p>Compares a template against overlapped image regions.</p><p>The function slides through image , compares the overlapped patches of size <code> w \times h </code> against templ using the specified method and stores the comparison results in result . #TemplateMatchModes describes the formulae for the available comparison methods ( <code> I </code> denotes image, <code> T </code> template, <code> R </code> result, <code> M </code> the optional mask ). The summation is done over template and/or the image patch: <code> x' = 0...w-1, y' = 0...h-1 </code></p><p>After the function finishes the comparison, the best matches can be found as global minimums (when #TM_SQDIFF was used) or maximums (when #TM_CCORR or #TM_CCOEFF was used) using the #minMaxLoc function. In case of a color image, template summation in the numerator and each sum in the denominator is done over all of the channels and separate mean values are used for each channel. That is, the function can take a color template and a color image. The result will still be a single-channel image, which is easier to analyze.</p><ul><li>Parameter: <code>image</code>: Image where the search is running. It must be 8-bit or 32-bit floating-point.</li><li>Parameter: <code>templ</code>: Searched template. It must be not greater than the source image and have the same data type.</li><li>Parameter: <code>result</code>: Map of comparison results. It must be single-channel 32-bit floating-point. If image is <code> W \times H </code> and templ is <code> w \times h </code> , then result is <code> (W-w+1) \times (H-h+1) </code> .</li><li>Parameter: <code>cv_method</code>: Parameter specifying the comparison method, see #TemplateMatchModes</li><li>Parameter: <code>mask</code>: Optional mask. It must have the same size as templ. It must either have the same number of channels as template or only one channel, which is then used for all template and image channels. If the data type is #CV_8U, the mask is interpreted as a binary mask, meaning only elements where mask is nonzero are used and are kept unchanged independent of the actual mask value (weight equals 1). For data tpye #CV_32F, the mask values are used as weights. The exact formulas are documented in #TemplateMatchModes.</li></ul></dd></dl><dl><dt class="spec value" id="val-connected_components1"><a href="#val-connected_components1" class="anchor"></a><code><span class="keyword">val</span> connected_components1 : <span>?&#8288;labels:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * int</code></dt><dd><p>Usage: <code>connected_components1 ?labels image connectivity ltype ccltype</code></p><p>computes the connected components labeled image of boolean image</p><p>image with 4 or 8 way connectivity - returns N, the total number of labels <code>0, N-1</code> where 0 represents the background label. ltype specifies the output label image type, an important consideration based on the total number of labels or alternatively the total number of pixels in the source image. ccltype specifies the connected components labeling algorithm to use, currently Grana (BBDT) and Wu's (SAUF) Wu2009 algorithms are supported, see the #ConnectedComponentsAlgorithmsTypes for details. Note that SAUF algorithm forces a row major ordering of labels while BBDT does not. This function uses parallel version of both Grana and Wu's algorithms if at least one allowed parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.</p><ul><li>Parameter: <code>image</code>: the 8-bit single-channel image to be labeled</li><li>Parameter: <code>labels</code>: destination labeled image</li><li>Parameter: <code>connectivity</code>: 8 or 4 for 8-way or 4-way connectivity respectively</li><li>Parameter: <code>ltype</code>: output image label type. Currently CV_32S and CV_16U are supported.</li><li>Parameter: <code>ccltype</code>: connected components algorithm type (see the #ConnectedComponentsAlgorithmsTypes).</li></ul></dd></dl><dl><dt class="spec value" id="val-connected_components2"><a href="#val-connected_components2" class="anchor"></a><code><span class="keyword">val</span> connected_components2 : <span>?&#8288;labels:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;connectivity:int</span> <span>&#45;&gt;</span> <span>?&#8288;ltype:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * int</code></dt><dd><p>Usage: <code>connected_components2 ?labels ?connectivity ?ltype image</code></p><ul><li>Parameter: <code>image</code>: the 8-bit single-channel image to be labeled</li><li>Parameter: <code>labels</code>: destination labeled image</li><li>Parameter: <code>connectivity</code>: 8 or 4 for 8-way or 4-way connectivity respectively</li><li>Parameter: <code>ltype</code>: output image label type. Currently CV_32S and CV_16U are supported.</li></ul></dd></dl><dl><dt class="spec value" id="val-connected_components_with_stats1"><a href="#val-connected_components_with_stats1" class="anchor"></a><code><span class="keyword">val</span> connected_components_with_stats1 : <span>?&#8288;labels:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;stats:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;centroids:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a> * int</code></dt><dd><p>Usage: <code>connected_components_with_stats1 ?labels ?stats ?centroids image connectivity ltype ccltype</code></p><p>computes the connected components labeled image of boolean image and also produces a statistics output for each label</p><p>image with 4 or 8 way connectivity - returns N, the total number of labels <code>0, N-1</code> where 0 represents the background label. ltype specifies the output label image type, an important consideration based on the total number of labels or alternatively the total number of pixels in the source image. ccltype specifies the connected components labeling algorithm to use, currently Grana's (BBDT) and Wu's (SAUF) Wu2009 algorithms are supported, see the #ConnectedComponentsAlgorithmsTypes for details. Note that SAUF algorithm forces a row major ordering of labels while BBDT does not. This function uses parallel version of both Grana and Wu's algorithms (statistics included) if at least one allowed parallel framework is enabled and if the rows of the image are at least twice the number returned by #getNumberOfCPUs.</p><ul><li>Parameter: <code>image</code>: the 8-bit single-channel image to be labeled</li><li>Parameter: <code>labels</code>: destination labeled image</li><li>Parameter: <code>stats</code>: statistics output for each label, including the background label. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S.</li><li>Parameter: <code>centroids</code>: centroid output for each label, including the background label. Centroids are accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.</li><li>Parameter: <code>connectivity</code>: 8 or 4 for 8-way or 4-way connectivity respectively</li><li>Parameter: <code>ltype</code>: output image label type. Currently CV_32S and CV_16U are supported.</li><li>Parameter: <code>ccltype</code>: connected components algorithm type (see #ConnectedComponentsAlgorithmsTypes).</li></ul></dd></dl><dl><dt class="spec value" id="val-connected_components_with_stats2"><a href="#val-connected_components_with_stats2" class="anchor"></a><code><span class="keyword">val</span> connected_components_with_stats2 : <span>?&#8288;labels:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;stats:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;centroids:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;connectivity:int</span> <span>&#45;&gt;</span> <span>?&#8288;ltype:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a> * <a href="Cvdata/index.html#type-t">Cvdata.t</a> * int</code></dt><dd><p>Usage: <code>connected_components_with_stats2 ?labels ?stats ?centroids ?connectivity ?ltype image</code></p><ul><li>Parameter: <code>image</code>: the 8-bit single-channel image to be labeled</li><li>Parameter: <code>labels</code>: destination labeled image</li><li>Parameter: <code>stats</code>: statistics output for each label, including the background label. Statistics are accessed via stats(label, COLUMN) where COLUMN is one of #ConnectedComponentsTypes, selecting the statistic. The data type is CV_32S.</li><li>Parameter: <code>centroids</code>: centroid output for each label, including the background label. Centroids are accessed via centroids(label, 0) for x and centroids(label, 1) for y. The data type CV_64F.</li><li>Parameter: <code>connectivity</code>: 8 or 4 for 8-way or 4-way connectivity respectively</li><li>Parameter: <code>ltype</code>: output image label type. Currently CV_32S and CV_16U are supported.</li></ul></dd></dl><dl><dt class="spec value" id="val-find_contours"><a href="#val-find_contours" class="anchor"></a><code><span class="keyword">val</span> find_contours : <span>?&#8288;contours:<span><span><a href="Cvdata/index.html#type-t">Cvdata.t</a> list</span> Stdlib.ref</span></span> <span>&#45;&gt;</span> <span>?&#8288;hierarchy:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;offset:<a href="index.html#type-point2i">point2i</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><a href="Cvdata/index.html#type-t">Cvdata.t</a> list</span> * <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>find_contours ?contours ?hierarchy ?offset image mode cv_method</code></p><p>Finds contours in a binary image.</p><p>The function retrieves contours from the binary image using the algorithm Suzuki85 . The contours are a useful tool for shape analysis and object detection and recognition. See squares.cpp in the OpenCV sample directory. Note: Since opencv 3.2 source image is not modified by this function.</p><ul><li>Parameter: <code>image</code>: Source, an 8-bit single-channel image. Non-zero pixels are treated as 1's. Zero pixels remain 0's, so the image is treated as binary . You can use #compare, #inRange, #threshold , #adaptiveThreshold, #Canny, and others to create a binary image out of a grayscale or color one. If mode equals to #RETR_CCOMP or #RETR_FLOODFILL, the input can also be a 32-bit integer image of labels (CV_32SC1).</li><li>Parameter: <code>contours</code>: Detected contours. Each contour is stored as a vector of points (e.g. std::vector&lt;std::vector&lt;cv::Point&gt; &gt;).</li><li>Parameter: <code>hierarchy</code>: Optional output vector (e.g. std::vector&lt;cv::Vec4i&gt;), containing information about the image topology. It has as many elements as the number of contours. For each i-th contour contours<code>i</code>, the elements hierarchy<code>i</code><code>0</code> , hierarchy<code>i</code><code>1</code> , hierarchy<code>i</code><code>2</code> , and hierarchy<code>i</code><code>3</code> are set to 0-based indices in contours of the next and previous contours at the same hierarchical level, the first child contour and the parent contour, respectively. If for the contour i there are no next, previous, parent, or nested contours, the corresponding elements of hierarchy<code>i</code> will be negative.</li><li>Parameter: <code>mode</code>: Contour retrieval mode, see #RetrievalModes</li><li>Parameter: <code>cv_method</code>: Contour approximation method, see #ContourApproximationModes</li><li>Parameter: <code>offset</code>: Optional offset by which every contour point is shifted. This is useful if the contours are extracted from the image ROI and then they should be analyzed in the whole image context.</li></ul></dd></dl><dl><dt class="spec value" id="val-approx_poly_dp"><a href="#val-approx_poly_dp" class="anchor"></a><code><span class="keyword">val</span> approx_poly_dp : <span>?&#8288;approx_curve:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>approx_poly_dp ?approx_curve curve epsilon closed</code></p><p>Approximates a polygonal curve(s) with the specified precision.</p><p>The function cv::approxPolyDP approximates a curve or a polygon with another curve/polygon with less vertices so that the distance between them is less or equal to the specified precision. It uses the Douglas-Peucker algorithm &lt;http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm&gt;</p><ul><li>Parameter: <code>curve</code>: Input vector of a 2D point stored in std::vector or Mat</li><li>Parameter: <code>approx_curve</code>: Result of the approximation. The type should match the type of the input curve.</li><li>Parameter: <code>epsilon</code>: Parameter specifying the approximation accuracy. This is the maximum distance between the original curve and its approximation.</li><li>Parameter: <code>closed</code>: If true, the approximated curve is closed (its first and last vertices are connected). Otherwise, it is not closed.</li></ul></dd></dl><dl><dt class="spec value" id="val-arc_length"><a href="#val-arc_length" class="anchor"></a><code><span class="keyword">val</span> arc_length : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> float</code></dt><dd><p>Usage: <code>arc_length curve closed</code></p><p>Calculates a contour perimeter or a curve length.</p><p>The function computes a curve length or a closed contour perimeter.</p><ul><li>Parameter: <code>curve</code>: Input vector of 2D points, stored in std::vector or Mat.</li><li>Parameter: <code>closed</code>: Flag indicating whether the curve is closed or not.</li></ul></dd></dl><dl><dt class="spec value" id="val-bounding_rect"><a href="#val-bounding_rect" class="anchor"></a><code><span class="keyword">val</span> bounding_rect : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-rect2i">rect2i</a></code></dt><dd><p>Usage: <code>bounding_rect array</code></p><p>Calculates the up-right bounding rectangle of a point set or non-zero pixels of gray-scale image.</p><p>The function calculates and returns the minimal up-right bounding rectangle for the specified point set or non-zero pixels of gray-scale image.</p><ul><li>Parameter: <code>array</code>: Input gray-scale image or 2D point set, stored in std::vector or Mat.</li></ul></dd></dl><dl><dt class="spec value" id="val-contour_area"><a href="#val-contour_area" class="anchor"></a><code><span class="keyword">val</span> contour_area : <span>?&#8288;oriented:bool</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> float</code></dt><dd><p>Usage: <code>contour_area ?oriented contour</code></p><p>Calculates a contour area.</p><p>The function computes a contour area. Similarly to moments , the area is computed using the Green formula. Thus, the returned area and the number of non-zero pixels, if you draw the contour using #drawContours or #fillPoly , can be different. Also, the function will most certainly give a wrong results for contours with self-intersections.</p><p>Example:</p><pre><code class="ml">vector&lt;Point&gt; contour;
contour.push_back(Point2f(0, 0));
contour.push_back(Point2f(10, 0));
contour.push_back(Point2f(10, 10));
contour.push_back(Point2f(5, 4));

double area0 = contourArea(contour);
vector&lt;Point&gt; approx;
approxPolyDP(contour, approx, 5, true);
double area1 = contourArea(approx);

cout &lt;&lt; &quot;area0 =&quot; &lt;&lt; area0 &lt;&lt; endl &lt;&lt;
        &quot;area1 =&quot; &lt;&lt; area1 &lt;&lt; endl &lt;&lt;
        &quot;approx poly vertices&quot; &lt;&lt; approx.size() &lt;&lt; endl;</code></pre><ul><li>Parameter: <code>contour</code>: Input vector of 2D points (contour vertices), stored in std::vector or Mat.</li><li>Parameter: <code>oriented</code>: Oriented area flag. If it is true, the function returns a signed area value, depending on the contour orientation (clockwise or counter-clockwise). Using this feature you can determine orientation of a contour by taking the sign of an area. By default, the parameter is false, which means that the absolute value is returned.</li></ul></dd></dl><dl><dt class="spec value" id="val-min_area_rect"><a href="#val-min_area_rect" class="anchor"></a><code><span class="keyword">val</span> min_area_rect : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-rotated_rect">rotated_rect</a></code></dt><dd><p>Usage: <code>min_area_rect points</code></p><p>Finds a rotated rectangle of the minimum area enclosing the input 2D point set.</p><p>The function calculates and returns the minimum-area bounding rectangle (possibly rotated) for a specified point set. Developer should keep in mind that the returned RotatedRect can contain negative indices when data is close to the containing Mat element boundary.</p><ul><li>Parameter: <code>points</code>: Input vector of 2D points, stored in std::vector\&lt;\&gt; or Mat</li></ul></dd></dl><dl><dt class="spec value" id="val-box_points"><a href="#val-box_points" class="anchor"></a><code><span class="keyword">val</span> box_points : <span>?&#8288;points:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-rotated_rect">rotated_rect</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>box_points ?points box</code></p><p>Finds the four vertices of a rotated rect. Useful to draw the rotated rectangle.</p><p>The function finds the four vertices of a rotated rectangle. This function is useful to draw the rectangle. In C++, instead of using this function, you can directly use RotatedRect::points method. Please visit the tutorial_bounding_rotated_ellipses &quot;tutorial on Creating Bounding rotated boxes and ellipses for contours&quot; for more information.</p><ul><li>Parameter: <code>box</code>: The input rotated rectangle. It may be the output of</li><li>Parameter: <code>points</code>: The output array of four vertices of rectangles.</li></ul></dd></dl><dl><dt class="spec value" id="val-min_enclosing_circle"><a href="#val-min_enclosing_circle" class="anchor"></a><code><span class="keyword">val</span> min_enclosing_circle : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-point2f">point2f</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>min_enclosing_circle points center radius</code></p><p>Finds a circle of the minimum area enclosing a 2D point set.</p><p>The function finds the minimal enclosing circle of a 2D point set using an iterative algorithm.</p><ul><li>Parameter: <code>points</code>: Input vector of 2D points, stored in std::vector\&lt;\&gt; or Mat</li><li>Parameter: <code>center</code>: Output center of the circle.</li><li>Parameter: <code>radius</code>: Output radius of the circle.</li></ul></dd></dl><dl><dt class="spec value" id="val-min_enclosing_triangle"><a href="#val-min_enclosing_triangle" class="anchor"></a><code><span class="keyword">val</span> min_enclosing_triangle : <span>?&#8288;triangle:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * float</code></dt><dd><p>Usage: <code>min_enclosing_triangle ?triangle points</code></p><p>Finds a triangle of minimum area enclosing a 2D point set and returns its area.</p><p>The function finds a triangle of minimum area enclosing the given set of 2D points and returns its area. The output for a given 2D point set is shown in the image below. 2D points are depicted in *red* and the enclosing triangle in *yellow*.</p><p>!<code>Sample output of the minimum enclosing triangle function</code>(pics/minenclosingtriangle.png)</p><p>The implementation of the algorithm is based on O'Rourke's ORourke86 and Klee and Laskowski's KleeLaskowski85 papers. O'Rourke provides a <code> \theta(n) </code> algorithm for finding the minimal enclosing triangle of a 2D convex polygon with n vertices. Since the #minEnclosingTriangle function takes a 2D point set as input an additional preprocessing step of computing the convex hull of the 2D point set is required. The complexity of the #convexHull function is <code> O(n log(n)) </code> which is higher than <code> \theta(n) </code>. Thus the overall complexity of the function is <code> O(n log(n)) </code>.</p><ul><li>Parameter: <code>points</code>: Input vector of 2D points with depth CV_32S or CV_32F, stored in std::vector\&lt;\&gt; or Mat</li><li>Parameter: <code>triangle</code>: Output vector of three 2D points defining the vertices of the triangle. The depth of the OutputArray must be CV_32F.</li></ul></dd></dl><dl><dt class="spec value" id="val-match_shapes"><a href="#val-match_shapes" class="anchor"></a><code><span class="keyword">val</span> match_shapes : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float</code></dt><dd><p>Usage: <code>match_shapes contour1 contour2 cv_method parameter</code></p><p>Compares two shapes.</p><p>The function compares two shapes. All three implemented methods use the Hu invariants (see #HuMoments)</p><ul><li>Parameter: <code>contour1</code>: First contour or grayscale image.</li><li>Parameter: <code>contour2</code>: Second contour or grayscale image.</li><li>Parameter: <code>cv_method</code>: Comparison method, see #ShapeMatchModes</li><li>Parameter: <code>parameter</code>: Method-specific parameter (not supported now).</li></ul></dd></dl><dl><dt class="spec value" id="val-convex_hull"><a href="#val-convex_hull" class="anchor"></a><code><span class="keyword">val</span> convex_hull : <span>?&#8288;hull:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;clockwise:bool</span> <span>&#45;&gt;</span> <span>?&#8288;return_points:bool</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>convex_hull ?hull ?clockwise ?return_points points</code></p><p>Finds the convex hull of a point set.</p><p>The function cv::convexHull finds the convex hull of a 2D point set using the Sklansky's algorithm Sklansky82 that has *O(N logN)* complexity in the current implementation.</p><ul><li>Parameter: <code>points</code>: Input 2D point set, stored in std::vector or Mat.</li><li>Parameter: <code>hull</code>: Output convex hull. It is either an integer vector of indices or vector of points. In the first case, the hull elements are 0-based indices of the convex hull points in the original array (since the set of convex hull points is a subset of the original point set). In the second case, hull elements are the convex hull points themselves.</li><li>Parameter: <code>clockwise</code>: Orientation flag. If it is true, the output convex hull is oriented clockwise. Otherwise, it is oriented counter-clockwise. The assumed coordinate system has its X axis pointing to the right, and its Y axis pointing upwards.</li><li>Parameter: <code>return_points</code>: Operation flag. In case of a matrix, when the flag is true, the function returns convex hull points. Otherwise, it returns indices of the convex hull points. When the output array is std::vector, the flag is ignored, and the output depends on the type of the vector: std::vector\&lt;int\&gt; implies returnPoints=false, std::vector\&lt;Point\&gt; implies returnPoints=true.</li></ul><p>Note: <code>points</code> and <code>hull</code> should be different arrays, inplace processing isn't supported.</p><p>Check tutorial_hull &quot;the corresponding tutorial&quot; for more details.</p><p>useful links:</p><p>https://www.learnopencv.com/convex-hull-using-opencv-in-python-and-c/</p></dd></dl><dl><dt class="spec value" id="val-convexity_defects"><a href="#val-convexity_defects" class="anchor"></a><code><span class="keyword">val</span> convexity_defects : <span>?&#8288;convexity_defects:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>convexity_defects ?convexity_defects contour convexhull</code></p><p>Finds the convexity defects of a contour.</p><p>The figure below displays convexity defects of a hand contour:</p><p>!<code>image</code>(pics/defects.png)</p><ul><li>Parameter: <code>contour</code>: Input contour.</li><li>Parameter: <code>convexhull</code>: Convex hull obtained using convexHull that should contain indices of the contour points that make the hull.</li><li>Parameter: <code>convexity_defects</code>: The output vector of convexity defects. In C++ and the new Python/Java interface each convexity defect is represented as 4-element integer vector (a.k.a. #Vec4i): (start_index, end_index, farthest_pt_index, fixpt_depth), where indices are 0-based indices in the original contour of the convexity defect beginning, end and the farthest point, and fixpt_depth is fixed-point approximation (with 8 fractional bits) of the distance between the farthest contour point and the hull. That is, to get the floating-point value of the depth will be fixpt_depth/256.0.</li></ul></dd></dl><dl><dt class="spec value" id="val-is_contour_convex"><a href="#val-is_contour_convex" class="anchor"></a><code><span class="keyword">val</span> is_contour_convex : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Usage: <code>is_contour_convex contour</code></p><p>Tests a contour convexity.</p><p>The function tests whether the input contour is convex or not. The contour must be simple, that is, without self-intersections. Otherwise, the function output is undefined.</p><ul><li>Parameter: <code>contour</code>: Input vector of 2D points, stored in std::vector\&lt;\&gt; or Mat</li></ul></dd></dl><dl><dt class="spec value" id="val-intersect_convex_convex"><a href="#val-intersect_convex_convex" class="anchor"></a><code><span class="keyword">val</span> intersect_convex_convex : <span>?&#8288;_p12:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;handle_nested:bool</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * float</code></dt><dd><p>Usage: <code>intersect_convex_convex ?_p12 ?handle_nested _p1 _p2</code></p><p>Finds intersection of two convex polygons</p><ul><li>Parameter: <code>_p1</code>: First polygon</li><li>Parameter: <code>_p2</code>: Second polygon</li><li>Parameter: <code>_p12</code>: Output polygon describing the intersecting area</li><li>Parameter: <code>handle_nested</code>: When true, an intersection is found if one of the polygons is fully enclosed in the other. When false, no intersection is found. If the polygons share a side or the vertex of one polygon lies on an edge of the other, they are not considered nested and an intersection will be found regardless of the value of handleNested.</li></ul><ul><li>Returns: Absolute value of area of intersecting polygon</li></ul><p>Note: intersectConvexConvex doesn't confirm that both polygons are convex and will return invalid results if they aren't.</p></dd></dl><dl><dt class="spec value" id="val-fit_ellipse"><a href="#val-fit_ellipse" class="anchor"></a><code><span class="keyword">val</span> fit_ellipse : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-rotated_rect">rotated_rect</a></code></dt><dd><p>Usage: <code>fit_ellipse points</code></p><p>Fits an ellipse around a set of 2D points.</p><p>The function calculates the ellipse that fits (in a least-squares sense) a set of 2D points best of all. It returns the rotated rectangle in which the ellipse is inscribed. The first algorithm described by Fitzgibbon95 is used. Developer should keep in mind that it is possible that the returned ellipse/rotatedRect data contains negative indices, due to the data points being close to the border of the containing Mat element.</p><ul><li>Parameter: <code>points</code>: Input 2D point set, stored in std::vector\&lt;\&gt; or Mat</li></ul></dd></dl><dl><dt class="spec value" id="val-fit_ellipse_ams"><a href="#val-fit_ellipse_ams" class="anchor"></a><code><span class="keyword">val</span> fit_ellipse_ams : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-rotated_rect">rotated_rect</a></code></dt><dd><p>Usage: <code>fit_ellipse_ams points</code></p><p>Fits an ellipse around a set of 2D points.</p><p>The function calculates the ellipse that fits a set of 2D points. It returns the rotated rectangle in which the ellipse is inscribed. The Approximate Mean Square (AMS) proposed by Taubin1991 is used.</p><p>For an ellipse, this basis set is <code>  \chi= \left(x^2, x y, y^2, x, y, 1\right)  </code>, which is a set of six free coefficients <code>  A^T=\left\{A_{\text{xx}},A_{\text{xy}},A_{\text{yy}},A_x,A_y,A_0\right\}  </code>. However, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths <code>  (a,b)  </code>, the position <code>  (x_0,y_0)  </code>, and the orientation <code>  \theta  </code>. This is because the basis set includes lines, quadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits. If the fit is found to be a parabolic or hyperbolic function then the standard #fitEllipse method is used. The AMS method restricts the fit to parabolic, hyperbolic and elliptical curves by imposing the condition that <code>  A^T ( D_x^T D_x  +   D_y^T D_y) A = 1  </code> where the matrices <code>  Dx  </code> and <code>  Dy  </code> are the partial derivatives of the design matrix <code>  D  </code> with respect to x and y. The matrices are formed row by row applying the following to each of the points in the set: <code>)&amp;=\left\{x_i^2, x_i y_i, y_i^2, x_i, y_i, 1\right\} &amp;
 D_x(i,:)&amp;=\left\{2 x_i,y_i,0,1,0,0\right\} &amp;
 D_y(i,:)&amp;=\left\{0,x_i,2 y_i,0,1,0\right\}
  </code> The AMS method minimizes the cost function <code> {
 \epsilon ^2=\frac{ A^T D^T D A }{ A^T (D_x^T D_x +  D_y^T D_y) A^T }
  </code></p><p>The minimum cost is found by solving the generalized eigenvalue problem.</p><p><code> {
 D^T D A = \lambda  \left( D_x^T D_x +  D_y^T D_y\right) A
  </code></p><ul><li>Parameter: <code>points</code>: Input 2D point set, stored in std::vector\&lt;\&gt; or Mat</li></ul></dd></dl><dl><dt class="spec value" id="val-fit_ellipse_direct"><a href="#val-fit_ellipse_direct" class="anchor"></a><code><span class="keyword">val</span> fit_ellipse_direct : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-rotated_rect">rotated_rect</a></code></dt><dd><p>Usage: <code>fit_ellipse_direct points</code></p><p>Fits an ellipse around a set of 2D points.</p><p>The function calculates the ellipse that fits a set of 2D points. It returns the rotated rectangle in which the ellipse is inscribed. The Direct least square (Direct) method by Fitzgibbon1999 is used.</p><p>For an ellipse, this basis set is <code>  \chi= \left(x^2, x y, y^2, x, y, 1\right)  </code>, which is a set of six free coefficients <code>  A^T=\left\{A_{\text{xx}},A_{\text{xy}},A_{\text{yy}},A_x,A_y,A_0\right\}  </code>. However, to specify an ellipse, all that is needed is five numbers; the major and minor axes lengths <code>  (a,b)  </code>, the position <code>  (x_0,y_0)  </code>, and the orientation <code>  \theta  </code>. This is because the basis set includes lines, quadratics, parabolic and hyperbolic functions as well as elliptical functions as possible fits. The Direct method confines the fit to ellipses by ensuring that <code>  4 A_{xx} A_{yy}- A_{xy}^2 &gt; 0  </code>. The condition imposed is that <code>  4 A_{xx} A_{yy}- A_{xy}^2=1  </code> which satisfies the inequality and as the coefficients can be arbitrarily scaled is not overly restrictive.</p><p><code> {
 \epsilon ^2= A^T D^T D A \quad \text{with} \quad A^T C A =1 \quad \text{and} \quad C=\left(\begin{matrix}
 0 &amp; 0  &amp; 2  &amp; 0  &amp; 0  &amp;  0  \\
 0 &amp; -1  &amp; 0  &amp; 0  &amp; 0  &amp;  0 \\
 2 &amp; 0  &amp; 0  &amp; 0  &amp; 0  &amp;  0 \\
 0 &amp; 0  &amp; 0  &amp; 0  &amp; 0  &amp;  0 \\
 0 &amp; 0  &amp; 0  &amp; 0  &amp; 0  &amp;  0 \\
 0 &amp; 0  &amp; 0  &amp; 0  &amp; 0  &amp;  0
 \end{matrix} \right)
  </code></p><p>The minimum cost is found by solving the generalized eigenvalue problem.</p><p><code> {
 D^T D A = \lambda  \left( C\right) A
  </code></p><p>The system produces only one positive eigenvalue <code>  \lambda </code> which is chosen as the solution with its eigenvector <code> \mathbf{u} </code>. These are used to find the coefficients</p><p><code> {
 A = \sqrt{\frac{1}{\mathbf{u}^T C \mathbf{u}}}  \mathbf{u}
  </code> The scaling factor guarantees that <code> A^T C A =1 </code>.</p><ul><li>Parameter: <code>points</code>: Input 2D point set, stored in std::vector\&lt;\&gt; or Mat</li></ul></dd></dl><dl><dt class="spec value" id="val-fit_line"><a href="#val-fit_line" class="anchor"></a><code><span class="keyword">val</span> fit_line : <span>?&#8288;line:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>fit_line ?line points dist_type param reps aeps</code></p><p>Fits a line to a 2D or 3D point set.</p><p>The function fitLine fits a line to a 2D or 3D point set by minimizing <code> \sum_i \rho(r_i) </code> where <code> r_i </code> is a distance between the <code> i^{th} </code> point, the line and <code> \rho(r) </code> is a distance function, one of the following:</p><ul><li>DIST_L2 <code> \rho (r) = r^2/2  \quad \text{(the simplest and the fastest least-squares method)} </code></li><li>DIST_L1 <code> \rho (r) = r </code></li><li>DIST_L12 <code> \rho (r) = 2  \cdot ( \sqrt{1 + \frac{r^2}{2}} - 1) </code></li><li>DIST_FAIR <code> \rho \left (r \right ) = C^2  \cdot \left (  \frac{r}{C} -  \log{\left(1 + \frac{r}{C}\right)} \right )  \quad \text{where} \quad C=1.3998 </code></li><li>DIST_WELSCH <code> \rho \left (r \right ) =  \frac{C^2}{2} \cdot \left ( 1 -  \exp{\left(-\left(\frac{r}{C}\right)^2\right)} \right )  \quad \text{where} \quad C=2.9846 </code></li><li>DIST_HUBER <code> \rho (r) =  \fork{r^2/2}{if \(r &lt; C\)}{C \cdot (r-C/2)}{otherwise} \quad \text{where} \quad C=1.345 </code></li></ul><p>The algorithm is based on the M-estimator ( &lt;http://en.wikipedia.org/wiki/M-estimator&gt; ) technique that iteratively fits the line using the weighted least-squares algorithm. After each iteration the weights <code> w_i </code> are adjusted to be inversely proportional to <code> \rho(r_i) </code> .</p><ul><li>Parameter: <code>points</code>: Input vector of 2D or 3D points, stored in std::vector\&lt;\&gt; or Mat.</li><li>Parameter: <code>line</code>: Output line parameters. In case of 2D fitting, it should be a vector of 4 elements (like Vec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized vector collinear to the line and (x0, y0) is a point on the line. In case of 3D fitting, it should be a vector of 6 elements (like Vec6f) - (vx, vy, vz, x0, y0, z0), where (vx, vy, vz) is a normalized vector collinear to the line and (x0, y0, z0) is a point on the line.</li><li>Parameter: <code>dist_type</code>: Distance used by the M-estimator, see #DistanceTypes</li><li>Parameter: <code>param</code>: Numerical parameter ( C ) for some types of distances. If it is 0, an optimal value is chosen.</li><li>Parameter: <code>reps</code>: Sufficient accuracy for the radius (distance between the coordinate origin and the line).</li><li>Parameter: <code>aeps</code>: Sufficient accuracy for the angle. 0.01 would be a good default value for reps and aeps.</li></ul></dd></dl><dl><dt class="spec value" id="val-point_polygon_test"><a href="#val-point_polygon_test" class="anchor"></a><code><span class="keyword">val</span> point_polygon_test : <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-point2f">point2f</a> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> float</code></dt><dd><p>Usage: <code>point_polygon_test contour pt measure_dist</code></p><p>Performs a point-in-contour test.</p><p>The function determines whether the point is inside a contour, outside, or lies on an edge (or coincides with a vertex). It returns positive (inside), negative (outside), or zero (on an edge) value, correspondingly. When measureDist=false , the return value is +1, -1, and 0, respectively. Otherwise, the return value is a signed distance between the point and the nearest contour edge.</p><p>See below a sample output of the function where each image pixel is tested against the contour:</p><p>!<code>sample output</code>(pics/pointpolygon.png)</p><ul><li>Parameter: <code>contour</code>: Input contour.</li><li>Parameter: <code>pt</code>: Point tested against the contour.</li><li>Parameter: <code>measure_dist</code>: If true, the function estimates the signed distance from the point to the nearest contour edge. Otherwise, the function only checks if the point is inside a contour or not.</li></ul></dd></dl><dl><dt class="spec value" id="val-rotated_rectangle_intersection"><a href="#val-rotated_rectangle_intersection" class="anchor"></a><code><span class="keyword">val</span> rotated_rectangle_intersection : <span>?&#8288;intersecting_region:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="index.html#type-rotated_rect">rotated_rect</a> <span>&#45;&gt;</span> <a href="index.html#type-rotated_rect">rotated_rect</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> * int</code></dt><dd><p>Usage: <code>rotated_rectangle_intersection ?intersecting_region rect1 rect2</code></p><p>Finds out if there is any intersection between two rotated rectangles.</p><p>If there is then the vertices of the intersecting region are returned as well.</p><p>Below are some examples of intersection configurations. The hatched pattern indicates the intersecting region and the red vertices are returned by the function.</p><p>!<code>intersection examples</code>(pics/intersection.png)</p><ul><li>Parameter: <code>rect1</code>: First rectangle</li><li>Parameter: <code>rect2</code>: Second rectangle</li><li>Parameter: <code>intersecting_region</code>: The output array of the vertices of the intersecting region. It returns at most 8 vertices. Stored as std::vector\&lt;cv::Point2f\&gt; or cv::Mat as Mx1 of type CV_32FC2.</li><li>Returns: One of #RectanglesIntersectTypes</li></ul></dd></dl><dl><dt class="spec value" id="val-apply_color_map1"><a href="#val-apply_color_map1" class="anchor"></a><code><span class="keyword">val</span> apply_color_map1 : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>apply_color_map1 ?dst src colormap</code></p><p>Applies a GNU Octave/MATLAB equivalent colormap on a given image.</p><ul><li>Parameter: <code>src</code>: The source image, grayscale or colored of type CV_8UC1 or CV_8UC3.</li><li>Parameter: <code>dst</code>: The result is the colormapped source image. Note: Mat::create is called on dst.</li><li>Parameter: <code>colormap</code>: The colormap to apply, see #ColormapTypes</li></ul></dd></dl><dl><dt class="spec value" id="val-apply_color_map2"><a href="#val-apply_color_map2" class="anchor"></a><code><span class="keyword">val</span> apply_color_map2 : <span>?&#8288;dst:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a></code></dt><dd><p>Usage: <code>apply_color_map2 ?dst src user_color</code></p><p>Applies a user colormap on a given image.</p><ul><li>Parameter: <code>src</code>: The source image, grayscale or colored of type CV_8UC1 or CV_8UC3.</li><li>Parameter: <code>dst</code>: The result is the colormapped source image. Note: Mat::create is called on dst.</li><li>Parameter: <code>user_color</code>: The colormap to apply of type CV_8UC1 or CV_8UC3 and size 256</li></ul></dd></dl><dl><dt class="spec value" id="val-line"><a href="#val-line" class="anchor"></a><code><span class="keyword">val</span> line : <span>?&#8288;thickness:int</span> <span>&#45;&gt;</span> <span>?&#8288;line_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;shift:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-point2i">point2i</a> <span>&#45;&gt;</span> <a href="index.html#type-point2i">point2i</a> <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>line ?thickness ?line_type ?shift img pt1 pt2 color</code></p><p>Draws a line segment connecting two points.</p><p>The function line draws the line segment between pt1 and pt2 points in the image. The line is clipped by the image boundaries. For non-antialiased lines with integer coordinates, the 8-connected or 4-connected Bresenham algorithm is used. Thick lines are drawn with rounding endings. Antialiased lines are drawn using Gaussian filtering.</p><ul><li>Parameter: <code>img</code>: Image.</li><li>Parameter: <code>pt1</code>: First point of the line segment.</li><li>Parameter: <code>pt2</code>: Second point of the line segment.</li><li>Parameter: <code>color</code>: Line color.</li><li>Parameter: <code>thickness</code>: Line thickness.</li><li>Parameter: <code>line_type</code>: Type of the line. See #LineTypes.</li><li>Parameter: <code>shift</code>: Number of fractional bits in the point coordinates.</li></ul></dd></dl><dl><dt class="spec value" id="val-arrowed_line"><a href="#val-arrowed_line" class="anchor"></a><code><span class="keyword">val</span> arrowed_line : <span>?&#8288;thickness:int</span> <span>&#45;&gt;</span> <span>?&#8288;line_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;shift:int</span> <span>&#45;&gt;</span> <span>?&#8288;tip_length:float</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-point2i">point2i</a> <span>&#45;&gt;</span> <a href="index.html#type-point2i">point2i</a> <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>arrowed_line ?thickness ?line_type ?shift ?tip_length img pt1 pt2 color</code></p><p>Draws a arrow segment pointing from the first point to the second one.</p><p>The function cv::arrowedLine draws an arrow between pt1 and pt2 points in the image. See also #line.</p><ul><li>Parameter: <code>img</code>: Image.</li><li>Parameter: <code>pt1</code>: The point the arrow starts from.</li><li>Parameter: <code>pt2</code>: The point the arrow points to.</li><li>Parameter: <code>color</code>: Line color.</li><li>Parameter: <code>thickness</code>: Line thickness.</li><li>Parameter: <code>line_type</code>: Type of the line. See #LineTypes</li><li>Parameter: <code>shift</code>: Number of fractional bits in the point coordinates.</li><li>Parameter: <code>tip_length</code>: The length of the arrow tip in relation to the arrow length</li></ul></dd></dl><dl><dt class="spec value" id="val-rectangle1"><a href="#val-rectangle1" class="anchor"></a><code><span class="keyword">val</span> rectangle1 : <span>?&#8288;thickness:int</span> <span>&#45;&gt;</span> <span>?&#8288;line_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;shift:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-point2i">point2i</a> <span>&#45;&gt;</span> <a href="index.html#type-point2i">point2i</a> <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>rectangle1 ?thickness ?line_type ?shift img pt1 pt2 color</code></p><p>Draws a simple, thick, or filled up-right rectangle.</p><p>The function cv::rectangle draws a rectangle outline or a filled rectangle whose two opposite corners are pt1 and pt2.</p><ul><li>Parameter: <code>img</code>: Image.</li><li>Parameter: <code>pt1</code>: Vertex of the rectangle.</li><li>Parameter: <code>pt2</code>: Vertex of the rectangle opposite to pt1 .</li><li>Parameter: <code>color</code>: Rectangle color or brightness (grayscale image).</li><li>Parameter: <code>thickness</code>: Thickness of lines that make up the rectangle. Negative values, like #FILLED, mean that the function has to draw a filled rectangle.</li><li>Parameter: <code>line_type</code>: Type of the line. See #LineTypes</li><li>Parameter: <code>shift</code>: Number of fractional bits in the point coordinates.</li></ul></dd></dl><dl><dt class="spec value" id="val-rectangle2"><a href="#val-rectangle2" class="anchor"></a><code><span class="keyword">val</span> rectangle2 : <span>?&#8288;thickness:int</span> <span>&#45;&gt;</span> <span>?&#8288;line_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;shift:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-rect2i">rect2i</a> <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>rectangle2 ?thickness ?line_type ?shift img rect color</code></p><p>use <code>rec</code> parameter as alternative specification of the drawn rectangle: `r.tl() and r.br()-Point(1,1)` are opposite corners</p></dd></dl><dl><dt class="spec value" id="val-circle"><a href="#val-circle" class="anchor"></a><code><span class="keyword">val</span> circle : <span>?&#8288;thickness:int</span> <span>&#45;&gt;</span> <span>?&#8288;line_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;shift:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-point2i">point2i</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>circle ?thickness ?line_type ?shift img center radius color</code></p><p>Draws a circle.</p><p>The function cv::circle draws a simple or filled circle with a given center and radius.</p><ul><li>Parameter: <code>img</code>: Image where the circle is drawn.</li><li>Parameter: <code>center</code>: Center of the circle.</li><li>Parameter: <code>radius</code>: Radius of the circle.</li><li>Parameter: <code>color</code>: Circle color.</li><li>Parameter: <code>thickness</code>: Thickness of the circle outline, if positive. Negative values, like #FILLED, mean that a filled circle is to be drawn.</li><li>Parameter: <code>line_type</code>: Type of the circle boundary. See #LineTypes</li><li>Parameter: <code>shift</code>: Number of fractional bits in the coordinates of the center and in the radius value.</li></ul></dd></dl><dl><dt class="spec value" id="val-ellipse1"><a href="#val-ellipse1" class="anchor"></a><code><span class="keyword">val</span> ellipse1 : <span>?&#8288;thickness:int</span> <span>&#45;&gt;</span> <span>?&#8288;line_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;shift:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-point2i">point2i</a> <span>&#45;&gt;</span> <a href="index.html#type-size2i">size2i</a> <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>ellipse1 ?thickness ?line_type ?shift img center axes angle start_angle end_angle color</code></p><p>Draws a simple or thick elliptic arc or fills an ellipse sector.</p><p>The function cv::ellipse with more parameters draws an ellipse outline, a filled ellipse, an elliptic arc, or a filled ellipse sector. The drawing code uses general parametric form. A piecewise-linear curve is used to approximate the elliptic arc boundary. If you need more control of the ellipse rendering, you can retrieve the curve using #ellipse2Poly and then render it with #polylines or fill it with #fillPoly. If you use the first variant of the function and want to draw the whole ellipse, not an arc, pass <code>startAngle=0</code> and <code>endAngle=360</code>. If <code>startAngle</code> is greater than <code>endAngle</code>, they are swapped. The figure below explains the meaning of the parameters to draw the blue arc.</p><p>!<code>Parameters of Elliptic Arc</code>(pics/ellipse.svg)</p><ul><li>Parameter: <code>img</code>: Image.</li><li>Parameter: <code>center</code>: Center of the ellipse.</li><li>Parameter: <code>axes</code>: Half of the size of the ellipse main axes.</li><li>Parameter: <code>angle</code>: Ellipse rotation angle in degrees.</li><li>Parameter: <code>start_angle</code>: Starting angle of the elliptic arc in degrees.</li><li>Parameter: <code>end_angle</code>: Ending angle of the elliptic arc in degrees.</li><li>Parameter: <code>color</code>: Ellipse color.</li><li>Parameter: <code>thickness</code>: Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn.</li><li>Parameter: <code>line_type</code>: Type of the ellipse boundary. See #LineTypes</li><li>Parameter: <code>shift</code>: Number of fractional bits in the coordinates of the center and values of axes.</li></ul></dd></dl><dl><dt class="spec value" id="val-ellipse2"><a href="#val-ellipse2" class="anchor"></a><code><span class="keyword">val</span> ellipse2 : <span>?&#8288;thickness:int</span> <span>&#45;&gt;</span> <span>?&#8288;line_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-rotated_rect">rotated_rect</a> <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>ellipse2 ?thickness ?line_type img box color</code></p><ul><li>Parameter: <code>img</code>: Image.</li><li>Parameter: <code>box</code>: Alternative ellipse representation via RotatedRect. This means that the function draws an ellipse inscribed in the rotated rectangle.</li><li>Parameter: <code>color</code>: Ellipse color.</li><li>Parameter: <code>thickness</code>: Thickness of the ellipse arc outline, if positive. Otherwise, this indicates that a filled ellipse sector is to be drawn.</li><li>Parameter: <code>line_type</code>: Type of the ellipse boundary. See #LineTypes</li></ul></dd></dl><dl><dt class="spec value" id="val-draw_marker"><a href="#val-draw_marker" class="anchor"></a><code><span class="keyword">val</span> draw_marker : <span>?&#8288;marker_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;marker_size:int</span> <span>&#45;&gt;</span> <span>?&#8288;thickness:int</span> <span>&#45;&gt;</span> <span>?&#8288;line_type:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-point2i">point2i</a> <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>draw_marker ?marker_type ?marker_size ?thickness ?line_type img position color</code></p><p>Draws a marker on a predefined position in an image.</p><p>The function cv::drawMarker draws a marker on a given position in the image. For the moment several marker types are supported, see #MarkerTypes for more information.</p><ul><li>Parameter: <code>img</code>: Image.</li><li>Parameter: <code>position</code>: The point where the crosshair is positioned.</li><li>Parameter: <code>color</code>: Line color.</li><li>Parameter: <code>marker_type</code>: The specific type of marker you want to use, see #MarkerTypes</li><li>Parameter: <code>thickness</code>: Line thickness.</li><li>Parameter: <code>line_type</code>: Type of the line, See #LineTypes</li><li>Parameter: <code>marker_size</code>: The length of the marker axis <code>default = 20 pixels</code></li></ul></dd></dl><dl><dt class="spec value" id="val-fill_convex_poly"><a href="#val-fill_convex_poly" class="anchor"></a><code><span class="keyword">val</span> fill_convex_poly : <span>?&#8288;line_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;shift:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>fill_convex_poly ?line_type ?shift img points color</code></p><p>Fills a convex polygon.</p><p>The function cv::fillConvexPoly draws a filled convex polygon. This function is much faster than the function #fillPoly . It can fill not only convex polygons but any monotonic polygon without self-intersections, that is, a polygon whose contour intersects every horizontal line (scan line) twice at the most (though, its top-most and/or the bottom edge could be horizontal).</p><ul><li>Parameter: <code>img</code>: Image.</li><li>Parameter: <code>points</code>: Polygon vertices.</li><li>Parameter: <code>color</code>: Polygon color.</li><li>Parameter: <code>line_type</code>: Type of the polygon boundaries. See #LineTypes</li><li>Parameter: <code>shift</code>: Number of fractional bits in the vertex coordinates.</li></ul></dd></dl><dl><dt class="spec value" id="val-fill_poly"><a href="#val-fill_poly" class="anchor"></a><code><span class="keyword">val</span> fill_poly : <span>?&#8288;line_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;shift:int</span> <span>&#45;&gt;</span> <span>?&#8288;offset:<a href="index.html#type-point2i">point2i</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <span><a href="Cvdata/index.html#type-t">Cvdata.t</a> list</span> <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>fill_poly ?line_type ?shift ?offset img pts color</code></p><p>Fills the area bounded by one or more polygons.</p><p>The function cv::fillPoly fills an area bounded by several polygonal contours. The function can fill complex areas, for example, areas with holes, contours with self-intersections (some of their parts), and so forth.</p><ul><li>Parameter: <code>img</code>: Image.</li><li>Parameter: <code>pts</code>: Array of polygons where each polygon is represented as an array of points.</li><li>Parameter: <code>color</code>: Polygon color.</li><li>Parameter: <code>line_type</code>: Type of the polygon boundaries. See #LineTypes</li><li>Parameter: <code>shift</code>: Number of fractional bits in the vertex coordinates.</li><li>Parameter: <code>offset</code>: Optional offset of all points of the contours.</li></ul></dd></dl><dl><dt class="spec value" id="val-polylines"><a href="#val-polylines" class="anchor"></a><code><span class="keyword">val</span> polylines : <span>?&#8288;thickness:int</span> <span>&#45;&gt;</span> <span>?&#8288;line_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;shift:int</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <span><a href="Cvdata/index.html#type-t">Cvdata.t</a> list</span> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>polylines ?thickness ?line_type ?shift img pts is_closed color</code></p><p>Draws several polygonal curves.</p><ul><li>Parameter: <code>img</code>: Image.</li><li>Parameter: <code>pts</code>: Array of polygonal curves.</li><li>Parameter: <code>is_closed</code>: Flag indicating whether the drawn polylines are closed or not. If they are closed, the function draws a line from the last vertex of each curve to its first vertex.</li><li>Parameter: <code>color</code>: Polyline color.</li><li>Parameter: <code>thickness</code>: Thickness of the polyline edges.</li><li>Parameter: <code>line_type</code>: Type of the line segments. See #LineTypes</li><li>Parameter: <code>shift</code>: Number of fractional bits in the vertex coordinates.</li></ul><p>The function cv::polylines draws one or more polygonal curves.</p></dd></dl><dl><dt class="spec value" id="val-draw_contours"><a href="#val-draw_contours" class="anchor"></a><code><span class="keyword">val</span> draw_contours : <span>?&#8288;thickness:int</span> <span>&#45;&gt;</span> <span>?&#8288;line_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;hierarchy:<a href="Cvdata/index.html#type-t">Cvdata.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;max_level:int</span> <span>&#45;&gt;</span> <span>?&#8288;offset:<a href="index.html#type-point2i">point2i</a></span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <span><a href="Cvdata/index.html#type-t">Cvdata.t</a> list</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>draw_contours ?thickness ?line_type ?hierarchy ?max_level ?offset image contours contour_idx color</code></p><p>Draws contours outlines or filled contours.</p><p>The function draws contour outlines in the image if <code> \texttt{thickness} \ge 0 </code> or fills the area bounded by the contours if <code> \texttt{thickness}&lt;0 </code> . The example below shows how to retrieve connected components from the binary image and label them: : Include: snippets/imgproc_drawContours.cpp</p><ul><li>Parameter: <code>image</code>: Destination image.</li><li>Parameter: <code>contours</code>: All the input contours. Each contour is stored as a point vector.</li><li>Parameter: <code>contour_idx</code>: Parameter indicating a contour to draw. If it is negative, all the contours are drawn.</li><li>Parameter: <code>color</code>: Color of the contours.</li><li>Parameter: <code>thickness</code>: Thickness of lines the contours are drawn with. If it is negative (for example, thickness=#FILLED ), the contour interiors are drawn.</li><li>Parameter: <code>line_type</code>: Line connectivity. See #LineTypes</li><li>Parameter: <code>hierarchy</code>: Optional information about hierarchy. It is only needed if you want to draw only some of the contours (see maxLevel ).</li><li>Parameter: <code>max_level</code>: Maximal level for drawn contours. If it is 0, only the specified contour is drawn. If it is 1, the function draws the contour(s) and all the nested contours. If it is 2, the function draws the contours, all the nested contours, all the nested-to-nested contours, and so on. This parameter is only taken into account when there is hierarchy available.</li><li>Parameter: <code>offset</code>: Optional contour shift parameter. Shift all the drawn contours by the specified <code> \texttt{offset}=(dx,dy) </code> . Note: When thickness=#FILLED, the function is designed to handle connected components with holes correctly even when no hierarchy date is provided. This is done by analyzing all the outlines together using even-odd rule. This may give incorrect results if you have a joint collection of separately retrieved contours. In order to solve this problem, you need to call #drawContours separately for each sub-group of contours, or iterate over the collection using contourIdx parameter.</li></ul></dd></dl><dl><dt class="spec value" id="val-clip_line"><a href="#val-clip_line" class="anchor"></a><code><span class="keyword">val</span> clip_line : <a href="index.html#type-rect2i">rect2i</a> <span>&#45;&gt;</span> <a href="index.html#type-point2i">point2i</a> <span>&#45;&gt;</span> <a href="index.html#type-point2i">point2i</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>Usage: <code>clip_line img_rect pt1 pt2</code></p><ul><li>Parameter: <code>img_rect</code>: Image rectangle.</li><li>Parameter: <code>pt1</code>: First line point.</li><li>Parameter: <code>pt2</code>: Second line point.</li></ul></dd></dl><dl><dt class="spec value" id="val-ellipse2_poly"><a href="#val-ellipse2_poly" class="anchor"></a><code><span class="keyword">val</span> ellipse2_poly : <a href="index.html#type-point2i">point2i</a> <span>&#45;&gt;</span> <a href="index.html#type-size2i">size2i</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span><a href="index.html#type-point2i">point2i</a> list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>ellipse2_poly center axes angle arc_start arc_end delta pts</code></p><p>Approximates an elliptic arc with a polyline.</p><p>The function ellipse2Poly computes the vertices of a polyline that approximates the specified elliptic arc. It is used by #ellipse. If <code>arcStart</code> is greater than <code>arcEnd</code>, they are swapped.</p><ul><li>Parameter: <code>center</code>: Center of the arc.</li><li>Parameter: <code>axes</code>: Half of the size of the ellipse main axes. See #ellipse for details.</li><li>Parameter: <code>angle</code>: Rotation angle of the ellipse in degrees. See #ellipse for details.</li><li>Parameter: <code>arc_start</code>: Starting angle of the elliptic arc in degrees.</li><li>Parameter: <code>arc_end</code>: Ending angle of the elliptic arc in degrees.</li><li>Parameter: <code>delta</code>: Angle between the subsequent polyline vertices. It defines the approximation accuracy.</li><li>Parameter: <code>pts</code>: Output vector of polyline vertices.</li></ul></dd></dl><dl><dt class="spec value" id="val-put_text"><a href="#val-put_text" class="anchor"></a><code><span class="keyword">val</span> put_text : <span>?&#8288;thickness:int</span> <span>&#45;&gt;</span> <span>?&#8288;line_type:int</span> <span>&#45;&gt;</span> <span>?&#8288;bottom_left_origin:bool</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-point2i">point2i</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> <a href="Scalar/index.html#type-t">Scalar.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>put_text ?thickness ?line_type ?bottom_left_origin img text org font_face font_scale color</code></p><p>Draws a text string.</p><p>The function cv::putText renders the specified text string in the image. Symbols that cannot be rendered using the specified font are replaced by question marks. See #getTextSize for a text rendering code example.</p><ul><li>Parameter: <code>img</code>: Image.</li><li>Parameter: <code>text</code>: Text string to be drawn.</li><li>Parameter: <code>org</code>: Bottom-left corner of the text string in the image.</li><li>Parameter: <code>font_face</code>: Font type, see #HersheyFonts.</li><li>Parameter: <code>font_scale</code>: Font scale factor that is multiplied by the font-specific base size.</li><li>Parameter: <code>color</code>: Text color.</li><li>Parameter: <code>thickness</code>: Thickness of the lines used to draw a text.</li><li>Parameter: <code>line_type</code>: Line type. See #LineTypes</li><li>Parameter: <code>bottom_left_origin</code>: When true, the image data origin is at the bottom-left corner. Otherwise, it is at the top-left corner.</li></ul></dd></dl><dl><dt class="spec value" id="val-get_text_size"><a href="#val-get_text_size" class="anchor"></a><code><span class="keyword">val</span> get_text_size : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-size2i">size2i</a></code></dt><dd><p>Usage: <code>get_text_size text font_face font_scale thickness base_line</code></p><p>Calculates the width and height of a text string.</p><p>The function cv::getTextSize calculates and returns the size of a box that contains the specified text. That is, the following code renders some text, the tight box surrounding it, and the baseline: :</p><pre><code class="ml">String text = &quot;Funny text inside the box&quot;;
int fontFace = FONT_HERSHEY_SCRIPT_SIMPLEX;
double fontScale = 2;
int thickness = 3;

Mat img(600, 800, CV_8UC3, Scalar::all(0));

int baseline=0;
Size textSize = getTextSize(text, fontFace,
                            fontScale, thickness, &amp;baseline);
baseline += thickness;

// center the text
Point textOrg((img.cols - textSize.width)/2,
              (img.rows + textSize.height)/2);

// draw the box
rectangle(img, textOrg + Point(0, baseline),
          textOrg + Point(textSize.width, -textSize.height),
          Scalar(0,0,255));
// ... and the baseline first
line(img, textOrg + Point(0, thickness),
     textOrg + Point(textSize.width, thickness),
     Scalar(0, 0, 255));

// then put the text itself
putText(img, text, textOrg, fontFace, fontScale,
        Scalar::all(255), thickness, 8);</code></pre><ul><li>Parameter: <code>text</code>: Input text string.</li><li>Parameter: <code>font_face</code>: Font to use, see #HersheyFonts.</li><li>Parameter: <code>font_scale</code>: Font scale factor that is multiplied by the font-specific base size.</li><li>Parameter: <code>thickness</code>: Thickness of lines used to render the text. See #putText for details.</li><li>Parameter: <code>base_line</code>: y-coordinate of the baseline relative to the bottom-most text point.</li><li>Returns: The size of a box that contains the specified text.</li></ul><p>See also putText</p></dd></dl><dl><dt class="spec value" id="val-get_font_scale_from_height"><a href="#val-get_font_scale_from_height" class="anchor"></a><code><span class="keyword">val</span> get_font_scale_from_height : <span>?&#8288;thickness:int</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float</code></dt><dd><p>Usage: <code>get_font_scale_from_height ?thickness font_face pixel_height</code></p><p>Calculates the font-specific size to use to achieve a given height in pixels.</p><ul><li>Parameter: <code>font_face</code>: Font to use, see cv::HersheyFonts.</li><li>Parameter: <code>pixel_height</code>: Pixel height to compute the fontScale for</li><li>Parameter: <code>thickness</code>: Thickness of lines used to render the text.See putText for details.</li><li>Returns: The fontSize to use for cv::putText</li></ul><p>See also cv::putText</p></dd></dl><dl><dt class="spec value" id="val-named_window"><a href="#val-named_window" class="anchor"></a><code><span class="keyword">val</span> named_window : <span>?&#8288;flags:int</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>named_window ?flags winname</code></p><p>Creates a window.</p><p>The function namedWindow creates a window that can be used as a placeholder for images and trackbars. Created windows are referred to by their names.</p><p>If a window with the same name already exists, the function does nothing.</p><p>You can call cv::destroyWindow or cv::destroyAllWindows to close the window and de-allocate any associated memory usage. For a simple program, you do not really have to call these functions because all the resources and windows of the application are closed automatically by the operating system upon exit.</p><p>Note:</p><p>Qt backend supports additional flags:</p><ul><li>**WINDOW_NORMAL or WINDOW_AUTOSIZE:** WINDOW_NORMAL enables you to resize the window, whereas WINDOW_AUTOSIZE adjusts automatically the window size to fit the displayed image (see imshow ), and you cannot change the window size manually.</li><li>**WINDOW_FREERATIO or WINDOW_KEEPRATIO:** WINDOW_FREERATIO adjusts the image with no respect to its ratio, whereas WINDOW_KEEPRATIO keeps the image ratio.</li><li>**WINDOW_GUI_NORMAL or WINDOW_GUI_EXPANDED:** WINDOW_GUI_NORMAL is the old way to draw the window without statusbar and toolbar, whereas WINDOW_GUI_EXPANDED is a new enhanced GUI. By default, flags == WINDOW_AUTOSIZE | WINDOW_KEEPRATIO | WINDOW_GUI_EXPANDED</li></ul><ul><li>Parameter: <code>winname</code>: Name of the window in the window caption that may be used as a window identifier.</li><li>Parameter: <code>flags</code>: Flags of the window. The supported flags are: (cv::WindowFlags)</li></ul></dd></dl><dl><dt class="spec value" id="val-destroy_window"><a href="#val-destroy_window" class="anchor"></a><code><span class="keyword">val</span> destroy_window : string <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>destroy_window winname</code></p><p>Destroys the specified window.</p><p>The function destroyWindow destroys the window with the given name.</p><ul><li>Parameter: <code>winname</code>: Name of the window to be destroyed.</li></ul></dd></dl><dl><dt class="spec value" id="val-destroy_all_windows"><a href="#val-destroy_all_windows" class="anchor"></a><code><span class="keyword">val</span> destroy_all_windows : unit <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>destroy_all_windows ()</code></p><p>Destroys all of the HighGUI windows.</p><p>The function destroyAllWindows destroys all of the opened HighGUI windows.</p></dd></dl><dl><dt class="spec value" id="val-start_window_thread"><a href="#val-start_window_thread" class="anchor"></a><code><span class="keyword">val</span> start_window_thread : unit <span>&#45;&gt;</span> int</code></dt><dd><p>Usage: <code>start_window_thread ()</code></p></dd></dl><dl><dt class="spec value" id="val-wait_key_ex"><a href="#val-wait_key_ex" class="anchor"></a><code><span class="keyword">val</span> wait_key_ex : <span>?&#8288;delay:int</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> int</code></dt><dd><p>Usage: <code>wait_key_ex ?delay ()</code></p><p>Similar to #waitKey, but returns full key code.</p><p>Note:</p><p>Key code is implementation specific and depends on used backend: QT/GTK/Win32/etc</p></dd></dl><dl><dt class="spec value" id="val-wait_key"><a href="#val-wait_key" class="anchor"></a><code><span class="keyword">val</span> wait_key : <span>?&#8288;delay:int</span> <span>&#45;&gt;</span> unit <span>&#45;&gt;</span> int</code></dt><dd><p>Usage: <code>wait_key ?delay ()</code></p><p>Waits for a pressed key.</p><p>The function waitKey waits for a key event infinitely (when <code> \texttt{delay}\leq 0 </code> ) or for delay milliseconds, when it is positive. Since the OS has a minimum time between switching threads, the function will not wait exactly delay ms, it will wait at least delay ms, depending on what else is running on your computer at that time. It returns the code of the pressed key or -1 if no key was pressed before the specified time had elapsed.</p><p>Note:</p><p>This function is the only method in HighGUI that can fetch and handle events, so it needs to be called periodically for normal event processing unless HighGUI is used within an environment that takes care of event processing.</p><p>Note:</p><p>The function only works if there is at least one HighGUI window created and the window is active. If there are several HighGUI windows, any of them can be active.</p><ul><li>Parameter: <code>delay</code>: Delay in milliseconds. 0 is the special value that means &quot;forever&quot;.</li></ul></dd></dl><dl><dt class="spec value" id="val-imshow"><a href="#val-imshow" class="anchor"></a><code><span class="keyword">val</span> imshow : string <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>imshow winname mat</code></p><p>Displays an image in the specified window.</p><p>The function imshow displays an image in the specified window. If the window was created with the cv::WINDOW_AUTOSIZE flag, the image is shown with its original size, however it is still limited by the screen resolution. Otherwise, the image is scaled to fit the window. The function may scale the image, depending on its depth:</p><ul><li>If the image is 8-bit unsigned, it is displayed as is.</li><li>If the image is 16-bit unsigned or 32-bit integer, the pixels are divided by 256. That is, the value range <code>0,255\*256</code> is mapped to <code>0,255</code>.</li><li>If the image is 32-bit or 64-bit floating-point, the pixel values are multiplied by 255. That is, the value range <code>0,1</code> is mapped to <code>0,255</code>.</li></ul><p>If window was created with OpenGL support, cv::imshow also support ogl::Buffer , ogl::Texture2D and cuda::GpuMat as input.</p><p>If the window was not created before this function, it is assumed creating a window with cv::WINDOW_AUTOSIZE.</p><p>If you need to show an image that is bigger than the screen resolution, you will need to call namedWindow(&quot;&quot;, WINDOW_NORMAL) before the imshow.</p><p>Note: This function should be followed by cv::waitKey function which displays the image for specified milliseconds. Otherwise, it won't display the image. For example, **waitKey(0)** will display the window infinitely until any keypress (it is suitable for image display). **waitKey(25)** will display a frame for 25 ms, after which display will be automatically closed. (If you put it in a loop to read videos, it will display the video frame-by-frame)</p><p>Note:</p><p><code>__Windows Backend Only__</code> Pressing Ctrl+C will copy the image to the clipboard.</p><p><code>__Windows Backend Only__</code> Pressing Ctrl+S will show a dialog to save the image.</p><ul><li>Parameter: <code>winname</code>: Name of the window.</li><li>Parameter: <code>mat</code>: Image to be shown.</li></ul></dd></dl><dl><dt class="spec value" id="val-resize_window1"><a href="#val-resize_window1" class="anchor"></a><code><span class="keyword">val</span> resize_window1 : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>resize_window1 winname width height</code></p><p>Resizes the window to the specified size</p><p>Note:</p><ul><li>The specified window size is for the image area. Toolbars are not counted.</li><li>Only windows created without cv::WINDOW_AUTOSIZE flag can be resized.</li></ul><ul><li>Parameter: <code>winname</code>: Window name.</li><li>Parameter: <code>width</code>: The new window width.</li><li>Parameter: <code>height</code>: The new window height.</li></ul></dd></dl><dl><dt class="spec value" id="val-move_window"><a href="#val-move_window" class="anchor"></a><code><span class="keyword">val</span> move_window : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>move_window winname x y</code></p><p>Moves the window to the specified position</p><ul><li>Parameter: <code>winname</code>: Name of the window.</li><li>Parameter: <code>x</code>: The new x-coordinate of the window.</li><li>Parameter: <code>y</code>: The new y-coordinate of the window.</li></ul></dd></dl><dl><dt class="spec value" id="val-set_window_property"><a href="#val-set_window_property" class="anchor"></a><code><span class="keyword">val</span> set_window_property : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>set_window_property winname prop_id prop_value</code></p><p>Changes parameters of a window dynamically.</p><p>The function setWindowProperty enables changing properties of a window.</p><ul><li>Parameter: <code>winname</code>: Name of the window.</li><li>Parameter: <code>prop_id</code>: Window property to edit. The supported operation flags are: (cv::WindowPropertyFlags)</li><li>Parameter: <code>prop_value</code>: New value of the window property. The supported flags are: (cv::WindowFlags)</li></ul></dd></dl><dl><dt class="spec value" id="val-set_window_title"><a href="#val-set_window_title" class="anchor"></a><code><span class="keyword">val</span> set_window_title : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>set_window_title winname title</code></p><p>Updates window title</p><ul><li>Parameter: <code>winname</code>: Name of the window.</li><li>Parameter: <code>title</code>: New title.</li></ul></dd></dl><dl><dt class="spec value" id="val-get_window_property"><a href="#val-get_window_property" class="anchor"></a><code><span class="keyword">val</span> get_window_property : string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> float</code></dt><dd><p>Usage: <code>get_window_property winname prop_id</code></p><p>Provides parameters of a window.</p><p>The function getWindowProperty returns properties of a window.</p><ul><li>Parameter: <code>winname</code>: Name of the window.</li><li>Parameter: <code>prop_id</code>: Window property to retrieve. The following operation flags are available: (cv::WindowPropertyFlags)</li></ul><p>See also: setWindowProperty</p></dd></dl><dl><dt class="spec value" id="val-get_window_image_rect"><a href="#val-get_window_image_rect" class="anchor"></a><code><span class="keyword">val</span> get_window_image_rect : string <span>&#45;&gt;</span> <a href="index.html#type-rect2i">rect2i</a></code></dt><dd><p>Usage: <code>get_window_image_rect winname</code></p><p>Provides rectangle of image in the window.</p><p>The function getWindowImageRect returns the client screen coordinates, width and height of the image rendering area.</p><ul><li>Parameter: <code>winname</code>: Name of the window.</li></ul><p>See also: resizeWindow moveWindow</p></dd></dl><dl><dt class="spec value" id="val-select_roi1"><a href="#val-select_roi1" class="anchor"></a><code><span class="keyword">val</span> select_roi1 : <span>?&#8288;show_crosshair:bool</span> <span>&#45;&gt;</span> <span>?&#8288;from_center:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-rect2i">rect2i</a></code></dt><dd><p>Usage: <code>select_roi1 ?show_crosshair ?from_center window_name img</code></p><p>Allows users to select a ROI on the given image.</p><p>The function creates a window and allows users to select a ROI using the mouse. Controls: use <code>space</code> or <code>enter</code> to finish selection, use key <code>c</code> to cancel selection (function will return the zero cv::Rect).</p><ul><li>Parameter: <code>window_name</code>: name of the window where selection process will be shown.</li><li>Parameter: <code>img</code>: image to select a ROI.</li><li>Parameter: <code>show_crosshair</code>: if true crosshair of selection rectangle will be shown.</li><li>Parameter: <code>from_center</code>: if true center of selection will match initial mouse position. In opposite case a corner of selection rectangle will correspont to the initial mouse position.</li><li>Returns: selected ROI or empty rect if selection canceled.</li></ul><p>Note: The function sets it's own mouse callback for specified window using cv::setMouseCallback(windowName, ...). After finish of work an empty callback will be set for the used window.</p></dd></dl><dl><dt class="spec value" id="val-select_roi2"><a href="#val-select_roi2" class="anchor"></a><code><span class="keyword">val</span> select_roi2 : <span>?&#8288;show_crosshair:bool</span> <span>&#45;&gt;</span> <span>?&#8288;from_center:bool</span> <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <a href="index.html#type-rect2i">rect2i</a></code></dt><dd><p>Usage: <code>select_roi2 ?show_crosshair ?from_center img</code></p></dd></dl><dl><dt class="spec value" id="val-select_ro_is"><a href="#val-select_ro_is" class="anchor"></a><code><span class="keyword">val</span> select_ro_is : <span>?&#8288;show_crosshair:bool</span> <span>&#45;&gt;</span> <span>?&#8288;from_center:bool</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="Cvdata/index.html#type-t">Cvdata.t</a> <span>&#45;&gt;</span> <span><a href="index.html#type-rect2i">rect2i</a> list</span> <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>select_ro_is ?show_crosshair ?from_center window_name img bounding_boxes</code></p><p>Allows users to select multiple ROIs on the given image.</p><p>The function creates a window and allows users to select multiple ROIs using the mouse. Controls: use <code>space</code> or <code>enter</code> to finish current selection and start a new one, use <code>esc</code> to terminate multiple ROI selection process.</p><ul><li>Parameter: <code>window_name</code>: name of the window where selection process will be shown.</li><li>Parameter: <code>img</code>: image to select a ROI.</li><li>Parameter: <code>bounding_boxes</code>: selected ROIs.</li><li>Parameter: <code>show_crosshair</code>: if true crosshair of selection rectangle will be shown.</li><li>Parameter: <code>from_center</code>: if true center of selection will match initial mouse position. In opposite case a corner of selection rectangle will correspont to the initial mouse position.</li></ul><p>Note: The function sets it's own mouse callback for specified window using cv::setMouseCallback(windowName, ...). After finish of work an empty callback will be set for the used window.</p></dd></dl><dl><dt class="spec value" id="val-get_trackbar_pos"><a href="#val-get_trackbar_pos" class="anchor"></a><code><span class="keyword">val</span> get_trackbar_pos : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int</code></dt><dd><p>Usage: <code>get_trackbar_pos trackbarname winname</code></p><p>Returns the trackbar position.</p><p>The function returns the current position of the specified trackbar.</p><p>Note:</p><p><code>__Qt Backend Only__</code> winname can be empty if the trackbar is attached to the control panel.</p><ul><li>Parameter: <code>trackbarname</code>: Name of the trackbar.</li><li>Parameter: <code>winname</code>: Name of the window that is the parent of the trackbar.</li></ul></dd></dl><dl><dt class="spec value" id="val-set_trackbar_pos"><a href="#val-set_trackbar_pos" class="anchor"></a><code><span class="keyword">val</span> set_trackbar_pos : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>set_trackbar_pos trackbarname winname pos</code></p><p>Sets the trackbar position.</p><p>The function sets the position of the specified trackbar in the specified window.</p><p>Note:</p><p><code>__Qt Backend Only__</code> winname can be empty if the trackbar is attached to the control panel.</p><ul><li>Parameter: <code>trackbarname</code>: Name of the trackbar.</li><li>Parameter: <code>winname</code>: Name of the window that is the parent of trackbar.</li><li>Parameter: <code>pos</code>: New position.</li></ul></dd></dl><dl><dt class="spec value" id="val-set_trackbar_max"><a href="#val-set_trackbar_max" class="anchor"></a><code><span class="keyword">val</span> set_trackbar_max : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>set_trackbar_max trackbarname winname maxval</code></p><p>Sets the trackbar maximum position.</p><p>The function sets the maximum position of the specified trackbar in the specified window.</p><p>Note:</p><p><code>__Qt Backend Only__</code> winname can be empty if the trackbar is attached to the control panel.</p><ul><li>Parameter: <code>trackbarname</code>: Name of the trackbar.</li><li>Parameter: <code>winname</code>: Name of the window that is the parent of trackbar.</li><li>Parameter: <code>maxval</code>: New maximum position.</li></ul></dd></dl><dl><dt class="spec value" id="val-set_trackbar_min"><a href="#val-set_trackbar_min" class="anchor"></a><code><span class="keyword">val</span> set_trackbar_min : string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>set_trackbar_min trackbarname winname minval</code></p><p>Sets the trackbar minimum position.</p><p>The function sets the minimum position of the specified trackbar in the specified window.</p><p>Note:</p><p><code>__Qt Backend Only__</code> winname can be empty if the trackbar is attached to the control panel.</p><ul><li>Parameter: <code>trackbarname</code>: Name of the trackbar.</li><li>Parameter: <code>winname</code>: Name of the window that is the parent of trackbar.</li><li>Parameter: <code>minval</code>: New minimum position.</li></ul></dd></dl><dl><dt class="spec value" id="val-add_text"><a href="#val-add_text" class="anchor"></a><code><span class="keyword">val</span> add_text : <span>?&#8288;point_size:int</span> <span>&#45;&gt;</span> <span>?&#8288;color:<a href="Scalar/index.html#type-t">Scalar.t</a></span> <span>&#45;&gt;</span> <span>?&#8288;weight:int</span> <span>&#45;&gt;</span> <span>?&#8288;style:int</span> <span>&#45;&gt;</span> <span>?&#8288;spacing:int</span> <span>&#45;&gt;</span> <a href="Mat/index.html#type-t">Mat.t</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> <a href="index.html#type-point2i">point2i</a> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>add_text ?point_size ?color ?weight ?style ?spacing img text org name_font</code></p><p>Draws a text on the image.</p><ul><li>Parameter: <code>img</code>: 8-bit 3-channel image where the text should be drawn.</li><li>Parameter: <code>text</code>: Text to write on an image.</li><li>Parameter: <code>org</code>: Point(x,y) where the text should start on an image.</li><li>Parameter: <code>name_font</code>: Name of the font. The name should match the name of a system font (such as *Times* ). If the font is not found, a default one is used.</li><li>Parameter: <code>point_size</code>: Size of the font. If not specified, equal zero or negative, the point size of the font is set to a system-dependent default value. Generally, this is 12 points.</li><li>Parameter: <code>color</code>: Color of the font in BGRA where A = 255 is fully transparent.</li><li>Parameter: <code>weight</code>: Font weight. Available operation flags are : cv::QtFontWeights You can also specify a positive integer for better control.</li><li>Parameter: <code>style</code>: Font style. Available operation flags are : cv::QtFontStyles</li><li>Parameter: <code>spacing</code>: Spacing between characters. It can be negative or positive.</li></ul></dd></dl><dl><dt class="spec value" id="val-display_overlay"><a href="#val-display_overlay" class="anchor"></a><code><span class="keyword">val</span> display_overlay : <span>?&#8288;delayms:int</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>display_overlay ?delayms winname text</code></p><p>Displays a text on a window image as an overlay for a specified duration.</p><p>The function displayOverlay displays useful information/tips on top of the window for a certain amount of time *delayms*. The function does not modify the image, displayed in the window, that is, after the specified delay the original content of the window is restored.</p><ul><li>Parameter: <code>winname</code>: Name of the window.</li><li>Parameter: <code>text</code>: Overlay text to write on a window image.</li><li>Parameter: <code>delayms</code>: The period (in milliseconds), during which the overlay text is displayed. If this function is called before the previous overlay text timed out, the timer is restarted and the text is updated. If this value is zero, the text never disappears.</li></ul></dd></dl><dl><dt class="spec value" id="val-display_status_bar"><a href="#val-display_status_bar" class="anchor"></a><code><span class="keyword">val</span> display_status_bar : <span>?&#8288;delayms:int</span> <span>&#45;&gt;</span> string <span>&#45;&gt;</span> string <span>&#45;&gt;</span> unit</code></dt><dd><p>Usage: <code>display_status_bar ?delayms winname text</code></p><p>Displays a text on the window statusbar during the specified period of time.</p><p>The function displayStatusBar displays useful information/tips on top of the window for a certain amount of time *delayms* . This information is displayed on the window statusbar (the window must be created with the CV_GUI_EXPANDED flags).</p><ul><li>Parameter: <code>winname</code>: Name of the window.</li><li>Parameter: <code>text</code>: Text to write on the window statusbar.</li><li>Parameter: <code>delayms</code>: Duration (in milliseconds) to display the text. If this function is called before the previous text timed out, the timer is restarted and the text is updated. If this value is zero, the text never disappears.</li></ul></dd></dl><dl><dt class="spec module" id="module-Draw"><a href="#module-Draw" class="anchor"></a><code><span class="keyword">module</span> <a href="Draw/index.html">Draw</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>Allows for pure-functional drawing operations by queueing a sequence of operations to be drawn at once on a copy of the source image with <code>draw</code>.</p></dd></dl><div class="spec module" id="module-Cvconst"><a href="#module-Cvconst" class="anchor"></a><code><span class="keyword">module</span> <a href="Cvconst/index.html">Cvconst</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-(~~)"><a href="#val-(~~)" class="anchor"></a><code><span class="keyword">val</span> (~~) : <a href="Cvconst/index.html#type-cv_const">Cvconst.cv_const</a> <span>&#45;&gt;</span> int</code></dt></dl></div></body></html>