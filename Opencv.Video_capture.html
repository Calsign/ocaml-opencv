<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Opencv.Cv.html">
<link rel="next" href="Opencv.Video_writer.html">
<link rel="Up" href="Opencv.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Opencv" rel="Chapter" href="Opencv.html"><title>Opencv.Video_capture</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Opencv.Cv.html" title="Opencv.Cv">Previous</a>
&nbsp;<a class="up" href="Opencv.html" title="Opencv">Up</a>
&nbsp;<a class="post" href="Opencv.Video_writer.html" title="Opencv.Video_writer">Next</a>
</div>
<h1>Module <a href="type_Opencv.Video_capture.html">Opencv.Video_capture</a></h1>

<pre><span id="MODULEVideo_capture"><span class="keyword">module</span> Video_capture</span>: <code class="code">sig</code> <a href="Opencv.Video_capture.html">..</a> <code class="code">end</code></pre><hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> </pre>


<pre><span id="VALvideo_capture1"><span class="keyword">val</span> video_capture1</span> : <code class="type">unit -> <a href="Opencv.Video_capture.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Usage: <code class="code">video_capture1 ()</code></p>

<p>Default constructor
    Note:  In  videoio_c "C API", when you finished working with video, release CvCapture structure with
    cvReleaseCapture(), or use Ptr\&lt;CvCapture\&gt; that calls cvReleaseCapture() automatically in the
    destructor.</p>
</div>
</div>

<pre><span id="VALvideo_capture2"><span class="keyword">val</span> video_capture2</span> : <code class="type">?api_preference:int -> string -> <a href="Opencv.Video_capture.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Usage: <code class="code">video_capture2 ?api_preference filename</code></p>

<p>Opens a video file or a capturing device or an IP video stream for video capturing with API Preference</p>

<ul>
<li>Parameter: <code class="code">filename</code>: it can be:</li>
<li>name of video file (eg. <code class="code">video.avi</code>)</li>
<li>or image sequence (eg. <code class="code">img_%02d.jpg</code>, which will read samples like <code class="code">img_00.jpg, img_01.jpg, img_02.jpg, ...</code>)</li>
<li>or URL of video stream (eg. <code class="code">protocol://host:port/script_name?script_params|auth</code>)</li>
<li>or GStreamer pipeline string in gst-launch tool format in case if GStreamer is used as backend
      Note that each video stream or IP camera feed has its own URL scheme. Please refer to the
      documentation of source stream to know the right URL.</li>
<li>Parameter: <code class="code">api_preference</code>: preferred Capture API backends to use. Can be used to enforce a specific reader
    implementation if multiple are available: e.g. cv::CAP_FFMPEG or cv::CAP_IMAGES or cv::CAP_DSHOW.</li>
</ul>
<p>See also:  cv::VideoCaptureAPIs</p>
</div>
</div>

<pre><span id="VALvideo_capture3"><span class="keyword">val</span> video_capture3</span> : <code class="type">?api_preference:int -> int -> <a href="Opencv.Video_capture.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Usage: <code class="code">video_capture3 ?api_preference index</code></p>

<p>Opens a camera for video capturing</p>

<ul>
<li>Parameter: <code class="code">index</code>: id of the video capturing device to open. To open default camera using default backend just pass 0.
    (to backward compatibility usage of camera_id + domain_offset (CAP_* ) is valid when apiPreference is CAP_ANY)</li>
<li>Parameter: <code class="code">api_preference</code>: preferred Capture API backends to use. Can be used to enforce a specific reader
    implementation if multiple are available: e.g. cv::CAP_DSHOW or cv::CAP_MSMF or cv::CAP_V4L.</li>
</ul>
<p>See also:  cv::VideoCaptureAPIs</p>
</div>
</div>

<pre><span id="VALopen1"><span class="keyword">val</span> open1</span> : <code class="type">?api_preference:int -> <a href="Opencv.Video_capture.html#TYPEt">t</a> -> string -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>Usage: <code class="code">open1 ?api_preference __self filename</code></p>

<p>Opens a video file or a capturing device or an IP video stream for video capturing.</p>

<p>Parameters are same as the constructor VideoCapture(const String&amp; filename, int apiPreference = CAP_ANY)</p>
<ul>
<li>Returns: <code class="code">true</code> if the file has been successfully opened</li>
</ul>
<p>The method first calls VideoCapture::release to close the already opened file or camera.</p>
</div>
</div>

<pre><span id="VALopen2"><span class="keyword">val</span> open2</span> : <code class="type">?api_preference:int -> <a href="Opencv.Video_capture.html#TYPEt">t</a> -> int -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>Usage: <code class="code">open2 ?api_preference __self index</code></p>

<p>Opens a camera for video capturing</p>

<p>Parameters are same as the constructor VideoCapture(int index, int apiPreference = CAP_ANY)</p>
<ul>
<li>Returns: <code class="code">true</code> if the camera has been successfully opened.</li>
</ul>
<p>The method first calls VideoCapture::release to close the already opened file or camera.</p>
</div>
</div>

<pre><span id="VALis_opened"><span class="keyword">val</span> is_opened</span> : <code class="type"><a href="Opencv.Video_capture.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>Usage: <code class="code">is_opened __self</code></p>

<p>Returns true if video capturing has been initialized already.</p>

<p>If the previous call to VideoCapture constructor or VideoCapture::open() succeeded, the method returns
    true.</p>
</div>
</div>

<pre><span id="VALrelease"><span class="keyword">val</span> release</span> : <code class="type"><a href="Opencv.Video_capture.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Usage: <code class="code">release __self</code></p>

<p>Closes video file or capturing device.</p>

<p>The method is automatically called by subsequent VideoCapture::open and by VideoCapture
    destructor.</p>

<p>The C function also deallocates memory and clears \*capture pointer.</p>
</div>
</div>

<pre><span id="VALgrab"><span class="keyword">val</span> grab</span> : <code class="type"><a href="Opencv.Video_capture.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>Usage: <code class="code">grab __self</code></p>

<p>Grabs the next frame from video file or capturing device.</p>

<ul>
<li>Returns: <code class="code">true</code> (non-zero) in the case of success.</li>
</ul>
<p>The method/function grabs the next frame from video file or camera and returns true (non-zero) in
    the case of success.</p>

<p>The primary use of the function is in multi-camera environments, especially when the cameras do not
    have hardware synchronization. That is, you call VideoCapture::grab() for each camera and after that
    call the slower method VideoCapture::retrieve() to decode and get frame from each camera. This way
    the overhead on demosaicing or motion jpeg decompression etc. is eliminated and the retrieved frames
    from different cameras will be closer in time.</p>

<p>Also, when a connected camera is multi-head (for example, a stereo camera or a Kinect device), the
    correct way of retrieving data from it is to call VideoCapture::grab() first and then call
    VideoCapture::retrieve() one or more times with different values of the channel parameter.</p>

<p>tutorial_kinect_openni</p>
</div>
</div>

<pre><span id="VALretrieve"><span class="keyword">val</span> retrieve</span> : <code class="type">?image:<a href="Opencv.Cvdata.html#TYPEt">Opencv.Cvdata.t</a> -><br>       ?flag:int -> <a href="Opencv.Video_capture.html#TYPEt">t</a> -> <a href="Opencv.Cvdata.html#TYPEt">Opencv.Cvdata.t</a> * bool</code></pre><div class="info ">
<div class="info-desc">
<p>Usage: <code class="code">retrieve ?image ?flag __self</code></p>

<p>Decodes and returns the grabbed video frame.</p>

<ul>
<li>Parameter: []:return image the video frame is returned here. If no frames has been grabbed the image will be empty.</li>
<li>Parameter: <code class="code">flag</code>: it could be a frame index or a driver specific flag</li>
<li>Returns: <code class="code">false</code> if no frames has been grabbed</li>
</ul>
<p>The method decodes and returns the just grabbed frame. If no frames has been grabbed
    (camera has been disconnected, or there are no more frames in video file), the method returns false
    and the function returns an empty image (with %cv::Mat, test it with Mat::empty()).</p>

<p>See also:  read()</p>

<p>Note:  In  videoio_c "C API", functions cvRetrieveFrame() and cv.RetrieveFrame() return image stored inside the video
    capturing structure. It is not allowed to modify or release the image! You can copy the frame using
    cvCloneImage and then do whatever you want with the copy.</p>
</div>
</div>

<pre><span id="VALread"><span class="keyword">val</span> read</span> : <code class="type">?image:<a href="Opencv.Cvdata.html#TYPEt">Opencv.Cvdata.t</a> -> <a href="Opencv.Video_capture.html#TYPEt">t</a> -> <a href="Opencv.Cvdata.html#TYPEt">Opencv.Cvdata.t</a> * bool</code></pre><div class="info ">
<div class="info-desc">
<p>Usage: <code class="code">read ?image __self</code></p>

<p>Grabs, decodes and returns the next video frame.</p>

<ul>
<li>Parameter: []:return image the video frame is returned here. If no frames has been grabbed the image will be empty.</li>
<li>Returns: <code class="code">false</code> if no frames has been grabbed</li>
</ul>
<p>The method/function combines VideoCapture::grab() and VideoCapture::retrieve() in one call. This is the
    most convenient method for reading video files or capturing data from decode and returns the just
    grabbed frame. If no frames has been grabbed (camera has been disconnected, or there are no more
    frames in video file), the method returns false and the function returns empty image (with %cv::Mat, test it with Mat::empty()).</p>

<p>Note:  In  videoio_c "C API", functions cvRetrieveFrame() and cv.RetrieveFrame() return image stored inside the video
    capturing structure. It is not allowed to modify or release the image! You can copy the frame using
    cvCloneImage and then do whatever you want with the copy.</p>
</div>
</div>

<pre><span id="VALset"><span class="keyword">val</span> set</span> : <code class="type"><a href="Opencv.Video_capture.html#TYPEt">t</a> -> int -> float -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>Usage: <code class="code">set __self prop_id value</code></p>

<p>Sets a property in the VideoCapture.</p>

<ul>
<li>Parameter: <code class="code">prop_id</code>: Property identifier from cv::VideoCaptureProperties (eg. cv::CAP_PROP_POS_MSEC, cv::CAP_PROP_POS_FRAMES, ...)
    or one from  videoio_flags_others</li>
<li>Parameter: <code class="code">value</code>: Value of the property.</li>
<li>Returns: <code class="code">true</code> if the property is supported by backend used by the VideoCapture instance.
    Note:  Even if it returns <code class="code">true</code> this doesn't ensure that the property
    value has been accepted by the capture device. See note in VideoCapture::get()</li>
</ul>
</div>
</div>

<pre><span id="VALget"><span class="keyword">val</span> get</span> : <code class="type"><a href="Opencv.Video_capture.html#TYPEt">t</a> -> int -> float</code></pre><div class="info ">
<div class="info-desc">
<p>Usage: <code class="code">get __self prop_id</code></p>

<p>Returns the specified VideoCapture property</p>

<ul>
<li>Parameter: <code class="code">prop_id</code>: Property identifier from cv::VideoCaptureProperties (eg. cv::CAP_PROP_POS_MSEC, cv::CAP_PROP_POS_FRAMES, ...)
    or one from  videoio_flags_others</li>
<li>Returns: Value for the specified property. Value 0 is returned when querying a property that is
    not supported by the backend used by the VideoCapture instance.</li>
</ul>
<p>Note:  Reading / writing properties involves many layers. Some unexpected result might happens
    along this chain.</p>
<pre class="codepre"><code class="code"> 
    VideoCapture -&gt; API Backend -&gt; Operating System -&gt; Device Driver -&gt; Device Hardware
     </code></pre><p>The returned value might be different from what really used by the device or it could be encoded
    using device dependent rules (eg. steps or percentage). Effective behaviour depends from device
    driver and API Backend</p>
</div>
</div>

<pre><span id="VALget_backend_name"><span class="keyword">val</span> get_backend_name</span> : <code class="type"><a href="Opencv.Video_capture.html#TYPEt">t</a> -> string</code></pre><div class="info ">
<div class="info-desc">
<p>Usage: <code class="code">get_backend_name __self</code></p>

<p>Returns used backend API name</p>

<p>Note:  Stream should be opened.</p>
</div>
</div>

<pre><span id="VALset_exception_mode"><span class="keyword">val</span> set_exception_mode</span> : <code class="type"><a href="Opencv.Video_capture.html#TYPEt">t</a> -> bool -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Usage: <code class="code">set_exception_mode __self enable</code></p>

<p>Switches exceptions mode</p>

<p>methods raise exceptions if not successful instead of returning an error code</p>
</div>
</div>

<pre><span id="VALget_exception_mode"><span class="keyword">val</span> get_exception_mode</span> : <code class="type"><a href="Opencv.Video_capture.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>Usage: <code class="code">get_exception_mode __self</code></p>
</div>
</div>
</body></html>
